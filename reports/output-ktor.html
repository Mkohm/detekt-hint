<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>detekt report</title>
    <style>
h2 {
  background-color: #666666;
  padding: 0.2em;
  color: #ffffff;
}
h3 {
  background-color:#f8dfdf;
  padding:0.5em;
}
.rule {
  background-color: #dddddd;
  padding: 0.3em;
  font-weight: bold;
}
.description {
  color:#000000;
  padding:0.3em;
}
.location {
  color: #690505;
  font-family: monospace;
  display: block;
}
.message {
  font-size: 0.8em;
  color: #444444;
  display: block;
  margin-top: 1pt;
}
.rule-container {
  border: 0.1em dashed #dddddd;
  padding: 0.1em;
  line-height: 1.5em;
  margin-bottom: 8px;
  margin-top: 8px;
}
pre {
  border: 1px solid #e0e0e0;
  overflow: scroll;
}
.lineno {
  color: #999999;
  background-color: #f0f0f0;
}
.error {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AwCFR4T/3uLMgAAADxJREFUCNdNyLERQEAABMCjL4lQwIzcjErpguAL+C9AvgKJDbeD/PRpLdm35Hm+MU+cB+tCKaJW4L4YBy+CAiLJrFs9mgAAAABJRU5ErkJggg==) bottom repeat-x;
}
.exception {
  color: #b60808;
  display: inline-block;
  background-color: #ecdada;
  border-color: #b60808;
  border-radius: 10px;
  border: solid 2px;
  padding-left: 16px;
  padding-right: 16px;
  margin-bottom: 16px;
}
</style>
</head>
<body>

<h1>detekt report</h1>

<h2>Metrics</h2>

<div>
  <ul>
    <li>896 number of kt files</li>
    <li>123 number of packages</li>
    <li>1,354 number of classes</li>
    <li>6,223 number of functions</li>
    <li>7,166 number of properties</li>
  </ul>
</div>


<h2>Complexity Report</h2>

<div>
  <ul>
    <li>94,157 lines of code (loc)</li>
    <li>62,042 source lines of code (sloc)</li>
    <li>46,291 logical lines of code (lloc)</li>
    <li>17,182 comment lines of code (cloc)</li>
    <li>13,614 McCabe complexity (mcc)</li>
    <li>640 number of total code smells</li>
    <li>27% comment source ratio</li>
    <li>294 mcc per 1,000 lloc</li>
    <li>13 code smells per 1,000 lloc</li>
  </ul>
</div>


<h2>Findings</h2>
<div>Total: 640
  <h3>detekt-hint: 640</h3>
  <details id="InterfaceSegregationPrinciple" open="open">
    <summary class="rule-container"><span class="rule">InterfaceSegregationPrinciple: 46 </span><span class="description">This rule reports classes that violates the Interface Segregation Principle.</span></summary>
    <ul>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-apache/jvm/src/io/ktor/client/engine/apache/ApacheHttpRequest.kt:52:9</span><span class="message">completed is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  49 </span>            callContext.cancel(CancellationException(&quot;Failed to execute request&quot;, mappedCause))
<span class="lineno">  50 </span>        }
<span class="lineno">  51 </span>
<span class="lineno">  52 </span>        <span class="error">override fun completed(result: Unit) {}</span>
<span class="lineno">  53 </span>
<span class="lineno">  54 </span>        override fun cancelled() {
<span class="lineno">  55 </span>            callContext.cancel()
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-apache/jvm/src/io/ktor/client/engine/apache/ApacheRequestProducer.kt:66:5</span><span class="message">requestCompleted is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  63 </span>
<span class="lineno">  64 </span>    override fun generateRequest(): HttpRequest = request
<span class="lineno">  65 </span>
<span class="lineno">  66 </span>    <span class="error">override fun requestCompleted(context: HttpContext) {</span>
<span class="lineno">  67 </span><span class="error">    }</span>
<span class="lineno">  68 </span>
<span class="lineno">  69 </span>    override fun resetRequest() {}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-apache/jvm/src/io/ktor/client/engine/apache/ApacheRequestProducer.kt:69:5</span><span class="message">resetRequest is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  66 </span>    override fun requestCompleted(context: HttpContext) {
<span class="lineno">  67 </span>    }
<span class="lineno">  68 </span>
<span class="lineno">  69 </span>    <span class="error">override fun resetRequest() {}</span>
<span class="lineno">  70 </span>
<span class="lineno">  71 </span>    override fun failed(cause: Exception) {
<span class="lineno">  72 </span>        requestChannel.close(cause)
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-apache/jvm/src/io/ktor/client/engine/apache/ApacheResponseConsumerDispatching.kt:141:5</span><span class="message">close is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 138 </span>        return true
<span class="lineno"> 139 </span>    }
<span class="lineno"> 140 </span>
<span class="lineno"> 141 </span>    <span class="error">override fun close() {</span>
<span class="lineno"> 142 </span><span class="error">    }</span>
<span class="lineno"> 143 </span>
<span class="lineno"> 144 </span>    override fun getException(): Exception? {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-apache/jvm/src/io/ktor/client/engine/apache/ApacheResponseConsumerDispatching.kt:148:5</span><span class="message">getResult is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 145 </span>        return jobCompletionCause.value as? Exception
<span class="lineno"> 146 </span>    }
<span class="lineno"> 147 </span>
<span class="lineno"> 148 </span>    <span class="error">override fun getResult() {</span>
<span class="lineno"> 149 </span><span class="error">    }</span>
<span class="lineno"> 150 </span>
<span class="lineno"> 151 </span>    override fun isDone(): Boolean = job.isCompleted
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/cache/storage/DisabledCacheStorage.kt:11:5</span><span class="message">store is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.http.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span>internal object DisabledCacheStorage : HttpCacheStorage() {
<span class="lineno">  11 </span>    <span class="error">override fun store(url: Url, value: HttpCacheEntry) {}</span>
<span class="lineno">  12 </span>
<span class="lineno">  13 </span>    override fun find(url: Url, varyKeys: Map&lt;String, String&gt;): HttpCacheEntry? = null
<span class="lineno">  14 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/cookies/ConstantCookiesStorage.kt:17:5</span><span class="message">addCookie is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class CookiesStorage` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  14 </span>
<span class="lineno">  15 </span>    override suspend fun get(requestUrl: Url): List&lt;Cookie&gt; = storage.filter { it.matches(requestUrl) }
<span class="lineno">  16 </span>
<span class="lineno">  17 </span>    <span class="error">override suspend fun addCookie(requestUrl: Url, cookie: Cookie) {}</span>
<span class="lineno">  18 </span>
<span class="lineno">  19 </span>    override fun close() {}
<span class="lineno">  20 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/cookies/ConstantCookiesStorage.kt:19:5</span><span class="message">close is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  16 </span>
<span class="lineno">  17 </span>    override suspend fun addCookie(requestUrl: Url, cookie: Cookie) {}
<span class="lineno">  18 </span>
<span class="lineno">  19 </span>    <span class="error">override fun close() {}</span>
<span class="lineno">  20 </span>}
<span class="lineno">  21 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/js/src/io/ktor/client/features/websocket/JsWebSocketSession.kt:107:5</span><span class="message">flush is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 104 </span>        }
<span class="lineno"> 105 </span>    }
<span class="lineno"> 106 </span>
<span class="lineno"> 107 </span>    <span class="error">override suspend fun flush() {</span>
<span class="lineno"> 108 </span><span class="error">    }</span>
<span class="lineno"> 109 </span>
<span class="lineno"> 110 </span>    @Deprecated(
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-features/ktor-client-logging/common/src/io/ktor/client/features/logging/Logger.kt:35:9</span><span class="message">log is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  32 </span> */
<span class="lineno">  33 </span>val Logger.Companion.EMPTY: Logger
<span class="lineno">  34 </span>    get() = object : Logger {
<span class="lineno">  35 </span>        <span class="error">override fun log(message: String) {}</span>
<span class="lineno">  36 </span>    }
<span class="lineno">  37 </span>
<span class="lineno">  38 </span>private class SimpleLogger : Logger {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpWebsocketSession.kt:119:5</span><span class="message">flush is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 116 </span>        outgoing.close(t)
<span class="lineno"> 117 </span>    }
<span class="lineno"> 118 </span>
<span class="lineno"> 119 </span>    <span class="error">override suspend fun flush() {</span>
<span class="lineno"> 120 </span><span class="error">    }</span>
<span class="lineno"> 121 </span>
<span class="lineno"> 122 </span>    /**
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/websocket/FrameCommon.kt:126:5</span><span class="message">dispose is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 123 </span>}
<span class="lineno"> 124 </span>
<span class="lineno"> 125 </span>internal object NonDisposableHandle : DisposableHandle {
<span class="lineno"> 126 </span>    <span class="error">override fun dispose() {}</span>
<span class="lineno"> 127 </span>    override fun toString(): String = &quot;NonDisposableHandle&quot;
<span class="lineno"> 128 </span>}
<span class="lineno"> 129 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/AbstractInput.kt:434:13</span><span class="message">append is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 431 </span>                return this
<span class="lineno"> 432 </span>            }
<span class="lineno"> 433 </span>
<span class="lineno"> 434 </span>            <span class="error">override fun append(csq: CharSequence?, start: Int, end: Int): Appendable {</span>
<span class="lineno"> 435 </span><span class="error">                throw UnsupportedOperationException()</span>
<span class="lineno"> 436 </span><span class="error">            }</span>
<span class="lineno"> 437 </span>        }
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/BytePacketBuilder.kt:65:5</span><span class="message">closeDestination is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  62 </span>    internal val _pool: ObjectPool&lt;ChunkBuffer&gt;
<span class="lineno">  63 </span>        get() = pool
<span class="lineno">  64 </span>
<span class="lineno">  65 </span>    <span class="error">/**</span>
<span class="lineno">  66 </span><span class="error">     * Does nothing for memory-backed output</span>
<span class="lineno">  67 </span><span class="error">     */</span>
<span class="lineno">  68 </span><span class="error">    final override fun closeDestination() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/BytePacketBuilder.kt:71:5</span><span class="message">flush is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  68 </span>    final override fun closeDestination() {
<span class="lineno">  69 </span>    }
<span class="lineno">  70 </span>
<span class="lineno">  71 </span>    <span class="error">/**</span>
<span class="lineno">  72 </span><span class="error">     * Does nothing for memory-backed output</span>
<span class="lineno">  73 </span><span class="error">     */</span>
<span class="lineno">  74 </span><span class="error">    final override fun flush(source: Memory, offset: Int, length: Int) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/ByteReadPacket.kt:38:5</span><span class="message">closeSource is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  35 </span>        return 0
<span class="lineno">  36 </span>    }
<span class="lineno">  37 </span>
<span class="lineno">  38 </span>    <span class="error">final override fun closeSource() {</span>
<span class="lineno">  39 </span><span class="error">    }</span>
<span class="lineno">  40 </span>
<span class="lineno">  41 </span>    override fun toString(): String {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/internal/ChunkBuffer.kt:165:13</span><span class="message">dispose is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 162 </span>                require(instance === ChunkBuffer.Empty) { &quot;Only ChunkBuffer.Empty instance could be recycled.&quot; }
<span class="lineno"> 163 </span>            }
<span class="lineno"> 164 </span>
<span class="lineno"> 165 </span>            <span class="error">override fun dispose() {</span>
<span class="lineno"> 166 </span><span class="error">            }</span>
<span class="lineno"> 167 </span>        }
<span class="lineno"> 168 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/internal/ChunkBuffer.kt:185:13</span><span class="message">borrow is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 182 </span>        }
<span class="lineno"> 183 </span>
<span class="lineno"> 184 </span>        internal val NoPoolManuallyManaged: ObjectPool&lt;ChunkBuffer&gt; = object : NoPoolImpl&lt;ChunkBuffer&gt;() {
<span class="lineno"> 185 </span>            <span class="error">override fun borrow(): ChunkBuffer {</span>
<span class="lineno"> 186 </span><span class="error">                throw UnsupportedOperationException(&quot;This pool doesn't support borrow&quot;)</span>
<span class="lineno"> 187 </span><span class="error">            }</span>
<span class="lineno"> 188 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/internal/ChunkBuffer.kt:189:13</span><span class="message">recycle is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 186 </span>                throw UnsupportedOperationException(&quot;This pool doesn't support borrow&quot;)
<span class="lineno"> 187 </span>            }
<span class="lineno"> 188 </span>
<span class="lineno"> 189 </span>            <span class="error">override fun recycle(instance: ChunkBuffer) {</span>
<span class="lineno"> 190 </span><span class="error">                // do nothing: manually managed objects should be disposed manually</span>
<span class="lineno"> 191 </span><span class="error">            }</span>
<span class="lineno"> 192 </span>        }
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/internal/Require.kt:13:13</span><span class="message">doFail is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  10 </span>
<span class="lineno">  11 </span>    if (!condition) {
<span class="lineno">  12 </span>        val m = object : RequireFailureCapture() {
<span class="lineno">  13 </span>            <span class="error">override fun doFail(): Nothing {</span>
<span class="lineno">  14 </span><span class="error">                throw IllegalArgumentException(message())</span>
<span class="lineno">  15 </span><span class="error">            }</span>
<span class="lineno">  16 </span>        }
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/pool/Pool.kt:42:5</span><span class="message">recycle is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class ObjectPool` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  39 </span>    override val capacity: Int
<span class="lineno">  40 </span>        get() = 0
<span class="lineno">  41 </span>
<span class="lineno">  42 </span>    <span class="error">override fun recycle(instance: T) {</span>
<span class="lineno">  43 </span><span class="error">    }</span>
<span class="lineno">  44 </span>
<span class="lineno">  45 </span>    override fun dispose() {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/pool/Pool.kt:45:5</span><span class="message">dispose is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class ObjectPool` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  42 </span>    override fun recycle(instance: T) {
<span class="lineno">  43 </span>    }
<span class="lineno">  44 </span>
<span class="lineno">  45 </span>    <span class="error">override fun dispose() {</span>
<span class="lineno">  46 </span><span class="error">    }</span>
<span class="lineno">  47 </span>}
<span class="lineno">  48 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/js/src/io/ktor/utils/io/bits/MemoryFactoryJs.kt:54:5</span><span class="message">free is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  51 </span>internal actual object DefaultAllocator : Allocator {
<span class="lineno">  52 </span>    override fun alloc(size: Int): Memory = Memory(DataView(ArrayBuffer(size)))
<span class="lineno">  53 </span>    override fun alloc(size: Long): Memory = Memory(DataView(ArrayBuffer(size.toIntOrFail(&quot;size&quot;))))
<span class="lineno">  54 </span>    <span class="error">override fun free(instance: Memory) {</span>
<span class="lineno">  55 </span><span class="error">    }</span>
<span class="lineno">  56 </span>}
<span class="lineno">  57 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/js/src/io/ktor/utils/io/core/IoBufferJS.kt:293:5</span><span class="message">flush is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `actual class Output` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 290 </span>        return length
<span class="lineno"> 291 </span>    }
<span class="lineno"> 292 </span>
<span class="lineno"> 293 </span>    <span class="error">actual final override fun flush() {</span>
<span class="lineno"> 294 </span><span class="error">    }</span>
<span class="lineno"> 295 </span>
<span class="lineno"> 296 </span>    @PublishedApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/js/src/io/ktor/utils/io/core/IoBufferJS.kt:353:5</span><span class="message">close is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `actual class Input` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 350 </span>        releaseImpl(pool)
<span class="lineno"> 351 </span>    }
<span class="lineno"> 352 </span>
<span class="lineno"> 353 </span>    <span class="error">actual override fun close() {</span>
<span class="lineno"> 354 </span><span class="error">        throw UnsupportedOperationException(&quot;close for buffer view is not supported&quot;)</span>
<span class="lineno"> 355 </span><span class="error">    }</span>
<span class="lineno"> 356 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/bits/MemoryFactoryJvm.kt:44:5</span><span class="message">free is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  41 </span>
<span class="lineno">  42 </span>    override fun alloc(size: Long): Memory = alloc(size.toIntOrFail(&quot;size&quot;))
<span class="lineno">  43 </span>
<span class="lineno">  44 </span>    <span class="error">override fun free(instance: Memory) {</span>
<span class="lineno">  45 </span><span class="error">    }</span>
<span class="lineno">  46 </span>}
<span class="lineno">  47 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/core/IoBufferJVM.kt:426:5</span><span class="message">close is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `actual class Input` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 423 </span>        }
<span class="lineno"> 424 </span>    }
<span class="lineno"> 425 </span>
<span class="lineno"> 426 </span>    <span class="error">actual override fun close() {</span>
<span class="lineno"> 427 </span><span class="error">        throw UnsupportedOperationException(&quot;close for buffer view is not supported&quot;)</span>
<span class="lineno"> 428 </span><span class="error">    }</span>
<span class="lineno"> 429 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/core/IoBufferJVM.kt:435:5</span><span class="message">flush is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `actual class Output` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 432 </span>        return (this as Buffer).readText(decoder, out, lastBuffer, max)
<span class="lineno"> 433 </span>    }
<span class="lineno"> 434 </span>
<span class="lineno"> 435 </span>    <span class="error">actual final override fun flush() {</span>
<span class="lineno"> 436 </span><span class="error">    }</span>
<span class="lineno"> 437 </span>
<span class="lineno"> 438 </span>    @PublishedApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/streams/Streams.kt:135:9</span><span class="message">close is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 132 </span>            this@outputStream.writeFully(b, off, len)
<span class="lineno"> 133 </span>        }
<span class="lineno"> 134 </span>
<span class="lineno"> 135 </span>        <span class="error">override fun close() {</span>
<span class="lineno"> 136 </span><span class="error">        }</span>
<span class="lineno"> 137 </span>    }
<span class="lineno"> 138 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/streams/Streams.kt:149:9</span><span class="message">flush is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 146 </span>            append(cbuf, off, off + len)
<span class="lineno"> 147 </span>        }
<span class="lineno"> 148 </span>
<span class="lineno"> 149 </span>        <span class="error">override fun flush() {</span>
<span class="lineno"> 150 </span><span class="error">        }</span>
<span class="lineno"> 151 </span>
<span class="lineno"> 152 </span>        override fun close() {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/streams/Streams.kt:152:9</span><span class="message">close is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 149 </span>        override fun flush() {
<span class="lineno"> 150 </span>        }
<span class="lineno"> 151 </span>
<span class="lineno"> 152 </span>        <span class="error">override fun close() {</span>
<span class="lineno"> 153 </span><span class="error">        }</span>
<span class="lineno"> 154 </span>    }
<span class="lineno"> 155 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/core/IoBufferNative.kt:316:5</span><span class="message">flush is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `actual class Output` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 313 </span>        }
<span class="lineno"> 314 </span>    }
<span class="lineno"> 315 </span>
<span class="lineno"> 316 </span>    <span class="error">actual final override fun flush() {</span>
<span class="lineno"> 317 </span><span class="error">    }</span>
<span class="lineno"> 318 </span>
<span class="lineno"> 319 </span>    actual override fun close() {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/core/IoBufferNative.kt:319:5</span><span class="message">close is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `actual class Input` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 316 </span>    actual final override fun flush() {
<span class="lineno"> 317 </span>    }
<span class="lineno"> 318 </span>
<span class="lineno"> 319 </span>    <span class="error">actual override fun close() {</span>
<span class="lineno"> 320 </span><span class="error">        throw UnsupportedOperationException(&quot;close for buffer view is not supported&quot;)</span>
<span class="lineno"> 321 </span><span class="error">    }</span>
<span class="lineno"> 322 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/HttpBenchmarkClient.kt:21:5</span><span class="message">setup is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class HttpBenchmarkClient` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  18 </span>}
<span class="lineno">  19 </span>
<span class="lineno">  20 </span>class UrlHttpBenchmarkClient : HttpBenchmarkClient {
<span class="lineno">  21 </span>    <span class="error">override fun setup() {}</span>
<span class="lineno">  22 </span>    override fun shutdown() {}
<span class="lineno">  23 </span>    override fun load(url: String) {
<span class="lineno">  24 </span>        val urlConnection = URL(url).openConnection() as HttpURLConnection
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/HttpBenchmarkClient.kt:22:5</span><span class="message">shutdown is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class HttpBenchmarkClient` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  19 </span>
<span class="lineno">  20 </span>class UrlHttpBenchmarkClient : HttpBenchmarkClient {
<span class="lineno">  21 </span>    override fun setup() {}
<span class="lineno">  22 </span>    <span class="error">override fun shutdown() {}</span>
<span class="lineno">  23 </span>    override fun load(url: String) {
<span class="lineno">  24 </span>        val urlConnection = URL(url).openConnection() as HttpURLConnection
<span class="lineno">  25 </span>        urlConnection.setRequestProperty(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/PipelineBenchmark.kt:46:5</span><span class="message">resumeWith is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  43 </span>}
<span class="lineno">  44 </span>
<span class="lineno">  45 </span>private object NoopContinuation : Continuation&lt;Any?&gt; {
<span class="lineno">  46 </span>    <span class="error">override fun resumeWith(result: Result&lt;Any?&gt;) {}</span>
<span class="lineno">  47 </span>
<span class="lineno">  48 </span>    override val context: CoroutineContext = Dispatchers.Unconfined
<span class="lineno">  49 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/sessions/SessionTrackerByValue.kt:40:5</span><span class="message">clear is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class SessionTracker` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  37 </span>        }
<span class="lineno">  38 </span>    }
<span class="lineno">  39 </span>
<span class="lineno">  40 </span>    <span class="error">override suspend fun clear(call: ApplicationCall) {</span>
<span class="lineno">  41 </span><span class="error">        // it's stateless, so nothing to clear</span>
<span class="lineno">  42 </span><span class="error">    }</span>
<span class="lineno">  43 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/sessions/SessionTransportHeader.kt:33:5</span><span class="message">clear is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class SessionTransport` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  30 </span>        call.response.header(name, transformers.transformWrite(value))
<span class="lineno">  31 </span>    }
<span class="lineno">  32 </span>
<span class="lineno">  33 </span>    <span class="error">override fun clear(call: ApplicationCall) {}</span>
<span class="lineno">  34 </span>
<span class="lineno">  35 </span>    override fun toString(): String {
<span class="lineno">  36 </span>        return &quot;SessionTransportHeader: $name&quot;
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/cio/NettyResponsePipeline.kt:368:9</span><span class="message">upgrade is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 365 </span>            return if (lastTransformed) null else DefaultHttp2DataFrame(true)
<span class="lineno"> 366 </span>        }
<span class="lineno"> 367 </span>
<span class="lineno"> 368 </span>        <span class="error">override fun upgrade(dst: ChannelHandlerContext) {</span>
<span class="lineno"> 369 </span><span class="error">            throw IllegalStateException(&quot;HTTP/2 doesn't support upgrade&quot;)</span>
<span class="lineno"> 370 </span><span class="error">        }</span>
<span class="lineno"> 371 </span>    }
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/cio/NettyResponsePipeline.kt:384:9</span><span class="message">upgrade is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 381 </span>            return null
<span class="lineno"> 382 </span>        }
<span class="lineno"> 383 </span>
<span class="lineno"> 384 </span>        <span class="error">override fun upgrade(dst: ChannelHandlerContext) {</span>
<span class="lineno"> 385 </span><span class="error">            throw IllegalStateException(&quot;Already upgraded&quot;)</span>
<span class="lineno"> 386 </span><span class="error">        }</span>
<span class="lineno"> 387 </span>    }
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/http2/NettyHttp2ApplicationResponse.kt:42:5</span><span class="message">respondUpgrade is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  39 </span>        // as response pipeline is always sending at least one data frame
<span class="lineno">  40 </span>    }
<span class="lineno">  41 </span>
<span class="lineno">  42 </span>    <span class="error">override suspend fun respondUpgrade(upgrade: OutgoingContent.ProtocolUpgrade) {</span>
<span class="lineno">  43 </span><span class="error">        throw UnsupportedOperationException(&quot;HTTP/2 doesn't support upgrade&quot;)</span>
<span class="lineno">  44 </span><span class="error">    }</span>
<span class="lineno">  45 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/TestApplicationResponse.kt:58:5</span><span class="message">setStatus is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  55 </span>     */
<span class="lineno">  56 </span>    internal val responseChannelDeferred: CompletableJob = Job()
<span class="lineno">  57 </span>
<span class="lineno">  58 </span>    <span class="error">override fun setStatus(statusCode: HttpStatusCode) {}</span>
<span class="lineno">  59 </span>
<span class="lineno">  60 </span>    override val headers: ResponseHeaders = object : ResponseHeaders() {
<span class="lineno">  61 </span>        private val builder = HeadersBuilder()
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/common/src/io/ktor/util/NonceManager.kt:52:5</span><span class="message">newNonce is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  49 </span>@Deprecated(&quot;This should be removed with OAuth2StateProvider&quot;, level = DeprecationLevel.ERROR)
<span class="lineno">  50 </span>@InternalAPI
<span class="lineno">  51 </span>object AlwaysFailNonceManager : NonceManager {
<span class="lineno">  52 </span>    <span class="error">override suspend fun newNonce(): String {</span>
<span class="lineno">  53 </span><span class="error">        throw UnsupportedOperationException(&quot;This manager should never be used&quot;)</span>
<span class="lineno">  54 </span><span class="error">    }</span>
<span class="lineno">  55 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/common/src/io/ktor/util/NonceManager.kt:56:5</span><span class="message">verifyNonce is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  53 </span>        throw UnsupportedOperationException(&quot;This manager should never be used&quot;)
<span class="lineno">  54 </span>    }
<span class="lineno">  55 </span>
<span class="lineno">  56 </span>    <span class="error">override suspend fun verifyNonce(nonce: String): Boolean {</span>
<span class="lineno">  57 </span><span class="error">        throw UnsupportedOperationException(&quot;This manager should never be used&quot;)</span>
<span class="lineno">  58 </span><span class="error">    }</span>
<span class="lineno">  59 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/internal/LockFreeLinkedList.kt:769:5</span><span class="message">remove is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 766 </span>        }
<span class="lineno"> 767 </span>    }
<span class="lineno"> 768 </span>
<span class="lineno"> 769 </span>    <span class="error">// just a defensive programming -- makes sure that list head sentinel is never removed</span>
<span class="lineno"> 770 </span><span class="error">    public final override fun remove(): Boolean = throw UnsupportedOperationException()</span>
<span class="lineno"> 771 </span>
<span class="lineno"> 772 </span>    public final override fun describeRemove(): Nothing = throw UnsupportedOperationException()
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/internal/LockFreeLinkedList.kt:772:5</span><span class="message">describeRemove is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 769 </span>    // just a defensive programming -- makes sure that list head sentinel is never removed
<span class="lineno"> 770 </span>    public final override fun remove(): Boolean = throw UnsupportedOperationException()
<span class="lineno"> 771 </span>
<span class="lineno"> 772 </span>    <span class="error">public final override fun describeRemove(): Nothing = throw UnsupportedOperationException()</span>
<span class="lineno"> 773 </span>
<span class="lineno"> 774 </span>    internal fun validate() {
<span class="lineno"> 775 </span>        var prev: Node = this
</code></pre>
      </li>
    </ul>
  </details>
  <details id="LackOfCohesionMethods" open="open">
    <summary class="rule-container"><span class="rule">LackOfCohesionMethods: 148 </span><span class="description">This rule reports a file with low LCOM value.</span></summary>
    <ul>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-android/jvm/src/io/ktor/client/engine/android/Android.kt:19:1</span><span class="message">AndroidEngineContainer have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  16 </span>        AndroidClientEngine(AndroidEngineConfig().apply(block))
<span class="lineno">  17 </span>}
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  20 </span><span class="error">class AndroidEngineContainer : HttpClientEngineContainer {</span>
<span class="lineno">  21 </span><span class="error">    override val factory: HttpClientEngineFactory&lt;*&gt; = Android</span>
<span class="lineno">  22 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-apache/jvm/src/io/ktor/client/engine/apache/Apache.kt:23:1</span><span class="message">ApacheEngineContainer have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  20 </span>    }
<span class="lineno">  21 </span>}
<span class="lineno">  22 </span>
<span class="lineno">  23 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  24 </span><span class="error">class ApacheEngineContainer : HttpClientEngineContainer {</span>
<span class="lineno">  25 </span><span class="error">    override val factory: HttpClientEngineFactory&lt;*&gt; = Apache</span>
<span class="lineno">  26 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-apache/jvm/src/io/ktor/client/engine/apache/ApacheEngineConfig.kt:12:1</span><span class="message">ApacheEngineConfig have a too high LCOM value: 0.8571428571428572. Number of methods: 2, number of properties: 7, number of references: 2</span>
        <pre><code><span class="lineno">   9 </span>import org.apache.http.impl.nio.client.*
<span class="lineno">  10 </span>import javax.net.ssl.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">/**</span>
<span class="lineno">  13 </span><span class="error"> * Configuration for [Apache] implementation of [HttpClientEngineFactory].</span>
<span class="lineno">  14 </span><span class="error"> */</span>
<span class="lineno">  15 </span><span class="error">class ApacheEngineConfig : HttpClientEngineConfig() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-apache/jvm/src/io/ktor/client/engine/apache/ApacheRequestProducer.kt:31:1</span><span class="message">ApacheRequestProducer have a too high LCOM value: 0.8. Number of methods: 10, number of properties: 8, number of references: 16</span>
        <pre><code><span class="lineno">  28 </span>import java.nio.*
<span class="lineno">  29 </span>import kotlin.coroutines.*
<span class="lineno">  30 </span>
<span class="lineno">  31 </span><span class="error">internal class ApacheRequestProducer(</span>
<span class="lineno">  32 </span><span class="error">    private val requestData: HttpRequestData,</span>
<span class="lineno">  33 </span><span class="error">    private val config: ApacheEngineConfig,</span>
<span class="lineno">  34 </span><span class="error">    private val callContext: CoroutineContext</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-cio/jvm/src/io/ktor/client/engine/cio/CIO.kt:23:1</span><span class="message">CIOEngineContainer have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  20 </span>        CIOEngine(CIOEngineConfig().apply(block))
<span class="lineno">  21 </span>}
<span class="lineno">  22 </span>
<span class="lineno">  23 </span><span class="error">@InternalAPI</span>
<span class="lineno">  24 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  25 </span><span class="error">class CIOEngineContainer : HttpClientEngineContainer {</span>
<span class="lineno">  26 </span><span class="error">    override val factory: HttpClientEngineFactory&lt;*&gt; = CIO</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/HttpClient.kt:61:1</span><span class="message">HttpClient have a too high LCOM value: 0.8214285714285714. Number of methods: 8, number of properties: 14, number of references: 20</span>
        <pre><code><span class="lineno">  58 </span>    block: HttpClientConfig&lt;*&gt;.() -&gt; Unit
<span class="lineno">  59 </span>): HttpClient = HttpClient(engine, HttpClientConfig&lt;HttpClientEngineConfig&gt;().apply(block), manageEngine = false)
<span class="lineno">  60 </span>
<span class="lineno">  61 </span><span class="error">/**</span>
<span class="lineno">  62 </span><span class="error"> * Asynchronous client to perform HTTP requests.</span>
<span class="lineno">  63 </span><span class="error"> *</span>
<span class="lineno">  64 </span><span class="error"> * This is a generic implementation that uses a specific engine [HttpClientEngine].</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/call/SavedCall.kt:24:1</span><span class="message">SavedHttpResponse have a too high LCOM value: 0.875. Number of methods: 1, number of properties: 8, number of references: 1</span>
        <pre><code><span class="lineno">  21 </span>    override val call: SavedHttpCall, origin: HttpRequest
<span class="lineno">  22 </span>) : HttpRequest by origin
<span class="lineno">  23 </span>
<span class="lineno">  24 </span><span class="error">internal class SavedHttpResponse(</span>
<span class="lineno">  25 </span><span class="error">    override val call: SavedHttpCall, body: ByteArray, origin: HttpResponse</span>
<span class="lineno">  26 </span><span class="error">) : HttpResponse() {</span>
<span class="lineno">  27 </span><span class="error">    override val status: HttpStatusCode = origin.status</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/ExpectSuccess.kt:18:1</span><span class="message">ExpectSuccess have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  15 </span>@Suppress(&quot;KDocMissingDocumentation&quot;)
<span class="lineno">  16 </span>typealias BadResponseStatusException = ResponseException
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">@Deprecated(</span>
<span class="lineno">  19 </span><span class="error">    &quot;Use [HttpCallValidator] instead.&quot;,</span>
<span class="lineno">  20 </span><span class="error">    ReplaceWith(&quot;HttpCallValidator&quot;),</span>
<span class="lineno">  21 </span><span class="error">    DeprecationLevel.ERROR</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/HttpCallValidator.kt:27:1</span><span class="message">HttpCallValidator have a too high LCOM value: 0.8666666666666667. Number of methods: 5, number of properties: 3, number of references: 2</span>
        <pre><code><span class="lineno">  24 </span> */
<span class="lineno">  25 </span>typealias CallExceptionHandler = suspend (cause: Throwable) -&gt; Unit
<span class="lineno">  26 </span>
<span class="lineno">  27 </span><span class="error">/**</span>
<span class="lineno">  28 </span><span class="error"> * Response validator feature is used for validate response and handle response exceptions.</span>
<span class="lineno">  29 </span><span class="error"> *</span>
<span class="lineno">  30 </span><span class="error"> * See also [Config] for additional details.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/HttpPlainText.kt:19:1</span><span class="message">HttpPlainText have a too high LCOM value: 0.9428571428571428. Number of methods: 5, number of properties: 7, number of references: 2</span>
        <pre><code><span class="lineno">  16 </span>import io.ktor.utils.io.core.*
<span class="lineno">  17 </span>import kotlin.math.*
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">/**</span>
<span class="lineno">  20 </span><span class="error"> * [HttpClient] feature that encodes [String] request bodies to [TextContent]</span>
<span class="lineno">  21 </span><span class="error"> * and processes the response body as [String].</span>
<span class="lineno">  22 </span><span class="error"> *</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/HttpRequestLifecycle.kt:13:1</span><span class="message">HttpRequestLifecycle have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  10 </span>import io.ktor.util.pipeline.*
<span class="lineno">  11 </span>import kotlinx.coroutines.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">/**</span>
<span class="lineno">  14 </span><span class="error"> * Client HTTP feature that sets up [HttpRequestBuilder.executionContext] and completes it when the pipeline is fully</span>
<span class="lineno">  15 </span><span class="error"> * processed.</span>
<span class="lineno">  16 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/HttpTimeout.kt:15:1</span><span class="message">HttpTimeout have a too high LCOM value: 0.8333333333333334. Number of methods: 3, number of properties: 6, number of references: 3</span>
        <pre><code><span class="lineno">  12 </span>import kotlinx.coroutines.*
<span class="lineno">  13 </span>import kotlin.native.concurrent.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">/**</span>
<span class="lineno">  16 </span><span class="error"> * Client HTTP timeout feature. There are no default values, so default timeouts will be taken from engine configuration</span>
<span class="lineno">  17 </span><span class="error"> * or considered as infinite time if engine doesn't provide them.</span>
<span class="lineno">  18 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/UserAgent.kt:12:1</span><span class="message">UserAgent have a too high LCOM value: 0.8333333333333334. Number of methods: 3, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno">   9 </span>import io.ktor.http.*
<span class="lineno">  10 </span>import io.ktor.util.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">/**</span>
<span class="lineno">  13 </span><span class="error"> * Default user-agent feature for [HttpClient].</span>
<span class="lineno">  14 </span><span class="error"> *</span>
<span class="lineno">  15 </span><span class="error"> * @property agent: value of user-agent header to set.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/cache/HttpCache.kt:26:1</span><span class="message">HttpCache have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">  23 </span>    internal val MUST_REVALIDATE = HeaderValue(&quot;must-revalidate&quot;)
<span class="lineno">  24 </span>}
<span class="lineno">  25 </span>
<span class="lineno">  26 </span><span class="error">/**</span>
<span class="lineno">  27 </span><span class="error"> * This feature allow to use HTTP cache.</span>
<span class="lineno">  28 </span><span class="error"> *</span>
<span class="lineno">  29 </span><span class="error"> * For detailed description follow: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/cache/storage/HttpCacheStorage.kt:12:1</span><span class="message">HttpCacheStorage have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">   9 </span>import io.ktor.http.*
<span class="lineno">  10 </span>import io.ktor.util.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">/**</span>
<span class="lineno">  13 </span><span class="error"> * Cache storage interface.</span>
<span class="lineno">  14 </span><span class="error"> */</span>
<span class="lineno">  15 </span><span class="error">@KtorExperimentalAPI</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/cookies/HttpCookies.kt:17:1</span><span class="message">HttpCookies have a too high LCOM value: 0.9444444444444444. Number of methods: 6, number of properties: 3, number of references: 1</span>
        <pre><code><span class="lineno">  14 </span>import io.ktor.utils.io.core.*
<span class="lineno">  15 </span>import kotlinx.coroutines.*
<span class="lineno">  16 </span>
<span class="lineno">  17 </span><span class="error">/**</span>
<span class="lineno">  18 </span><span class="error"> * [HttpClient] feature that handles sent `Cookie`, and received `Set-Cookie` headers,</span>
<span class="lineno">  19 </span><span class="error"> * using a specific [storage] for storing and retrieving cookies.</span>
<span class="lineno">  20 </span><span class="error"> *</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/observer/ResponseObserver.kt:18:1</span><span class="message">ResponseObserver have a too high LCOM value: 0.875. Number of methods: 4, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno">  15 </span> */
<span class="lineno">  16 </span>typealias ResponseHandler = suspend (HttpResponse) -&gt; Unit
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">/**</span>
<span class="lineno">  19 </span><span class="error"> * Observe response feature.</span>
<span class="lineno">  20 </span><span class="error"> */</span>
<span class="lineno">  21 </span><span class="error">class ResponseObserver(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/request/DefaultHttpRequest.kt:13:1</span><span class="message">DefaultHttpRequest have a too high LCOM value: 0.8571428571428572. Number of methods: 1, number of properties: 7, number of references: 1</span>
        <pre><code><span class="lineno">  10 </span>import io.ktor.util.*
<span class="lineno">  11 </span>import kotlin.coroutines.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">/**</span>
<span class="lineno">  14 </span><span class="error"> * Default [HttpRequest] implementation.</span>
<span class="lineno">  15 </span><span class="error"> */</span>
<span class="lineno">  16 </span><span class="error">@InternalAPI</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/statement/DefaultHttpResponse.kt:15:1</span><span class="message">DefaultHttpResponse have a too high LCOM value: 0.875. Number of methods: 1, number of properties: 8, number of references: 1</span>
        <pre><code><span class="lineno">  12 </span>import io.ktor.utils.io.*
<span class="lineno">  13 </span>import kotlin.coroutines.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">@InternalAPI</span>
<span class="lineno">  16 </span><span class="error">class DefaultHttpResponse(</span>
<span class="lineno">  17 </span><span class="error">    override val call: HttpClientCall, responseData: HttpResponseData</span>
<span class="lineno">  18 </span><span class="error">) : HttpResponse() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/statement/HttpResponse.kt:16:1</span><span class="message">HttpResponse have a too high LCOM value: 0.8333333333333334. Number of methods: 1, number of properties: 6, number of references: 1</span>
        <pre><code><span class="lineno">  13 </span>import io.ktor.utils.io.*
<span class="lineno">  14 </span>import kotlinx.coroutines.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">/**</span>
<span class="lineno">  17 </span><span class="error"> * A response for [HttpClient], second part of [HttpClientCall].</span>
<span class="lineno">  18 </span><span class="error"> */</span>
<span class="lineno">  19 </span><span class="error">abstract class HttpResponse : HttpMessage, CoroutineScope {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/utils/AtomicBoolean.kt:7:1</span><span class="message">AtomicBoolean have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   4 </span>
<span class="lineno">   5 </span>package io.ktor.client.utils
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal expect class AtomicBoolean(value: Boolean) {</span>
<span class="lineno">   8 </span><span class="error"></span>
<span class="lineno">   9 </span><span class="error">    val value: Boolean</span>
<span class="lineno">  10 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-features/ktor-client-auth-basic/common/src/io/ktor/client/features/auth/basic/BasicAuth.kt:13:1</span><span class="message">BasicAuth have a too high LCOM value: 1.0. Number of methods: 4, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">  10 </span>import io.ktor.http.*
<span class="lineno">  11 </span>import io.ktor.util.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">/**</span>
<span class="lineno">  14 </span><span class="error"> * [HttpClient] feature that sets an `Authorization: basic` header</span>
<span class="lineno">  15 </span><span class="error"> * as specified in RFC-2617 using [username] and [password].</span>
<span class="lineno">  16 </span><span class="error"> *</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-features/ktor-client-json/common/src/io/ktor/client/features/json/JsonFeature.kt:27:1</span><span class="message">JsonFeature have a too high LCOM value: 0.95. Number of methods: 5, number of properties: 4, number of references: 1</span>
        <pre><code><span class="lineno">  24 </span> */
<span class="lineno">  25 </span>expect fun defaultSerializer(): JsonSerializer
<span class="lineno">  26 </span>
<span class="lineno">  27 </span><span class="error">/**</span>
<span class="lineno">  28 </span><span class="error"> * [HttpClient] feature that serializes/de-serializes as JSON custom objects</span>
<span class="lineno">  29 </span><span class="error"> * to request and from response bodies using a [serializer].</span>
<span class="lineno">  30 </span><span class="error"> *</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-features/ktor-client-json/ktor-client-json-tests/jvm/src/io/ktor/client/features/json/tests/JsonTest.kt:25:1</span><span class="message">JsonTest have a too high LCOM value: 0.8571428571428572. Number of methods: 7, number of properties: 2, number of references: 2</span>
        <pre><code><span class="lineno">  22 </span>import kotlinx.serialization.*
<span class="lineno">  23 </span>import kotlin.test.*
<span class="lineno">  24 </span>
<span class="lineno">  25 </span><span class="error">/** Base class for JSON tests. */</span>
<span class="lineno">  26 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  27 </span><span class="error">abstract class JsonTest : TestWithKtor() {</span>
<span class="lineno">  28 </span><span class="error">    val widget = Widget(&quot;Foo&quot;, 1000, listOf(&quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;))</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-features/ktor-client-logging/common/src/io/ktor/client/features/logging/Logging.kt:21:1</span><span class="message">Logging have a too high LCOM value: 0.95. Number of methods: 5, number of properties: 4, number of references: 1</span>
        <pre><code><span class="lineno">  18 </span>import io.ktor.utils.io.core.*
<span class="lineno">  19 </span>import kotlinx.coroutines.*
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">/**</span>
<span class="lineno">  22 </span><span class="error"> * [HttpClient] logging feature.</span>
<span class="lineno">  23 </span><span class="error"> */</span>
<span class="lineno">  24 </span><span class="error">class Logging(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-jetty/jvm/src/io/ktor/client/engine/jetty/Jetty.kt:22:1</span><span class="message">JettyEngineContainer have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  19 </span>        JettyHttp2Engine(JettyEngineConfig().apply(block))
<span class="lineno">  20 </span>}
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">@InternalAPI</span>
<span class="lineno">  23 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  24 </span><span class="error">class JettyEngineContainer : HttpClientEngineContainer {</span>
<span class="lineno">  25 </span><span class="error">    override val factory: HttpClientEngineFactory&lt;*&gt; = Jetty</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-mock/common/src/io/ktor/client/engine/mock/MockEngine.kt:14:1</span><span class="message">MockEngine have a too high LCOM value: 0.8666666666666667. Number of methods: 6, number of properties: 10, number of references: 8</span>
        <pre><code><span class="lineno">  11 </span>import kotlinx.atomicfu.locks.*
<span class="lineno">  12 </span>import kotlinx.coroutines.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">/**</span>
<span class="lineno">  15 </span><span class="error"> * [HttpClientEngine] for writing tests without network.</span>
<span class="lineno">  16 </span><span class="error"> */</span>
<span class="lineno">  17 </span><span class="error">class MockEngine(override val config: MockEngineConfig) : HttpClientEngineBase(&quot;ktor-mock&quot;) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttp.kt:19:1</span><span class="message">OkHttpEngineContainer have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  16 </span>        OkHttpEngine(OkHttpConfig().apply(block))
<span class="lineno">  17 </span>}
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  20 </span><span class="error">class OkHttpEngineContainer : HttpClientEngineContainer {</span>
<span class="lineno">  21 </span><span class="error">    override val factory: HttpClientEngineFactory&lt;*&gt; = OkHttp</span>
<span class="lineno">  22 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpWebsocketSession.kt:16:1</span><span class="message">OkHttpWebsocketSession have a too high LCOM value: 0.8692307692307693. Number of methods: 10, number of properties: 13, number of references: 17</span>
        <pre><code><span class="lineno">  13 </span>import okio.ByteString.Companion.toByteString
<span class="lineno">  14 </span>import kotlin.coroutines.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">@OptIn(ObsoleteCoroutinesApi::class)</span>
<span class="lineno">  17 </span><span class="error">internal class OkHttpWebsocketSession(</span>
<span class="lineno">  18 </span><span class="error">    private val engine: OkHttpClient,</span>
<span class="lineno">  19 </span><span class="error">    engineRequest: Request,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-tests/jvm/src/io/ktor/client/tests/utils/ClientLoader.kt:16:1</span><span class="message">ClientLoader have a too high LCOM value: 0.875. Number of methods: 4, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno">  13 </span>import org.junit.runners.*
<span class="lineno">  14 </span>import java.util.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">/**</span>
<span class="lineno">  17 </span><span class="error"> * Helper interface to test client.</span>
<span class="lineno">  18 </span><span class="error"> */</span>
<span class="lineno">  19 </span><span class="error">@RunWith(Parameterized::class)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/Authentication.kt:14:1</span><span class="message">Authentication have a too high LCOM value: 1.0. Number of methods: 8, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">  11 </span>import io.ktor.util.*
<span class="lineno">  12 </span>import org.slf4j.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">/**</span>
<span class="lineno">  15 </span><span class="error"> * Authentication feature supports pluggable mechanisms for checking and challenging a client to provide credentials</span>
<span class="lineno">  16 </span><span class="error"> *</span>
<span class="lineno">  17 </span><span class="error"> * @param config initial authentication configuration</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/AuthenticationContext.kt:13:1</span><span class="message">AuthenticationContext have a too high LCOM value: 0.85. Number of methods: 5, number of properties: 8, number of references: 6</span>
        <pre><code><span class="lineno">  10 </span>import kotlin.collections.HashMap
<span class="lineno">  11 </span>import kotlin.properties.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">/**</span>
<span class="lineno">  14 </span><span class="error"> * Represents an authentication context for the call</span>
<span class="lineno">  15 </span><span class="error"> * @param call instance of [ApplicationCall] this context is for</span>
<span class="lineno">  16 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/AuthenticationProcedureChallenge.kt:11:1</span><span class="message">AuthenticationProcedureChallenge have a too high LCOM value: 0.875. Number of methods: 2, number of properties: 4, number of references: 1</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.util.*
<span class="lineno">   9 </span>import io.ktor.util.pipeline.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * Represents authentication challenging procedure requested by authentication mechanism</span>
<span class="lineno">  13 </span><span class="error"> */</span>
<span class="lineno">  14 </span><span class="error">class AuthenticationProcedureChallenge {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/DigestAuth.kt:14:1</span><span class="message">DigestAuthenticationProvider have a too high LCOM value: 0.8. Number of methods: 1, number of properties: 5, number of references: 1</span>
        <pre><code><span class="lineno">  11 </span>import io.ktor.util.*
<span class="lineno">  12 </span>import java.security.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">/**</span>
<span class="lineno">  15 </span><span class="error"> * Represents a Digest authentication provider</span>
<span class="lineno">  16 </span><span class="error"> * @property realm specifies value to be passed in `WWW-Authenticate` header</span>
<span class="lineno">  17 </span><span class="error"> * @property algorithmName Message digest algorithm to be used. Usually only `MD5` is supported by clients.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/DigestAuth.kt:34:5</span><span class="message">Configuration have a too high LCOM value: 0.8. Number of methods: 1, number of properties: 5, number of references: 1</span>
        <pre><code><span class="lineno">  31 </span>    @KtorExperimentalAPI
<span class="lineno">  32 </span>    internal val userNameRealmPasswordDigestProvider: suspend (String, String) -&gt; ByteArray? = config.digestProvider
<span class="lineno">  33 </span>
<span class="lineno">  34 </span>    <span class="error">/**</span>
<span class="lineno">  35 </span><span class="error">     * Digest auth configuration</span>
<span class="lineno">  36 </span><span class="error">     */</span>
<span class="lineno">  37 </span><span class="error">    class Configuration internal constructor(name: String?) : AuthenticationProvider.Configuration(name) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/ForbiddenResponse.kt:11:1</span><span class="message">ForbiddenResponse have a too high LCOM value: 0.8333333333333334. Number of methods: 2, number of properties: 3, number of references: 1</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.http.*
<span class="lineno">   9 </span>import io.ktor.http.auth.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * Response content with `403 Forbidden` status code and `WWW-Authenticate` header of supplied [challenges]</span>
<span class="lineno">  13 </span><span class="error"> * @param challenges to be passed with `WWW-Authenticate` header</span>
<span class="lineno">  14 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-locations/jvm/src/io/ktor/locations/BackwardCompatibleImpl.kt:20:1</span><span class="message">LocationsImpl have a too high LCOM value: 0.92. Number of methods: 5, number of properties: 5, number of references: 2</span>
        <pre><code><span class="lineno">  17 </span>import kotlin.reflect.full.*
<span class="lineno">  18 </span>import kotlin.reflect.jvm.*
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">@OptIn(KtorExperimentalLocationsAPI::class)</span>
<span class="lineno">  21 </span><span class="error">internal abstract class LocationsImpl(</span>
<span class="lineno">  22 </span><span class="error">    protected val application: Application,</span>
<span class="lineno">  23 </span><span class="error">    protected val routeService: LocationRouteService</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-locations/jvm/src/io/ktor/locations/Locations.kt:13:1</span><span class="message">Locations have a too high LCOM value: 1.0. Number of methods: 8, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">  10 </span>import io.ktor.util.*
<span class="lineno">  11 </span>import kotlin.reflect.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">/**</span>
<span class="lineno">  14 </span><span class="error"> * Ktor feature that allows to handle and construct routes in a typed way.</span>
<span class="lineno">  15 </span><span class="error"> *</span>
<span class="lineno">  16 </span><span class="error"> * You have to create data classes/objects representing parameterized routes and annotate them with [Location].</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-metrics-micrometer/jvm/src/io/ktor/metrics/micrometer/MicrometerMetrics.kt:22:1</span><span class="message">MicrometerMetrics have a too high LCOM value: 0.9722222222222222. Number of methods: 4, number of properties: 9, number of references: 1</span>
        <pre><code><span class="lineno">  19 </span>import io.micrometer.core.instrument.distribution.*
<span class="lineno">  20 </span>import java.util.concurrent.atomic.*
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">/**</span>
<span class="lineno">  23 </span><span class="error"> * Enables Micrometer support when installed. Exposes the following metrics:</span>
<span class="lineno">  24 </span><span class="error"> * &lt;ul&gt;</span>
<span class="lineno">  25 </span><span class="error"> *     &lt;li&gt;&lt;code&gt;ktor.http.server.requests.active&lt;/code&gt;: Gauge - The amount of active ktor requests&lt;/li&gt;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-webjars/jvm/src/io/ktor/webjars/Webjars.kt:22:1</span><span class="message">Webjars have a too high LCOM value: 1.0. Number of methods: 4, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">  19 </span>import java.io.*
<span class="lineno">  20 </span>import java.time.*
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">/**</span>
<span class="lineno">  23 </span><span class="error"> * This feature listens to requests starting with the specified path prefix and responding with static content</span>
<span class="lineno">  24 </span><span class="error"> * packaged into webjars. A [WebJarAssetLocator] is used to look for static files.</span>
<span class="lineno">  25 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-websockets/jvm/src/io/ktor/websocket/WebSockets.kt:15:1</span><span class="message">WebSockets have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 7, number of references: 0</span>
        <pre><code><span class="lineno">  12 </span>import java.time.*
<span class="lineno">  13 </span>import kotlin.coroutines.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">/**</span>
<span class="lineno">  16 </span><span class="error"> * WebSockets support feature. It is required to be installed first before binding any websocket endpoints</span>
<span class="lineno">  17 </span><span class="error"> *</span>
<span class="lineno">  18 </span><span class="error"> * ```</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/ContentDisposition.kt:7:1</span><span class="message">ContentDisposition have a too high LCOM value: 0.9428571428571428. Number of methods: 5, number of properties: 14, number of references: 4</span>
        <pre><code><span class="lineno">   4 </span>
<span class="lineno">   5 </span>package io.ktor.http
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">/**</span>
<span class="lineno">   8 </span><span class="error"> * Represents `Content-Disposition` header value</span>
<span class="lineno">   9 </span><span class="error"> */</span>
<span class="lineno">  10 </span><span class="error">class ContentDisposition(disposition: String, parameters: List&lt;HeaderValueParam&gt; = emptyList()) :</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/ContentTypes.kt:9:1</span><span class="message">ContentType have a too high LCOM value: 0.9722222222222222. Number of methods: 9, number of properties: 56, number of references: 14</span>
        <pre><code><span class="lineno">   6 </span>
<span class="lineno">   7 </span>import io.ktor.utils.io.charsets.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">/**</span>
<span class="lineno">  10 </span><span class="error"> * Represents a value for a `Content-Type` header.</span>
<span class="lineno">  11 </span><span class="error"> * @property contentType represents a type part of the media type.</span>
<span class="lineno">  12 </span><span class="error"> * @property contentSubtype represents a subtype part of the media type.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/HttpMethod.kt:7:1</span><span class="message">HttpMethod have a too high LCOM value: 0.8888888888888888. Number of methods: 2, number of properties: 9, number of references: 2</span>
        <pre><code><span class="lineno">   4 </span>
<span class="lineno">   5 </span>package io.ktor.http
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">/**</span>
<span class="lineno">   8 </span><span class="error"> * Represents an HTTP method (verb)</span>
<span class="lineno">   9 </span><span class="error"> * @property value contains method name</span>
<span class="lineno">  10 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/HttpProtocolVersion.kt:8:1</span><span class="message">HttpProtocolVersion have a too high LCOM value: 0.8125. Number of methods: 4, number of properties: 8, number of references: 6</span>
        <pre><code><span class="lineno">   5 </span>package io.ktor.http
<span class="lineno">   6 </span>
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">/**</span>
<span class="lineno">   9 </span><span class="error"> * Represents an HTTP protocol version.</span>
<span class="lineno">  10 </span><span class="error"> * @property name specifies name of the protocol, e.g. &quot;HTTP&quot;.</span>
<span class="lineno">  11 </span><span class="error"> * @property major specifies protocol major version.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/HttpStatusCode.kt:7:1</span><span class="message">HttpStatusCode have a too high LCOM value: 0.9821428571428571. Number of methods: 6, number of properties: 56, number of references: 6</span>
        <pre><code><span class="lineno">   4 </span>
<span class="lineno">   5 </span>package io.ktor.http
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">/**</span>
<span class="lineno">   8 </span><span class="error"> * Represents an HTTP status code and description.</span>
<span class="lineno">   9 </span><span class="error"> * @param value is a numeric code.</span>
<span class="lineno">  10 </span><span class="error"> * @param description is free form description of a status.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/LinkHeader.kt:7:1</span><span class="message">LinkHeader have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 15, number of references: 0</span>
        <pre><code><span class="lineno">   4 </span>
<span class="lineno">   5 </span>package io.ktor.http
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">/**</span>
<span class="lineno">   8 </span><span class="error"> * Represents a `Link` header value as per RFC 5988</span>
<span class="lineno">   9 </span><span class="error"> */</span>
<span class="lineno">  10 </span><span class="error">class LinkHeader(uri: String, params: List&lt;HeaderValueParam&gt;) : HeaderValueWithParameters(&quot;&lt;$uri&gt;&quot;, params) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/URLProtocol.kt:9:1</span><span class="message">URLProtocol have a too high LCOM value: 0.875. Number of methods: 3, number of properties: 8, number of references: 3</span>
        <pre><code><span class="lineno">   6 </span>
<span class="lineno">   7 </span>import io.ktor.util.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">/**</span>
<span class="lineno">  10 </span><span class="error"> * Represents URL protocol</span>
<span class="lineno">  11 </span><span class="error"> * @property name of protocol (schema)</span>
<span class="lineno">  12 </span><span class="error"> * @property defaultPort default port for protocol or `-1` if not known</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/auth/HttpAuthHeader.kt:48:1</span><span class="message">HttpAuthHeader have a too high LCOM value: 0.9518518518518518. Number of methods: 18, number of properties: 15, number of references: 13</span>
        <pre><code><span class="lineno">  45 </span>}
<span class="lineno">  46 </span>
<span class="lineno">  47 </span>
<span class="lineno">  48 </span><span class="error">/**</span>
<span class="lineno">  49 </span><span class="error"> * Describes an authentication header with a mandatory [authScheme] that usually is a standard [AuthScheme].</span>
<span class="lineno">  50 </span><span class="error"> *</span>
<span class="lineno">  51 </span><span class="error"> * This can be of type [HttpAuthHeader.Single] or [HttpAuthHeader.Parameterized].</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/content/Multipart.kt:10:1</span><span class="message">PartData have a too high LCOM value: 0.8333333333333334. Number of methods: 1, number of properties: 6, number of references: 1</span>
        <pre><code><span class="lineno">   7 </span>import io.ktor.http.*
<span class="lineno">   8 </span>import io.ktor.utils.io.core.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">/**</span>
<span class="lineno">  11 </span><span class="error"> * Represents a multipart/form-data entry. Could be a [FormItem] or [FileItem]</span>
<span class="lineno">  12 </span><span class="error"> * @property dispose to be invoked when this part is no longed needed</span>
<span class="lineno">  13 </span><span class="error"> * @property headers of this part, could be inaccurate on some engines</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/content/OutgoingContent.kt:13:1</span><span class="message">OutgoingContent have a too high LCOM value: 1.0. Number of methods: 7, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  10 </span>import io.ktor.utils.io.*
<span class="lineno">  11 </span>import kotlin.coroutines.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">/**</span>
<span class="lineno">  14 </span><span class="error"> * Information about the content to be sent to the peer, recognized by a client or server engine</span>
<span class="lineno">  15 </span><span class="error"> */</span>
<span class="lineno">  16 </span><span class="error">sealed class OutgoingContent {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/content/OutgoingContent.kt:106:5</span><span class="message">ProtocolUpgrade have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno"> 103 </span>        abstract fun bytes(): ByteArray
<span class="lineno"> 104 </span>    }
<span class="lineno"> 105 </span>
<span class="lineno"> 106 </span>    <span class="error">/**</span>
<span class="lineno"> 107 </span><span class="error">     * Variant of a [OutgoingContent] for upgrading an HTTP connection</span>
<span class="lineno"> 108 </span><span class="error">     */</span>
<span class="lineno"> 109 </span><span class="error">    abstract class ProtocolUpgrade : OutgoingContent() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/jvm/src/io/ktor/http/content/Versions.kt:140:1</span><span class="message">EntityTagVersion have a too high LCOM value: 0.85. Number of methods: 10, number of properties: 4, number of references: 6</span>
        <pre><code><span class="lineno"> 137 </span>    return EntityTagVersion.parseSingle(spec)
<span class="lineno"> 138 </span>}
<span class="lineno"> 139 </span>
<span class="lineno"> 140 </span><span class="error">/**</span>
<span class="lineno"> 141 </span><span class="error"> * This version checks [etag] value and pass it through conditions supplied by the remote client. Depending on conditions it</span>
<span class="lineno"> 142 </span><span class="error"> * produces return value of enum type [VersionCheckResult]</span>
<span class="lineno"> 143 </span><span class="error"> *</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/internals/AsciiCharTree.kt:7:1</span><span class="message">AsciiCharTree have a too high LCOM value: 0.8125. Number of methods: 4, number of properties: 4, number of references: 3</span>
        <pre><code><span class="lineno">   4 </span>
<span class="lineno">   5 </span>package io.ktor.http.cio.internals
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class AsciiCharTree&lt;T : Any&gt;(val root: Node&lt;T&gt;) {</span>
<span class="lineno">   8 </span><span class="error">    class Node&lt;T&gt;(val ch: Char, val exact: List&lt;T&gt;, val children: List&lt;Node&lt;T&gt;&gt;) {</span>
<span class="lineno">   9 </span><span class="error">        val array = Array(0x100) { chi -&gt; children.singleOrNull { it.ch.toInt() == chi } }</span>
<span class="lineno">  10 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/js/src/io/ktor/http/cio/websocket/FrameJs.kt:10:1</span><span class="message">Frame have a too high LCOM value: 1.0. Number of methods: 4, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   7 </span>import kotlinx.coroutines.*
<span class="lineno">   8 </span>import io.ktor.utils.io.core.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">/**</span>
<span class="lineno">  11 </span><span class="error"> * A frame received or ready to be sent. It is not reusable and not thread-safe</span>
<span class="lineno">  12 </span><span class="error"> * @property fin is it final fragment, should be always `true` for control frames and if no fragmentation is used</span>
<span class="lineno">  13 </span><span class="error"> * @property frameType enum value</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/internals/WeakTimeoutQueue.kt:14:1</span><span class="message">WeakTimeoutQueue have a too high LCOM value: 0.8636363636363636. Number of methods: 11, number of properties: 4, number of references: 6</span>
        <pre><code><span class="lineno">  11 </span>import kotlin.coroutines.*
<span class="lineno">  12 </span>import kotlin.coroutines.intrinsics.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">/**</span>
<span class="lineno">  15 </span><span class="error"> * It provides ability to cancel jobs and schedule coroutine with timeout. Unlike regular withTimeout</span>
<span class="lineno">  16 </span><span class="error"> * this implementation is never scheduling timer tasks but only checks for current time. This makes timeout measurement</span>
<span class="lineno">  17 </span><span class="error"> * much cheaper and doesn't require any watchdog thread.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/internals/WeakTimeoutQueue.kt:124:5</span><span class="message">Cancellable have a too high LCOM value: 0.8333333333333334. Number of methods: 3, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno"> 121 </span>        }
<span class="lineno"> 122 </span>    }
<span class="lineno"> 123 </span>
<span class="lineno"> 124 </span>    <span class="error">private abstract class Cancellable(</span>
<span class="lineno"> 125 </span><span class="error">        val deadline: Long</span>
<span class="lineno"> 126 </span><span class="error">    ) : LockFreeLinkedListNode(), Registration {</span>
<span class="lineno"> 127 </span><span class="error">        open val isActive: Boolean</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/websocket/Frame.kt:12:1</span><span class="message">Frame have a too high LCOM value: 1.0. Number of methods: 5, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   9 </span>import kotlinx.coroutines.*
<span class="lineno">  10 </span>import java.nio.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">/**</span>
<span class="lineno">  13 </span><span class="error"> * A frame received or ready to be sent. It is not reusable and not thread-safe</span>
<span class="lineno">  14 </span><span class="error"> * @property fin is it final fragment, should be always `true` for control frames and if no fragmentation is used</span>
<span class="lineno">  15 </span><span class="error"> * @property frameType enum value</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/posix/src/io/ktor/http/cio/websocket/FrameNative.kt:10:1</span><span class="message">Frame have a too high LCOM value: 1.0. Number of methods: 4, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   7 </span>import kotlinx.coroutines.*
<span class="lineno">   8 </span>import io.ktor.utils.io.core.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">/**</span>
<span class="lineno">  11 </span><span class="error"> * A frame received or ready to be sent. It is not reusable and not thread-safe</span>
<span class="lineno">  12 </span><span class="error"> * @property fin is it final fragment, should be always `true` for control frames and if no fragmentation is used</span>
<span class="lineno">  13 </span><span class="error"> * @property frameType enum value</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/ByteChannelSequential.kt:22:1</span><span class="message">ByteChannelSequentialBase have a too high LCOM value: 0.8208333333333333. Number of methods: 48, number of properties: 20, number of references: 172</span>
        <pre><code><span class="lineno">  19 </span>    return copyToSequentialImpl(dst, limit)
<span class="lineno">  20 </span>}
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">/**</span>
<span class="lineno">  23 </span><span class="error"> * Sequential (non-concurrent) byte channel implementation</span>
<span class="lineno">  24 </span><span class="error"> */</span>
<span class="lineno">  25 </span><span class="error">@Suppress(&quot;OverridingDeprecatedMember&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/bits/Memory.kt:7:1</span><span class="message">Memory have a too high LCOM value: 1.0. Number of methods: 8, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">   4 </span>
<span class="lineno">   5 </span>import io.ktor.utils.io.core.*
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">/**</span>
<span class="lineno">   8 </span><span class="error"> * Represents a linear range of bytes.</span>
<span class="lineno">   9 </span><span class="error"> * All operations are guarded by range-checks by default however at some platforms they could be disabled</span>
<span class="lineno">  10 </span><span class="error"> * in release builds.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/AbstractInput.kt:10:1</span><span class="message">AbstractInput have a too high LCOM value: 0.8755760368663594. Number of methods: 31, number of properties: 14, number of references: 54</span>
        <pre><code><span class="lineno">   7 </span>import io.ktor.utils.io.core.internal.require
<span class="lineno">   8 </span>import io.ktor.utils.io.pool.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">/**</span>
<span class="lineno">  11 </span><span class="error"> * The default abstract base class implementing [Input] interface.</span>
<span class="lineno">  12 </span><span class="error"> * @see [AbstractInput.fill] and [AbstractInput.closeSource].</span>
<span class="lineno">  13 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/AbstractOutput.kt:10:1</span><span class="message">AbstractOutput have a too high LCOM value: 0.9454545454545454. Number of methods: 22, number of properties: 15, number of references: 18</span>
        <pre><code><span class="lineno">   7 </span>import io.ktor.utils.io.core.internal.*
<span class="lineno">   8 </span>import io.ktor.utils.io.pool.ObjectPool
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">/**</span>
<span class="lineno">  11 </span><span class="error"> * The default [Output] implementation.</span>
<span class="lineno">  12 </span><span class="error"> * @see flush</span>
<span class="lineno">  13 </span><span class="error"> * @see closeDestination</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/Buffers.kt:8:1</span><span class="message">IoBuffer have a too high LCOM value: 1.0. Number of methods: 4, number of properties: 6, number of references: 0</span>
        <pre><code><span class="lineno">   5 </span>import io.ktor.utils.io.pool.*
<span class="lineno">   6 </span>import kotlin.contracts.*
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">/**</span>
<span class="lineno">   9 </span><span class="error"> * A read-write facade to actual buffer of fixed size. Multiple views could share the same actual buffer.</span>
<span class="lineno">  10 </span><span class="error"> * Concurrent unsafe. The only concurrent-safe operation is [release].</span>
<span class="lineno">  11 </span><span class="error"> * In most cases [ByteReadPacket] and [BytePacketBuilder] should be used instead.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/BytePacketBuilder.kt:20:1</span><span class="message">BytePacketBuilder have a too high LCOM value: 0.9428571428571428. Number of methods: 14, number of properties: 5, number of references: 4</span>
        <pre><code><span class="lineno">  17 </span>import kotlin.check
<span class="lineno">  18 </span>import kotlin.jvm.JvmName
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">/**</span>
<span class="lineno">  21 </span><span class="error"> * A builder that provides ability to build byte packets with no knowledge of it's size.</span>
<span class="lineno">  22 </span><span class="error"> * Unlike Java's ByteArrayOutputStream it doesn't copy the whole content every time it's internal buffer overflows</span>
<span class="lineno">  23 </span><span class="error"> * but chunks buffers instead. Packet building via [build] function is O(1) operation and only does instantiate</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/ByteReadPacket.kt:9:1</span><span class="message">ByteReadPacket have a too high LCOM value: 1.0. Number of methods: 8, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">   6 </span>import io.ktor.utils.io.core.internal.*
<span class="lineno">   7 </span>import io.ktor.utils.io.pool.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">/**</span>
<span class="lineno">  10 </span><span class="error"> * Read-only immutable byte packet. Could be consumed only once however it does support [copy] that doesn't copy every byte</span>
<span class="lineno">  11 </span><span class="error"> * but creates a new view instead. Once packet created it should be either completely read (consumed) or released</span>
<span class="lineno">  12 </span><span class="error"> * via [release].</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/Packet.kt:9:1</span><span class="message">ByteReadPacketBase have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   6 </span>import io.ktor.utils.io.errors.*
<span class="lineno">   7 </span>import io.ktor.utils.io.pool.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">@DangerousInternalIoApi</span>
<span class="lineno">  10 </span><span class="error">@Deprecated(</span>
<span class="lineno">  11 </span><span class="error">    &quot;Will be removed in the future releases. Use Input or AbstractInput instead.&quot;,</span>
<span class="lineno">  12 </span><span class="error">    ReplaceWith(&quot;AbstractInput&quot;, &quot;io.ktor.utils.io.core.AbstractInput&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/internal/ChunkBuffer.kt:12:1</span><span class="message">ChunkBuffer have a too high LCOM value: 0.88. Number of methods: 5, number of properties: 10, number of references: 6</span>
        <pre><code><span class="lineno">   9 </span>import io.ktor.utils.io.core.*
<span class="lineno">  10 </span>import io.ktor.utils.io.pool.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">@DangerousInternalIoApi</span>
<span class="lineno">  13 </span><span class="error">open class ChunkBuffer internal constructor(memory: Memory, origin: ChunkBuffer?) : Buffer(memory) {</span>
<span class="lineno">  14 </span><span class="error">    init {</span>
<span class="lineno">  15 </span><span class="error">        require(origin !== this) { &quot;A chunk couldn't be a view of itself.&quot; }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/pool/Pool.kt:35:1</span><span class="message">NoPoolImpl have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  32 </span>    override fun close() = dispose()
<span class="lineno">  33 </span>}
<span class="lineno">  34 </span>
<span class="lineno">  35 </span><span class="error">/**</span>
<span class="lineno">  36 </span><span class="error"> * A pool implementation of zero capacity that always creates new instances</span>
<span class="lineno">  37 </span><span class="error"> */</span>
<span class="lineno">  38 </span><span class="error">abstract class NoPoolImpl&lt;T : Any&gt; : ObjectPool&lt;T&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/pool/Pool.kt:111:1</span><span class="message">DefaultPool have a too high LCOM value: 1.0. Number of methods: 7, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno"> 108 </span>    }
<span class="lineno"> 109 </span>}
<span class="lineno"> 110 </span>
<span class="lineno"> 111 </span><span class="error">/**</span>
<span class="lineno"> 112 </span><span class="error"> * Default object pool implementation.</span>
<span class="lineno"> 113 </span><span class="error"> */</span>
<span class="lineno"> 114 </span><span class="error">expect abstract class DefaultPool&lt;T : Any&gt;(capacity: Int) : ObjectPool&lt;T&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/js/src/io/ktor/utils/io/core/IoBufferJS.kt:11:1</span><span class="message">IoBuffer have a too high LCOM value: 0.9962962962962963. Number of methods: 54, number of properties: 10, number of references: 2</span>
        <pre><code><span class="lineno">   8 </span>import org.khronos.webgl.*
<span class="lineno">   9 </span>import kotlin.contracts.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">@Suppress(&quot;DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES&quot;)</span>
<span class="lineno">  12 </span><span class="error">@Deprecated(&quot;Use Buffer instead.&quot;, replaceWith = ReplaceWith(&quot;Buffer&quot;, &quot;io.ktor.utils.io.core.Buffer&quot;))</span>
<span class="lineno">  13 </span><span class="error">actual class IoBuffer actual constructor(</span>
<span class="lineno">  14 </span><span class="error">    memory: Memory,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/js/src/io/ktor/utils/io/js/TextDecoders.kt:19:1</span><span class="message">TextDecoder have a too high LCOM value: 1.0. Number of methods: 5, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  16 </span>    return readText(out, Charset.forName(encoding), max)
<span class="lineno">  17 </span>}
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">internal external class TextDecoder(encoding: String, options: dynamic = definedExternally) {</span>
<span class="lineno">  20 </span><span class="error">    val encoding: String</span>
<span class="lineno">  21 </span><span class="error"></span>
<span class="lineno">  22 </span><span class="error">    fun decode(): String</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/js/src/io/ktor/utils/io/js/TextEncoders.kt:5:1</span><span class="message">TextEncoder have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   2 </span>
<span class="lineno">   3 </span>import org.khronos.webgl.*
<span class="lineno">   4 </span>
<span class="lineno">   5 </span><span class="error">internal external class TextEncoder() {</span>
<span class="lineno">   6 </span><span class="error">    val encoding: String</span>
<span class="lineno">   7 </span><span class="error"></span>
<span class="lineno">   8 </span><span class="error">    fun encode(input: String): Uint8Array</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/ByteBufferChannel.kt:23:1</span><span class="message">ByteBufferChannel have a too high LCOM value: 0.9796610169491525. Number of methods: 59, number of properties: 5, number of references: 6</span>
        <pre><code><span class="lineno">  20 </span>
<span class="lineno">  21 </span>internal const val DEFAULT_CLOSE_MESSAGE = &quot;Byte channel was closed&quot;
<span class="lineno">  22 </span>
<span class="lineno">  23 </span><span class="error">// implementation for ByteChannel</span>
<span class="lineno">  24 </span><span class="error">internal open class ByteBufferChannel(</span>
<span class="lineno">  25 </span><span class="error">    override val autoFlush: Boolean,</span>
<span class="lineno">  26 </span><span class="error">    private val pool: ObjectPool&lt;ReadWriteBufferState.Initial&gt; = BufferObjectPool,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/ByteChannelSequentialJVM.kt:8:1</span><span class="message">ByteChannelSequentialJVM have a too high LCOM value: 0.9090909090909091. Number of methods: 11, number of properties: 1, number of references: 1</span>
        <pre><code><span class="lineno">   5 </span>import io.ktor.utils.io.core.*
<span class="lineno">   6 </span>import java.nio.ByteBuffer
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">@Suppress(&quot;EXPERIMENTAL_FEATURE_WARNING&quot;)</span>
<span class="lineno">   9 </span><span class="error">@ExperimentalIoApi</span>
<span class="lineno">  10 </span><span class="error">class ByteChannelSequentialJVM(initial: IoBuffer, autoFlush: Boolean)</span>
<span class="lineno">  11 </span><span class="error">    : ByteChannelSequentialBase(initial, autoFlush) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/ConditionJVM.kt:8:1</span><span class="message">Condition have a too high LCOM value: 0.8333333333333334. Number of methods: 6, number of properties: 3, number of references: 3</span>
        <pre><code><span class="lineno">   5 </span>import kotlin.coroutines.intrinsics.*
<span class="lineno">   6 </span>import kotlin.jvm.*
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">internal actual class Condition actual constructor(val predicate: () -&gt; Boolean) {</span>
<span class="lineno">   9 </span><span class="error">    @Volatile</span>
<span class="lineno">  10 </span><span class="error">    private var cond: Continuation&lt;Unit&gt;? = null</span>
<span class="lineno">  11 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/core/IoBufferJVM.kt:15:1</span><span class="message">IoBuffer have a too high LCOM value: 0.9987373737373737. Number of methods: 66, number of properties: 12, number of references: 1</span>
        <pre><code><span class="lineno">  12 </span>import io.ktor.utils.io.core.internal.require
<span class="lineno">  13 </span>import kotlin.contracts.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">/**</span>
<span class="lineno">  16 </span><span class="error"> * A read-write facade to actual buffer of fixed size. Multiple views could share the same actual buffer.</span>
<span class="lineno">  17 </span><span class="error"> */</span>
<span class="lineno">  18 </span><span class="error">@Suppress(&quot;DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/internal/EventLoopExperimental.kt:6:1</span><span class="message">CoroutinesEventLoop have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">   3 </span>import java.lang.reflect.*
<span class="lineno">   4 </span>
<span class="lineno">   5 </span>
<span class="lineno">   6 </span><span class="error">internal sealed class CoroutinesEventLoop {</span>
<span class="lineno">   7 </span><span class="error"></span>
<span class="lineno">   8 </span><span class="error">    /**</span>
<span class="lineno">   9 </span><span class="error">     * Processes next event in the current thread's event loop.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/internal/ReadWriteBufferState.kt:11:1</span><span class="message">ReadWriteBufferState have a too high LCOM value: 0.9444444444444444. Number of methods: 18, number of properties: 3, number of references: 3</span>
        <pre><code><span class="lineno">   8 </span>internal val EmptyByteBuffer: ByteBuffer = ByteBuffer.allocate(0)
<span class="lineno">   9 </span>internal val EmptyCapacity = RingBufferCapacity(0)
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal sealed class ReadWriteBufferState(</span>
<span class="lineno">  12 </span><span class="error">    @JvmField val backingBuffer: ByteBuffer,</span>
<span class="lineno">  13 </span><span class="error">    @JvmField val capacity: RingBufferCapacity</span>
<span class="lineno">  14 </span><span class="error">) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/internal/ReadWriteBufferState.kt:29:5</span><span class="message">Initial have a too high LCOM value: 0.9285714285714286. Number of methods: 4, number of properties: 7, number of references: 2</span>
        <pre><code><span class="lineno">  26 </span>        override fun toString() = &quot;IDLE(empty)&quot;
<span class="lineno">  27 </span>    }
<span class="lineno">  28 </span>
<span class="lineno">  29 </span>    <span class="error">class Initial(</span>
<span class="lineno">  30 </span><span class="error">        backingBuffer: ByteBuffer,</span>
<span class="lineno">  31 </span><span class="error">        reservedSize: Int = RESERVED_SIZE</span>
<span class="lineno">  32 </span><span class="error">    ) : ReadWriteBufferState(backingBuffer, RingBufferCapacity(backingBuffer.capacity() - reservedSize)) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/pool/DefaultPool.kt:12:1</span><span class="message">DefaultPool have a too high LCOM value: 0.8888888888888888. Number of methods: 9, number of properties: 7, number of references: 7</span>
        <pre><code><span class="lineno">   9 </span>private const val MAGIC = 2654435769.toInt() // fractional part of golden ratio
<span class="lineno">  10 </span>private const val MAX_CAPACITY = Int.MAX_VALUE / MULTIPLIER
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">actual abstract class DefaultPool&lt;T : Any&gt; actual constructor(actual final override val capacity: Int) : ObjectPool&lt;T&gt; {</span>
<span class="lineno">  13 </span><span class="error">    init {</span>
<span class="lineno">  14 </span><span class="error">        require(capacity &gt; 0) { &quot;capacity should be positive but it is $capacity&quot; }</span>
<span class="lineno">  15 </span><span class="error">        require(capacity &lt;= MAX_CAPACITY) { &quot;capacity should be less or equal to $MAX_CAPACITY but it is $capacity&quot;}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/core/IoBufferNative.kt:16:1</span><span class="message">IoBuffer have a too high LCOM value: 0.9984051036682615. Number of methods: 57, number of properties: 11, number of references: 1</span>
        <pre><code><span class="lineno">  13 </span>@SharedImmutable
<span class="lineno">  14 </span>internal val MAX_SIZE: size_t = size_t.MAX_VALUE
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">@Suppress(&quot;DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES&quot;)</span>
<span class="lineno">  17 </span><span class="error">@Deprecated(&quot;Use Buffer instead.&quot;, replaceWith = ReplaceWith(&quot;Buffer&quot;, &quot;io.ktor.utils.io.core.Buffer&quot;))</span>
<span class="lineno">  18 </span><span class="error">actual class IoBuffer actual constructor(</span>
<span class="lineno">  19 </span><span class="error">    memory: Memory,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/selector/InterestSuspensionsMap.kt:11:1</span><span class="message">InterestSuspensionsMap have a too high LCOM value: 0.8666666666666667. Number of methods: 6, number of properties: 5, number of references: 4</span>
        <pre><code><span class="lineno">   8 </span>import kotlinx.coroutines.*
<span class="lineno">   9 </span>import java.util.concurrent.atomic.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  12 </span><span class="error">@InternalAPI</span>
<span class="lineno">  13 </span><span class="error">class InterestSuspensionsMap {</span>
<span class="lineno">  14 </span><span class="error">    @Volatile</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/selector/LockFreeMPSCQueue.kt:57:1</span><span class="message">LockFreeMPSCQueueCore have a too high LCOM value: 0.9895833333333334. Number of methods: 6, number of properties: 16, number of references: 1</span>
        <pre><code><span class="lineno">  54 </span>    }
<span class="lineno">  55 </span>}
<span class="lineno">  56 </span>
<span class="lineno">  57 </span><span class="error">/**</span>
<span class="lineno">  58 </span><span class="error"> * Lock-free Multiply-Producer Single-Consumer Queue core.</span>
<span class="lineno">  59 </span><span class="error"> * *Note: This queue is NOT linearizable. It provides only quiescent consistency for its operations.*</span>
<span class="lineno">  60 </span><span class="error"> *</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/sockets/DatagramSocketImpl.kt:16:1</span><span class="message">DatagramSocketImpl have a too high LCOM value: 0.8125. Number of methods: 2, number of properties: 8, number of references: 3</span>
        <pre><code><span class="lineno">  13 </span>import java.nio.*
<span class="lineno">  14 </span>import java.nio.channels.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">@OptIn(</span>
<span class="lineno">  17 </span><span class="error">    ObsoleteCoroutinesApi::class, ExperimentalCoroutinesApi::class</span>
<span class="lineno">  18 </span><span class="error">)</span>
<span class="lineno">  19 </span><span class="error">internal class DatagramSocketImpl(override val channel: DatagramChannel, selector: SelectorManager)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/sockets/SocketOptions.kt:9:1</span><span class="message">SocketOptions have a too high LCOM value: 0.8333333333333334. Number of methods: 9, number of properties: 4, number of references: 6</span>
        <pre><code><span class="lineno">   6 </span>
<span class="lineno">   7 </span>import io.ktor.network.util.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">/**</span>
<span class="lineno">  10 </span><span class="error"> * Socket options builder</span>
<span class="lineno">  11 </span><span class="error"> */</span>
<span class="lineno">  12 </span><span class="error">@OptIn(ExperimentalUnsignedTypes::class)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/sockets/TypeOfService.kt:7:1</span><span class="message">TypeOfService have a too high LCOM value: 0.9285714285714286. Number of methods: 2, number of properties: 7, number of references: 1</span>
        <pre><code><span class="lineno">   4 </span>
<span class="lineno">   5 </span>package io.ktor.network.sockets
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">/**</span>
<span class="lineno">   8 </span><span class="error"> * An inline class to hold a IP ToS value</span>
<span class="lineno">   9 </span><span class="error"> * @property value an unsigned byte IP_TOS value</span>
<span class="lineno">  10 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/util/IOCoroutineDispatcher.kt:15:1</span><span class="message">IOCoroutineDispatcher have a too high LCOM value: 0.8571428571428572. Number of methods: 7, number of properties: 1, number of references: 1</span>
        <pre><code><span class="lineno">  12 </span>import kotlin.coroutines.*
<span class="lineno">  13 </span>import kotlin.coroutines.intrinsics.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">/**</span>
<span class="lineno">  16 </span><span class="error"> * Default ktor fixed size dispatcher for doing non-blocking I/O operations and selection</span>
<span class="lineno">  17 </span><span class="error"> */</span>
<span class="lineno">  18 </span><span class="error">@Deprecated(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/util/IOCoroutineDispatcher.kt:71:5</span><span class="message">IOThread have a too high LCOM value: 0.8. Number of methods: 4, number of properties: 5, number of references: 4</span>
        <pre><code><span class="lineno">  68 </span>        }
<span class="lineno">  69 </span>    }
<span class="lineno">  70 </span>
<span class="lineno">  71 </span>    <span class="error">private class IOThread(</span>
<span class="lineno">  72 </span><span class="error">            private val number: Int,</span>
<span class="lineno">  73 </span><span class="error">            private val tasks: LockFreeLinkedListHead,</span>
<span class="lineno">  74 </span><span class="error">            dispatcherThreadGroup: ThreadGroup) : Thread(dispatcherThreadGroup, &quot;io-thread-$number&quot;) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/ktor-network-tls/jvm/src/io/ktor/network/tls/OID.kt:9:1</span><span class="message">OID have a too high LCOM value: 0.96875. Number of methods: 2, number of properties: 16, number of references: 1</span>
        <pre><code><span class="lineno">   6 </span>
<span class="lineno">   7 </span>import io.ktor.util.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">@InternalAPI</span>
<span class="lineno">  10 </span><span class="error">data class OID(val identifier: String) {</span>
<span class="lineno">  11 </span><span class="error">    val asArray: IntArray = identifier.split(&quot;.&quot;, &quot; &quot;).map { it.trim().toInt() }.toIntArray()</span>
<span class="lineno">  12 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/AsyncIntegrationBenchmark.kt:25:1</span><span class="message">AsyncIntegrationBenchmark have a too high LCOM value: 0.8148148148148149. Number of methods: 24, number of properties: 9, number of references: 40</span>
        <pre><code><span class="lineno">  22 </span>import java.io.*
<span class="lineno">  23 </span>import java.util.concurrent.*
<span class="lineno">  24 </span>
<span class="lineno">  25 </span><span class="error">@State(Scope.Group)</span>
<span class="lineno">  26 </span><span class="error">abstract class AsyncIntegrationBenchmark&lt;TEngine : ApplicationEngine&gt; {</span>
<span class="lineno">  27 </span><span class="error">    private val coreDirectory = File(&quot;../ktor-server-core&quot;).absoluteFile.normalize()</span>
<span class="lineno">  28 </span><span class="error">    private val packageName = IntegrationBenchmark::class.java.`package`.name</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/BenchmarkRunner.kt:22:1</span><span class="message">BenchmarkSettings have a too high LCOM value: 0.8. Number of methods: 3, number of properties: 5, number of references: 3</span>
        <pre><code><span class="lineno">  19 </span>        .resultFormat(ResultFormatType.CSV)
<span class="lineno">  20 </span>        .forks(1)
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">class BenchmarkSettings {</span>
<span class="lineno">  23 </span><span class="error">    var threads = 32</span>
<span class="lineno">  24 </span><span class="error">    val profilers = mutableListOf&lt;String&gt;()</span>
<span class="lineno">  25 </span><span class="error">    var iterations = 20</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/jetty/JettyPlatformBenchmark.kt:16:1</span><span class="message">JettyPlatformBenchmark have a too high LCOM value: 0.8. Number of methods: 5, number of properties: 2, number of references: 2</span>
        <pre><code><span class="lineno">  13 </span>import javax.servlet.*
<span class="lineno">  14 </span>import javax.servlet.http.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">class JettyPlatformBenchmark : PlatformBenchmark() {</span>
<span class="lineno">  17 </span><span class="error">    lateinit var server: Server</span>
<span class="lineno">  18 </span><span class="error"></span>
<span class="lineno">  19 </span><span class="error">    override fun runServer(port: Int) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/netty/NettyPlatformBenchmark.kt:19:1</span><span class="message">NettyPlatformBenchmark have a too high LCOM value: 1.0. Number of methods: 6, number of properties: 4, number of references: 0</span>
        <pre><code><span class="lineno">  16 </span>import java.net.*
<span class="lineno">  17 </span>import java.util.concurrent.*
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">class NettyPlatformBenchmark : PlatformBenchmark() {</span>
<span class="lineno">  20 </span><span class="error">    private lateinit var channel: Channel</span>
<span class="lineno">  21 </span><span class="error">    val eventLoopGroup = NioEventLoopGroup()</span>
<span class="lineno">  22 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/netty/NettyPlatformBenchmark.kt:53:5</span><span class="message">BenchmarkServerHandler have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 4, number of references: 0</span>
        <pre><code><span class="lineno">  50 </span>        }
<span class="lineno">  51 </span>    }
<span class="lineno">  52 </span>
<span class="lineno">  53 </span>    <span class="error">class BenchmarkServerHandler internal constructor(service: ScheduledExecutorService) : ChannelInboundHandlerAdapter() {</span>
<span class="lineno">  54 </span><span class="error">        override fun channelRead(ctx: ChannelHandlerContext, msg: Any) {</span>
<span class="lineno">  55 </span><span class="error">            when (msg) {</span>
<span class="lineno">  56 </span><span class="error">                is HttpRequest -&gt; try {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/test/TestIntegrationBenchmark.kt:13:1</span><span class="message">TestIntegrationBenchmark have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  10 </span>import io.ktor.server.engine.*
<span class="lineno">  11 </span>import io.ktor.server.testing.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class TestIntegrationBenchmark : IntegrationBenchmark&lt;TestApplicationEngine&gt;() {</span>
<span class="lineno">  14 </span><span class="error"></span>
<span class="lineno">  15 </span><span class="error">    override val localhost: String = &quot;&quot;</span>
<span class="lineno">  16 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-cio/jvm/src/io/ktor/server/cio/CIOApplicationCall.kt:15:1</span><span class="message">CIOApplicationCall have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">  12 </span>import java.net.*
<span class="lineno">  13 </span>import kotlin.coroutines.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">internal class CIOApplicationCall(</span>
<span class="lineno">  16 </span><span class="error">    application: Application,</span>
<span class="lineno">  17 </span><span class="error">    _request: Request,</span>
<span class="lineno">  18 </span><span class="error">    input: ByteReadChannel,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/AutoHeadResponse.kt:41:5</span><span class="message">HeadResponse have a too high LCOM value: 0.8. Number of methods: 3, number of properties: 5, number of references: 3</span>
        <pre><code><span class="lineno">  38 </span>        }
<span class="lineno">  39 </span>    }
<span class="lineno">  40 </span>
<span class="lineno">  41 </span>    <span class="error">private class HeadResponse(val original: OutgoingContent) : OutgoingContent.NoContent() {</span>
<span class="lineno">  42 </span><span class="error">        override val status: HttpStatusCode? get() = original.status</span>
<span class="lineno">  43 </span><span class="error">        override val contentType: ContentType? get() = original.contentType</span>
<span class="lineno">  44 </span><span class="error">        override val contentLength: Long? get() = original.contentLength</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/CORS.kt:16:1</span><span class="message">CORS have a too high LCOM value: 0.9375. Number of methods: 9, number of properties: 16, number of references: 9</span>
        <pre><code><span class="lineno">  13 </span>import io.ktor.response.*
<span class="lineno">  14 </span>import io.ktor.util.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">/**</span>
<span class="lineno">  17 </span><span class="error"> * CORS feature. Please read http://ktor.io/servers/features/cors.html first before using it.</span>
<span class="lineno">  18 </span><span class="error"> */</span>
<span class="lineno">  19 </span><span class="error">class CORS(configuration: Configuration) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/CORS.kt:259:5</span><span class="message">Configuration have a too high LCOM value: 0.9081632653061225. Number of methods: 7, number of properties: 14, number of references: 9</span>
        <pre><code><span class="lineno"> 256 </span>            }
<span class="lineno"> 257 </span>        }.toString()
<span class="lineno"> 258 </span>
<span class="lineno"> 259 </span>    <span class="error">/**</span>
<span class="lineno"> 260 </span><span class="error">     * CORS feature configuration</span>
<span class="lineno"> 261 </span><span class="error">     */</span>
<span class="lineno"> 262 </span><span class="error">    class Configuration {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/CallId.kt:47:1</span><span class="message">CallId have a too high LCOM value: 0.9125. Number of methods: 10, number of properties: 8, number of references: 7</span>
        <pre><code><span class="lineno">  44 </span> */
<span class="lineno">  45 </span>val ApplicationCall.callId: String? get() = attributes.getOrNull(CallId.callIdKey)
<span class="lineno">  46 </span>
<span class="lineno">  47 </span><span class="error">/**</span>
<span class="lineno">  48 </span><span class="error"> * Retrieves and generates if necessary a call id. A call id (or correlation id) could be retrieved_ from a call</span>
<span class="lineno">  49 </span><span class="error"> * via [CallId.Configuration.retrieve] function. Multiple retrieve functions could be configured that will be invoked</span>
<span class="lineno">  50 </span><span class="error"> * one by one until one of them return non-null value. If no value has been provided by retrievers then a generator</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/CallId.kt:78:5</span><span class="message">Configuration have a too high LCOM value: 0.8055555555555556. Number of methods: 9, number of properties: 4, number of references: 7</span>
        <pre><code><span class="lineno">  75 </span>    private val repliers: Array&lt;(call: ApplicationCall, callId: String) -&gt; Unit&gt;,
<span class="lineno">  76 </span>    private val verifier: CallIdVerifier
<span class="lineno">  77 </span>) {
<span class="lineno">  78 </span>    <span class="error">/**</span>
<span class="lineno">  79 </span><span class="error">     * [CallId] feature's configuration</span>
<span class="lineno">  80 </span><span class="error">     */</span>
<span class="lineno">  81 </span><span class="error">    class Configuration {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/CallLogging.kt:17:1</span><span class="message">CallLogging have a too high LCOM value: 0.9. Number of methods: 7, number of properties: 10, number of references: 7</span>
        <pre><code><span class="lineno">  14 </span>import org.slf4j.event.*
<span class="lineno">  15 </span>import kotlin.coroutines.*
<span class="lineno">  16 </span>
<span class="lineno">  17 </span><span class="error">/**</span>
<span class="lineno">  18 </span><span class="error"> * Logs application lifecycle and call events.</span>
<span class="lineno">  19 </span><span class="error"> */</span>
<span class="lineno">  20 </span><span class="error">class CallLogging private constructor(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/CallLogging.kt:31:5</span><span class="message">Configuration have a too high LCOM value: 0.8. Number of methods: 3, number of properties: 5, number of references: 3</span>
        <pre><code><span class="lineno">  28 </span>
<span class="lineno">  29 </span>    internal class MDCEntry(val name: String, val provider: (ApplicationCall) -&gt; String?)
<span class="lineno">  30 </span>
<span class="lineno">  31 </span>    <span class="error">/**</span>
<span class="lineno">  32 </span><span class="error">     * Configuration for [CallLogging] feature</span>
<span class="lineno">  33 </span><span class="error">     */</span>
<span class="lineno">  34 </span><span class="error">    class Configuration {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/Compression.kt:56:1</span><span class="message">Compression have a too high LCOM value: 0.85. Number of methods: 10, number of properties: 2, number of references: 3</span>
        <pre><code><span class="lineno">  53 </span>    val priority: Double
<span class="lineno">  54 </span>)
<span class="lineno">  55 </span>
<span class="lineno">  56 </span><span class="error">/**</span>
<span class="lineno">  57 </span><span class="error"> * Feature to compress a response based on conditions and ability of client to decompress it</span>
<span class="lineno">  58 </span><span class="error"> */</span>
<span class="lineno">  59 </span><span class="error">class Compression(compression: Configuration) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/ContentNegotiation.kt:40:1</span><span class="message">ContentNegotiation have a too high LCOM value: 0.8333333333333334. Number of methods: 4, number of properties: 3, number of references: 2</span>
        <pre><code><span class="lineno">  37 </span>    }
<span class="lineno">  38 </span>}
<span class="lineno">  39 </span>
<span class="lineno">  40 </span><span class="error">/**</span>
<span class="lineno">  41 </span><span class="error"> * This feature provides automatic content conversion according to Content-Type and Accept headers</span>
<span class="lineno">  42 </span><span class="error"> *</span>
<span class="lineno">  43 </span><span class="error"> * See normative documents:</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/DataConversion.kt:13:1</span><span class="message">DataConversion have a too high LCOM value: 0.875. Number of methods: 8, number of properties: 2, number of references: 2</span>
        <pre><code><span class="lineno">  10 </span>import kotlin.reflect.*
<span class="lineno">  11 </span>import kotlin.reflect.jvm.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">/**</span>
<span class="lineno">  14 </span><span class="error"> * Data conversion feature to serialize and deserialize types using [converters] registry</span>
<span class="lineno">  15 </span><span class="error"> */</span>
<span class="lineno">  16 </span><span class="error">class DataConversion(private val converters: Map&lt;Type, ConversionService&gt;) : ConversionService {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/DefaultHeaders.kt:15:1</span><span class="message">DefaultHeaders have a too high LCOM value: 0.9166666666666666. Number of methods: 2, number of properties: 6, number of references: 1</span>
        <pre><code><span class="lineno">  12 </span>import kotlinx.atomicfu.*
<span class="lineno">  13 </span>import java.util.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">/**</span>
<span class="lineno">  16 </span><span class="error"> * Adds standard HTTP headers `Date` and `Server` and provides ability to specify other headers</span>
<span class="lineno">  17 </span><span class="error"> * that are included in responses.</span>
<span class="lineno">  18 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/DoubleReceive.kt:14:1</span><span class="message">DoubleReceive have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">  11 </span>import io.ktor.utils.io.*
<span class="lineno">  12 </span>import kotlin.reflect.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">/**</span>
<span class="lineno">  15 </span><span class="error"> * This feature provides ability to invoke [ApplicationCall.receive] several times.</span>
<span class="lineno">  16 </span><span class="error"> * Please note that not every type could be received twice. For example, even with this feature installed you can't</span>
<span class="lineno">  17 </span><span class="error"> * receive a channel twice (unless [Configuration.receiveEntireContent] is enabled).</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/HSTS.kt:11:1</span><span class="message">HSTS have a too high LCOM value: 0.875. Number of methods: 2, number of properties: 8, number of references: 2</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.response.*
<span class="lineno">   9 </span>import io.ktor.util.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * HSTS feature that appends `Strict-Transport-Security` HTTP header to every response.</span>
<span class="lineno">  13 </span><span class="error"> * See http://ktor.io/servers/features/hsts.html for details</span>
<span class="lineno">  14 </span><span class="error"> * See RFC 6797 https://tools.ietf.org/html/rfc6797</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/HttpsRedirect.kt:12:1</span><span class="message">HttpsRedirect have a too high LCOM value: 0.8333333333333334. Number of methods: 3, number of properties: 4, number of references: 2</span>
        <pre><code><span class="lineno">   9 </span>import io.ktor.response.*
<span class="lineno">  10 </span>import io.ktor.util.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">/**</span>
<span class="lineno">  13 </span><span class="error"> * Redirect non-secure requests to HTTPS</span>
<span class="lineno">  14 </span><span class="error"> */</span>
<span class="lineno">  15 </span><span class="error">class HttpsRedirect(config: Configuration) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/OriginConnectionPoint.kt:27:1</span><span class="message">MutableOriginConnectionPoint have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 7, number of references: 0</span>
        <pre><code><span class="lineno">  24 </span>val MutableOriginConnectionPointKey: AttributeKey&lt;MutableOriginConnectionPoint&gt; =
<span class="lineno">  25 </span>    AttributeKey(&quot;MutableOriginConnectionPointKey&quot;)
<span class="lineno">  26 </span>
<span class="lineno">  27 </span><span class="error">/**</span>
<span class="lineno">  28 </span><span class="error"> * Represents a [RequestConnectionPoint]. Every it's component is mutable so application features could provide them</span>
<span class="lineno">  29 </span><span class="error"> */</span>
<span class="lineno">  30 </span><span class="error">@KtorExperimentalAPI</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/OriginConnectionPoint.kt:50:1</span><span class="message">OriginConnectionPoint have a too high LCOM value: 0.8888888888888888. Number of methods: 2, number of properties: 9, number of references: 2</span>
        <pre><code><span class="lineno">  47 </span>    override var remoteHost: String by AssignableWithDelegate { delegate.remoteHost }
<span class="lineno">  48 </span>}
<span class="lineno">  49 </span>
<span class="lineno">  50 </span><span class="error">internal class OriginConnectionPoint(</span>
<span class="lineno">  51 </span><span class="error">    private val local: RequestConnectionPoint,</span>
<span class="lineno">  52 </span><span class="error">    private val hostHeaderValue: String?</span>
<span class="lineno">  53 </span><span class="error">) : RequestConnectionPoint {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/PartialContent.kt:20:1</span><span class="message">PartialContent have a too high LCOM value: 0.875. Number of methods: 8, number of properties: 9, number of references: 9</span>
        <pre><code><span class="lineno">  17 </span>import kotlin.coroutines.*
<span class="lineno">  18 </span>import kotlin.properties.*
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">/**</span>
<span class="lineno">  21 </span><span class="error"> * Feature to support requests to specific content ranges.</span>
<span class="lineno">  22 </span><span class="error"> *</span>
<span class="lineno">  23 </span><span class="error"> * It is essential for streaming video and restarting downloads.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/PartialContent.kt:201:5</span><span class="message">PartialOutgoingContent have a too high LCOM value: 0.8571428571428572. Number of methods: 7, number of properties: 9, number of references: 9</span>
        <pre><code><span class="lineno"> 198 </span>        proceedWith(PartialOutgoingContent.Multiple(coroutineContext, call.isGet(), content, ranges, length, boundary))
<span class="lineno"> 199 </span>    }
<span class="lineno"> 200 </span>
<span class="lineno"> 201 </span>    <span class="error">private sealed class PartialOutgoingContent(val original: ReadChannelContent) :</span>
<span class="lineno"> 202 </span><span class="error">        OutgoingContent.ReadChannelContent() {</span>
<span class="lineno"> 203 </span><span class="error">        override val status: HttpStatusCode? get() = original.status</span>
<span class="lineno"> 204 </span><span class="error">        override val contentType: ContentType? get() = original.contentType</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/PartialContent.kt:208:9</span><span class="message">Bypass have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno"> 205 </span>        override fun &lt;T : Any&gt; getProperty(key: AttributeKey&lt;T&gt;) = original.getProperty(key)
<span class="lineno"> 206 </span>        override fun &lt;T : Any&gt; setProperty(key: AttributeKey&lt;T&gt;, value: T?) = original.setProperty(key, value)
<span class="lineno"> 207 </span>
<span class="lineno"> 208 </span>        <span class="error">class Bypass(original: ReadChannelContent) : PartialOutgoingContent(original) {</span>
<span class="lineno"> 209 </span><span class="error"></span>
<span class="lineno"> 210 </span><span class="error">            override val contentLength: Long?</span>
<span class="lineno"> 211 </span><span class="error">                get() = original.contentLength</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/Routing.kt:14:1</span><span class="message">Routing have a too high LCOM value: 0.8. Number of methods: 4, number of properties: 5, number of references: 4</span>
        <pre><code><span class="lineno">  11 </span>import io.ktor.response.*
<span class="lineno">  12 </span>import io.ktor.util.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">/**</span>
<span class="lineno">  15 </span><span class="error"> * Root routing node for an [Application]</span>
<span class="lineno">  16 </span><span class="error"> * @param application is an instance of [Application] for this routing</span>
<span class="lineno">  17 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/sessions/Sessions.kt:12:1</span><span class="message">Sessions have a too high LCOM value: 0.8888888888888888. Number of methods: 3, number of properties: 3, number of references: 1</span>
        <pre><code><span class="lineno">   9 </span>import io.ktor.util.*
<span class="lineno">  10 </span>import kotlin.reflect.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">/**</span>
<span class="lineno">  13 </span><span class="error"> * Sessions feature that provides a mechanism to persist information between requests.</span>
<span class="lineno">  14 </span><span class="error"> * @property providers list of session providers</span>
<span class="lineno">  15 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/sessions/SessionsBuilder.kt:275:1</span><span class="message">CookieSessionBuilder have a too high LCOM value: 0.8. Number of methods: 2, number of properties: 5, number of references: 2</span>
        <pre><code><span class="lineno"> 272 </span>        private set
<span class="lineno"> 273 </span>}
<span class="lineno"> 274 </span>
<span class="lineno"> 275 </span><span class="error">/**</span>
<span class="lineno"> 276 </span><span class="error"> * Cookie session configuration builder</span>
<span class="lineno"> 277 </span><span class="error"> * @property type - session instance type</span>
<span class="lineno"> 278 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-host-common/jvm/src/io/ktor/server/engine/BaseApplicationCall.kt:11:1</span><span class="message">BaseApplicationCall have a too high LCOM value: 0.8. Number of methods: 2, number of properties: 5, number of references: 2</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.http.*
<span class="lineno">   9 </span>import io.ktor.util.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * Base class for implementing an [ApplicationCall].</span>
<span class="lineno">  13 </span><span class="error"> */</span>
<span class="lineno">  14 </span><span class="error">@EngineAPI</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-host-common/jvm/src/io/ktor/server/engine/BaseApplicationResponse.kt:19:1</span><span class="message">BaseApplicationResponse have a too high LCOM value: 0.9411764705882353. Number of methods: 17, number of properties: 2, number of references: 2</span>
        <pre><code><span class="lineno">  16 </span>import kotlinx.coroutines.*
<span class="lineno">  17 </span>import java.nio.*
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">/**</span>
<span class="lineno">  20 </span><span class="error"> * Base class for implementing an [ApplicationResponse]</span>
<span class="lineno">  21 </span><span class="error"> */</span>
<span class="lineno">  22 </span><span class="error">abstract class BaseApplicationResponse(override val call: ApplicationCall) : ApplicationResponse {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-host-common/jvm/src/io/ktor/server/engine/DefaultUncaughtExceptionHandler.kt:13:1</span><span class="message">DefaultUncaughtExceptionHandler have a too high LCOM value: 0.8333333333333334. Number of methods: 3, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno">  10 </span>import java.io.*
<span class="lineno">  11 </span>import kotlin.coroutines.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">/**</span>
<span class="lineno">  14 </span><span class="error"> * Handles all uncaught exceptions and logs errors with the specified [logger]</span>
<span class="lineno">  15 </span><span class="error"> * ignoring [CancellationException] and [IOException].</span>
<span class="lineno">  16 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-host-common/jvm/src/io/ktor/server/engine/ShutDownUrl.kt:15:1</span><span class="message">ShutDownUrl have a too high LCOM value: 1.0. Number of methods: 4, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">  12 </span>import kotlinx.coroutines.*
<span class="lineno">  13 </span>import kotlin.system.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">/**</span>
<span class="lineno">  16 </span><span class="error"> * Shutdown URL feature. It stops application when requested particular url</span>
<span class="lineno">  17 </span><span class="error"> *</span>
<span class="lineno">  18 </span><span class="error"> * @property url to handle</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-jetty/jvm/src/io/ktor/server/jetty/JettyApplicationCall.kt:15:1</span><span class="message">JettyApplicationCall have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  12 </span>import javax.servlet.http.*
<span class="lineno">  13 </span>import kotlin.coroutines.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  16 </span><span class="error">@InternalAPI</span>
<span class="lineno">  17 </span><span class="error">class JettyApplicationCall(</span>
<span class="lineno">  18 </span><span class="error">    application: Application,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationEngine.kt:23:1</span><span class="message">NettyApplicationEngine have a too high LCOM value: 0.828125. Number of methods: 4, number of properties: 16, number of references: 11</span>
        <pre><code><span class="lineno">  20 </span>import java.util.concurrent.*
<span class="lineno">  21 </span>import kotlin.reflect.KClass
<span class="lineno">  22 </span>
<span class="lineno">  23 </span><span class="error">/**</span>
<span class="lineno">  24 </span><span class="error"> * [ApplicationEngine] implementation for running in a standalone Netty</span>
<span class="lineno">  25 </span><span class="error"> */</span>
<span class="lineno">  26 </span><span class="error">class NettyApplicationEngine(environment: ApplicationEngineEnvironment, configure: Configuration.() -&gt; Unit = {}) :</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/cio/NettyRequestQueue.kt:13:1</span><span class="message">NettyRequestQueue have a too high LCOM value: 0.84375. Number of methods: 8, number of properties: 4, number of references: 5</span>
        <pre><code><span class="lineno">  10 </span>import kotlinx.coroutines.*
<span class="lineno">  11 </span>import kotlinx.coroutines.channels.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">internal class NettyRequestQueue(internal val readLimit: Int, internal val runningLimit: Int) {</span>
<span class="lineno">  14 </span><span class="error">    init {</span>
<span class="lineno">  15 </span><span class="error">        require(readLimit &gt; 0) { &quot;readLimit should be positive: $readLimit&quot; }</span>
<span class="lineno">  16 </span><span class="error">        require(runningLimit &gt; 0) { &quot;executeLimit should be positive: $runningLimit&quot; }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/cio/NettyResponsePipeline.kt:26:1</span><span class="message">NettyResponsePipeline have a too high LCOM value: 0.8. Number of methods: 2, number of properties: 10, number of references: 4</span>
        <pre><code><span class="lineno">  23 </span>
<span class="lineno">  24 </span>private const val UNFLUSHED_LIMIT = 65536
<span class="lineno">  25 </span>
<span class="lineno">  26 </span><span class="error">internal class NettyResponsePipeline(private val dst: ChannelHandlerContext,</span>
<span class="lineno">  27 </span><span class="error">                                     initialEncapsulation: WriterEncapsulation,</span>
<span class="lineno">  28 </span><span class="error">                                     private val requestQueue: NettyRequestQueue,</span>
<span class="lineno">  29 </span><span class="error">                                     override val coroutineContext: CoroutineContext</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/cio/NettyResponsePipeline.kt:333:1</span><span class="message">WriterEncapsulation have a too high LCOM value: 1.0. Number of methods: 12, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno"> 330 </span>
<span class="lineno"> 331 </span>private val ResponsePipelineCoroutineName = CoroutineName(&quot;response-pipeline&quot;)
<span class="lineno"> 332 </span>
<span class="lineno"> 333 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno"> 334 </span><span class="error">@InternalAPI</span>
<span class="lineno"> 335 </span><span class="error">sealed class WriterEncapsulation {</span>
<span class="lineno"> 336 </span><span class="error">    open val requiresContextClose: Boolean get() = true</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/http1/NettyHttp1ApplicationCall.kt:14:1</span><span class="message">NettyHttp1ApplicationCall have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">  11 </span>import io.ktor.utils.io.*
<span class="lineno">  12 </span>import kotlin.coroutines.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">internal class NettyHttp1ApplicationCall(</span>
<span class="lineno">  15 </span><span class="error">    application: Application,</span>
<span class="lineno">  16 </span><span class="error">    context: ChannelHandlerContext,</span>
<span class="lineno">  17 </span><span class="error">    httpRequest: HttpRequest,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/http2/NettyHttp2ApplicationCall.kt:13:1</span><span class="message">NettyHttp2ApplicationCall have a too high LCOM value: 0.8333333333333334. Number of methods: 2, number of properties: 3, number of references: 1</span>
        <pre><code><span class="lineno">  10 </span>import io.netty.handler.codec.http2.*
<span class="lineno">  11 </span>import kotlin.coroutines.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">internal class NettyHttp2ApplicationCall(application: Application,</span>
<span class="lineno">  14 </span><span class="error">                                         context: ChannelHandlerContext,</span>
<span class="lineno">  15 </span><span class="error">                                         val headers: Http2Headers,</span>
<span class="lineno">  16 </span><span class="error">                                         handler: NettyHttp2Handler,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/http2/NettyHttp2Handler.kt:22:1</span><span class="message">NettyHttp2Handler have a too high LCOM value: 0.9. Number of methods: 5, number of properties: 4, number of references: 2</span>
        <pre><code><span class="lineno">  19 </span>import java.nio.channels.*
<span class="lineno">  20 </span>import kotlin.coroutines.*
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">@ChannelHandler.Sharable</span>
<span class="lineno">  23 </span><span class="error">internal class NettyHttp2Handler(</span>
<span class="lineno">  24 </span><span class="error">    private val enginePipeline: EnginePipeline,</span>
<span class="lineno">  25 </span><span class="error">    private val application: Application,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/BlockingServlet.kt:18:1</span><span class="message">BlockingServletApplicationCall have a too high LCOM value: 0.8333333333333334. Number of methods: 2, number of properties: 3, number of references: 1</span>
        <pre><code><span class="lineno">  15 </span>import javax.servlet.http.*
<span class="lineno">  16 </span>import kotlin.coroutines.*
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">internal class BlockingServletApplicationCall(</span>
<span class="lineno">  19 </span><span class="error">    application: Application,</span>
<span class="lineno">  20 </span><span class="error">    servletRequest: HttpServletRequest,</span>
<span class="lineno">  21 </span><span class="error">    servletResponse: HttpServletResponse,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/ServletApplicationEngine.kt:16:1</span><span class="message">ServletApplicationEngine have a too high LCOM value: 0.8571428571428572. Number of methods: 2, number of properties: 7, number of references: 2</span>
        <pre><code><span class="lineno">  13 </span>import javax.servlet.*
<span class="lineno">  14 </span>import javax.servlet.annotation.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">/**</span>
<span class="lineno">  17 </span><span class="error"> * This servlet need to be installed into a servlet container</span>
<span class="lineno">  18 </span><span class="error"> */</span>
<span class="lineno">  19 </span><span class="error">@MultipartConfig</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/ServletApplicationRequest.kt:13:1</span><span class="message">ServletApplicationRequest have a too high LCOM value: 0.8. Number of methods: 1, number of properties: 5, number of references: 1</span>
        <pre><code><span class="lineno">  10 </span>import io.ktor.server.engine.*
<span class="lineno">  11 </span>import javax.servlet.http.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  14 </span><span class="error">@EngineAPI</span>
<span class="lineno">  15 </span><span class="error">abstract class ServletApplicationRequest(</span>
<span class="lineno">  16 </span><span class="error">    call: ApplicationCall,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/ServletConnectionPoint.kt:10:1</span><span class="message">ServletConnectionPoint have a too high LCOM value: 0.875. Number of methods: 1, number of properties: 8, number of references: 1</span>
        <pre><code><span class="lineno">   7 </span>import io.ktor.http.*
<span class="lineno">   8 </span>import javax.servlet.http.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">internal class ServletConnectionPoint(val servletRequest: HttpServletRequest) : RequestConnectionPoint {</span>
<span class="lineno">  11 </span><span class="error">    override val uri = servletRequest.queryString.let { query -&gt;</span>
<span class="lineno">  12 </span><span class="error">        if (query == null) {</span>
<span class="lineno">  13 </span><span class="error">            servletRequest.requestURI!!</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/EngineTestBase.kt:39:1</span><span class="message">EngineTestBase have a too high LCOM value: 0.9393939393939394. Number of methods: 11, number of properties: 9, number of references: 6</span>
        <pre><code><span class="lineno">  36 </span>import kotlin.test.*
<span class="lineno">  37 </span>
<span class="lineno">  38 </span>
<span class="lineno">  39 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  40 </span><span class="error">abstract class EngineTestBase&lt;TEngine : ApplicationEngine, TConfiguration : ApplicationEngine.Configuration&gt;(</span>
<span class="lineno">  41 </span><span class="error">    val applicationEngineFactory: ApplicationEngineFactory&lt;TEngine, TConfiguration&gt;</span>
<span class="lineno">  42 </span><span class="error">) : CoroutineScope {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/EngineTestSuite.kt:39:1</span><span class="message">EngineTestSuite have a too high LCOM value: 1.0. Number of methods: 60, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">  36 </span>import kotlin.coroutines.*
<span class="lineno">  37 </span>import kotlin.test.*
<span class="lineno">  38 </span>
<span class="lineno">  39 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  40 </span><span class="error">abstract class EngineTestSuite&lt;TEngine : ApplicationEngine, TConfiguration : ApplicationEngine.Configuration&gt;(</span>
<span class="lineno">  41 </span><span class="error">    hostFactory: ApplicationEngineFactory&lt;TEngine, TConfiguration&gt;</span>
<span class="lineno">  42 </span><span class="error">) : EngineTestBase&lt;TEngine, TConfiguration&gt;(hostFactory) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/HighLoadHttpGenerator.kt:21:1</span><span class="message">HighLoadHttpGenerator have a too high LCOM value: 0.9087301587301587. Number of methods: 12, number of properties: 21, number of references: 23</span>
        <pre><code><span class="lineno">  18 </span>import kotlin.io.use
<span class="lineno">  19 </span>import kotlin.text.toByteArray
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">/**</span>
<span class="lineno">  22 </span><span class="error"> * This HTTP generator produces huge amount of requests however it doesn't validate responses and doesn't measure</span>
<span class="lineno">  23 </span><span class="error"> * any time characteristics.</span>
<span class="lineno">  24 </span><span class="error"> *</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/TestApplicationEngine.kt:24:1</span><span class="message">TestApplicationEngine have a too high LCOM value: 0.875. Number of methods: 8, number of properties: 7, number of references: 7</span>
        <pre><code><span class="lineno">  21 </span>import io.ktor.utils.io.*
<span class="lineno">  22 </span>import kotlin.coroutines.*
<span class="lineno">  23 </span>
<span class="lineno">  24 </span><span class="error">/**</span>
<span class="lineno">  25 </span><span class="error"> * ktor test engine that provides way to simulate application calls to existing application module(s)</span>
<span class="lineno">  26 </span><span class="error"> * without actual HTTP connection</span>
<span class="lineno">  27 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/TestApplicationRequest.kt:18:1</span><span class="message">TestApplicationRequest have a too high LCOM value: 0.8333333333333334. Number of methods: 3, number of properties: 10, number of references: 5</span>
        <pre><code><span class="lineno">  15 </span>import io.ktor.utils.io.charsets.*
<span class="lineno">  16 </span>import io.ktor.utils.io.core.*
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">/**</span>
<span class="lineno">  19 </span><span class="error"> * Represents a test application request</span>
<span class="lineno">  20 </span><span class="error"> *</span>
<span class="lineno">  21 </span><span class="error"> * @property method HTTP method to be sent or executed</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/client/TestHttpClientEngine.kt:19:1</span><span class="message">TestHttpClientEngine have a too high LCOM value: 0.875. Number of methods: 4, number of properties: 6, number of references: 3</span>
        <pre><code><span class="lineno">  16 </span>import kotlinx.coroutines.*
<span class="lineno">  17 </span>import kotlin.coroutines.*
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  20 </span><span class="error">@KtorExperimentalAPI</span>
<span class="lineno">  21 </span><span class="error">class TestHttpClientEngine(override val config: TestHttpClientConfig) : HttpClientEngineBase(&quot;ktor-test&quot;) {</span>
<span class="lineno">  22 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/common/src/io/ktor/util/CaseInsensitiveMap.kt:7:1</span><span class="message">CaseInsensitiveMap have a too high LCOM value: 0.8. Number of methods: 10, number of properties: 5, number of references: 10</span>
        <pre><code><span class="lineno">   4 </span>
<span class="lineno">   5 </span>package io.ktor.util
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">/**</span>
<span class="lineno">   8 </span><span class="error"> * A map with case insensitive [String] keys</span>
<span class="lineno">   9 </span><span class="error"> */</span>
<span class="lineno">  10 </span><span class="error">@InternalAPI</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/common/src/io/ktor/util/date/GMTDateParser.kt:11:1</span><span class="message">GMTDateParser have a too high LCOM value: 0.8888888888888888. Number of methods: 3, number of properties: 9, number of references: 3</span>
        <pre><code><span class="lineno">   8 </span>
<span class="lineno">   9 </span>private typealias DateChunkParser = GMTDateBuilder.(String) -&gt; Unit
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * Build [GMTDate] parser using [pattern] string.</span>
<span class="lineno">  13 </span><span class="error"> *</span>
<span class="lineno">  14 </span><span class="error"> * Pattern string format:</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/common/src/io/ktor/util/pipeline/Pipeline.kt:10:1</span><span class="message">Pipeline have a too high LCOM value: 0.8125. Number of methods: 14, number of properties: 8, number of references: 21</span>
        <pre><code><span class="lineno">   7 </span>import io.ktor.util.*
<span class="lineno">   8 </span>import kotlin.jvm.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">/**</span>
<span class="lineno">  11 </span><span class="error"> * Represents an execution pipeline for asynchronous extensible computations</span>
<span class="lineno">  12 </span><span class="error"> */</span>
<span class="lineno">  13 </span><span class="error">open class Pipeline&lt;TSubject : Any, TContext : Any&gt;(vararg phases: PipelinePhase) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/js/src/io/ktor/util/CryptoJs.kt:51:1</span><span class="message">Crypto have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  48 </span>
<span class="lineno">  49 </span>private val crypto: Crypto = if (PlatformUtils.IS_NODE) js(&quot;require('crypto')&quot;) else js(&quot;(crypto ? crypto : msCrypto)&quot;)
<span class="lineno">  50 </span>
<span class="lineno">  51 </span><span class="error">private external class Crypto {</span>
<span class="lineno">  52 </span><span class="error">    val subtle: SubtleCrypto</span>
<span class="lineno">  53 </span><span class="error"></span>
<span class="lineno">  54 </span><span class="error">    fun getRandomValues(array: ByteArray)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/internal/LockFreeLinkedList.kt:124:1</span><span class="message">LockFreeLinkedListNode have a too high LCOM value: 0.9444444444444444. Number of methods: 36, number of properties: 3, number of references: 6</span>
        <pre><code><span class="lineno"> 121 </span>}
<span class="lineno"> 122 </span>
<span class="lineno"> 123 </span>
<span class="lineno"> 124 </span><span class="error">/**</span>
<span class="lineno"> 125 </span><span class="error"> * Doubly-linked concurrent list node with remove support.</span>
<span class="lineno"> 126 </span><span class="error"> * Based on paper</span>
<span class="lineno"> 127 </span><span class="error"> * [&quot;Lock-Free and Practical Doubly Linked List-Based Deques Using Single-Word Compare-and-Swap&quot;](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.4693&amp;rep=rep1&amp;type=pdf)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/internal/LockFreeLinkedList.kt:448:5</span><span class="message">RemoveFirstDesc have a too high LCOM value: 0.8958333333333334. Number of methods: 8, number of properties: 6, number of references: 5</span>
        <pre><code><span class="lineno"> 445 </span>        }
<span class="lineno"> 446 </span>    }
<span class="lineno"> 447 </span>
<span class="lineno"> 448 </span>    <span class="error">public open class RemoveFirstDesc&lt;T&gt;(</span>
<span class="lineno"> 449 </span><span class="error">        @JvmField val queue: Node</span>
<span class="lineno"> 450 </span><span class="error">    ) : AbstractAtomicDesc() {</span>
<span class="lineno"> 451 </span><span class="error">        private val _affectedNode = atomic&lt;Node?&gt;(null)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/internal/LockFreeLinkedList.kt:749:1</span><span class="message">LockFreeLinkedListHead have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno"> 746 </span>@PublishedApi
<span class="lineno"> 747 </span>internal fun Any.unwrap(): Node = (this as? Removed)?.ref ?: this as Node
<span class="lineno"> 748 </span>
<span class="lineno"> 749 </span><span class="error">/**</span>
<span class="lineno"> 750 </span><span class="error"> * Head (sentinel) item of the linked list that is never removed.</span>
<span class="lineno"> 751 </span><span class="error"> *</span>
<span class="lineno"> 752 </span><span class="error"> * @suppress **This is unstable API and it is subject to change.**</span>
</code></pre>
      </li>
    </ul>
  </details>
  <details id="OpenClosedPrinciple" open="open">
    <summary class="rule-container"><span class="rule">OpenClosedPrinciple: 110 </span><span class="description">This rule reports use of switching on enums and classes, which may be a sign of violation the open closed principle.</span></summary>
    <ul>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-android/jvm/src/io/ktor/client/engine/android/AndroidClientEngine.kt:109:5</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.WriteChannelContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.ByteArrayContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 106 </span>internal suspend fun OutgoingContent.writeTo(
<span class="lineno"> 107 </span>    stream: OutputStream, callContext: CoroutineContext
<span class="lineno"> 108 </span>): Unit = stream.use { blockingOutput -&gt;
<span class="lineno"> 109 </span>    <span class="error">when (this) {</span>
<span class="lineno"> 110 </span><span class="error">        is OutgoingContent.ByteArrayContent -&gt; blockingOutput.write(bytes())</span>
<span class="lineno"> 111 </span><span class="error">        is OutgoingContent.ReadChannelContent -&gt; run {</span>
<span class="lineno"> 112 </span><span class="error">            readFrom().copyTo(blockingOutput)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-apache/jvm/src/io/ktor/client/engine/apache/ApacheHttpRequest.kt:40:31</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `java.net.SocketTimeoutException`, `ConnectException`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  37 </span>
<span class="lineno">  38 </span>    val callback = object : FutureCallback&lt;Unit&gt; {
<span class="lineno">  39 </span>        override fun failed(exception: Exception) {
<span class="lineno">  40 </span>            val mappedCause = <span class="error">when {</span>
<span class="lineno">  41 </span><span class="error">                exception is ConnectException &amp;&amp; exception.isTimeoutException() -&gt; ConnectTimeoutException(</span>
<span class="lineno">  42 </span><span class="error">                    requestData, exception</span>
<span class="lineno">  43 </span><span class="error">                )</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-apache/jvm/src/io/ktor/client/engine/apache/ApacheRequestProducer.kt:44:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.WriteChannelContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.NoContent`, `OutgoingContent.ProtocolUpgrade`, `OutgoingContent.ByteArrayContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  41 </span>    private val currentBuffer: AtomicRef&lt;ByteBuffer?&gt; = atomic(null)
<span class="lineno">  42 </span>
<span class="lineno">  43 </span>    init {
<span class="lineno">  44 </span>        <span class="error">when (val body = requestData.body) {</span>
<span class="lineno">  45 </span><span class="error">            is OutgoingContent.ByteArrayContent -&gt; {</span>
<span class="lineno">  46 </span><span class="error">                requestChannel.offer(ByteBuffer.wrap(body.bytes()))</span>
<span class="lineno">  47 </span><span class="error">                requestChannel.close()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-apache/jvm/src/io/ktor/client/engine/apache/ApacheResponseConsumerDispatching.kt:125:27</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `java.net.SocketTimeoutException`, `ConnectException`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 122 </span>    }
<span class="lineno"> 123 </span>
<span class="lineno"> 124 </span>    override fun failed(cause: Exception) {
<span class="lineno"> 125 </span>        val mappedCause = <span class="error">when {</span>
<span class="lineno"> 126 </span><span class="error">            cause is ConnectException &amp;&amp; cause.isTimeoutException() -&gt; ConnectTimeoutException(requestData!!, cause)</span>
<span class="lineno"> 127 </span><span class="error">            cause is java.net.SocketTimeoutException -&gt; SocketTimeoutException(requestData!!, cause)</span>
<span class="lineno"> 128 </span><span class="error">            else -&gt; cause</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-cio/jvm/src/io/ktor/client/engine/cio/Endpoint.kt:123:35</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `java.net.SocketTimeoutException`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 120 </span>
<span class="lineno"> 121 </span>            response.resume(responseData)
<span class="lineno"> 122 </span>        } catch (cause: Throwable) {
<span class="lineno"> 123 </span>            val mappedException = <span class="error">when (cause.rootCause) {</span>
<span class="lineno"> 124 </span><span class="error">                is java.net.SocketTimeoutException -&gt; SocketTimeoutException(task.request, cause)</span>
<span class="lineno"> 125 </span><span class="error">                else -&gt; cause</span>
<span class="lineno"> 126 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-cio/jvm/src/io/ktor/client/engine/cio/utils.kt:68:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.ProtocolUpgrade`, `OutgoingContent.WriteChannelContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.ByteArrayContent`, `OutgoingContent.NoContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  65 </span>        val channel = chunkedJob?.channel ?: output
<span class="lineno">  66 </span>
<span class="lineno">  67 </span>        try {
<span class="lineno">  68 </span>            <span class="error">when (content) {</span>
<span class="lineno">  69 </span><span class="error">                is OutgoingContent.NoContent -&gt; return</span>
<span class="lineno">  70 </span><span class="error">                is OutgoingContent.ByteArrayContent -&gt; channel.writeFully(content.bytes())</span>
<span class="lineno">  71 </span><span class="error">                is OutgoingContent.ReadChannelContent -&gt; content.readFrom().copyAndClose(channel)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/DefaultTransform.kt:30:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `ByteReadChannel`, `ByteArray`, `String`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  27 </span>            context.headers.append(HttpHeaders.Accept, &quot;*/*&quot;)
<span class="lineno">  28 </span>        }
<span class="lineno">  29 </span>
<span class="lineno">  30 </span>        <span class="error">when (body) {</span>
<span class="lineno">  31 </span><span class="error">            is String -&gt; {</span>
<span class="lineno">  32 </span><span class="error">                val contentType = context.headers[HttpHeaders.ContentType]?.let {</span>
<span class="lineno">  33 </span><span class="error">                    context.headers.remove(HttpHeaders.ContentType)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/request/forms/FormDataContent.kt:58:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `PartData.FormItem`, `PartData.BinaryItem`, `PartData.FileItem`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  55 </span>        }
<span class="lineno">  56 </span>
<span class="lineno">  57 </span>        val bodySize = part.headers[HttpHeaders.ContentLength]?.toLong()
<span class="lineno">  58 </span>        <span class="error">when (part) {</span>
<span class="lineno">  59 </span><span class="error">            is PartData.FileItem -&gt; {</span>
<span class="lineno">  60 </span><span class="error">                val headers = headersBuilder.build().readBytes()</span>
<span class="lineno">  61 </span><span class="error">                val size = bodySize?.plus(PART_OVERHEAD_SIZE)?.plus(headers.size)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/request/forms/formDsl.kt:33:20</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Input`, `InputProvider`, `ByteReadPacket`, `ByteArray`, `Number`, `String`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  30 </span>            append(HttpHeaders.ContentDisposition, &quot;form-data; name=$key&quot;)
<span class="lineno">  31 </span>            appendAll(headers)
<span class="lineno">  32 </span>        }
<span class="lineno">  33 </span>        val part = <span class="error">when (value) {</span>
<span class="lineno">  34 </span><span class="error">            is String -&gt; PartData.FormItem(value, {}, partHeaders.build())</span>
<span class="lineno">  35 </span><span class="error">            is Number -&gt; PartData.FormItem(value.toString(), {}, partHeaders.build())</span>
<span class="lineno">  36 </span><span class="error">            is ByteArray -&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/utils/Content.kt:26:81</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.ProtocolUpgrade`, `OutgoingContent.ByteArrayContent`, `OutgoingContent.WriteChannelContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.NoContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  23 </span> * Generates a new [OutgoingContent] of the same abstract type
<span class="lineno">  24 </span> * but with [OutgoingContent.headers] transformed by the specified [block].
<span class="lineno">  25 </span> */
<span class="lineno">  26 </span>fun OutgoingContent.wrapHeaders(block: (Headers) -&gt; Headers): OutgoingContent = <span class="error">when (this) {</span>
<span class="lineno">  27 </span><span class="error">    is OutgoingContent.NoContent -&gt; object : OutgoingContent.NoContent() {</span>
<span class="lineno">  28 </span><span class="error">        override val contentLength: Long? get() = this@wrapHeaders.contentLength</span>
<span class="lineno">  29 </span><span class="error">        override val contentType: ContentType? get() = this@wrapHeaders.contentType</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/js/src/io/ktor/client/engine/js/JsUtils.kt:24:21</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.WriteChannelContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.ByteArrayContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  21 </span>        jsHeaders[key] = value
<span class="lineno">  22 </span>    }
<span class="lineno">  23 </span>
<span class="lineno">  24 </span>    val bodyBytes = <span class="error">when (val content = body) {</span>
<span class="lineno">  25 </span><span class="error">        is OutgoingContent.ByteArrayContent -&gt; content.bytes()</span>
<span class="lineno">  26 </span><span class="error">        is OutgoingContent.ReadChannelContent -&gt; content.readFrom().readRemaining().readBytes()</span>
<span class="lineno">  27 </span><span class="error">        is OutgoingContent.WriteChannelContent -&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/js/src/io/ktor/client/features/websocket/JsWebSocketSession.kt:37:36</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `String`, `ArrayBuffer`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  34 </span>            launch {
<span class="lineno">  35 </span>                val data = event.data
<span class="lineno">  36 </span>
<span class="lineno">  37 </span>                val frame: Frame = <span class="error">when (data) {</span>
<span class="lineno">  38 </span><span class="error">                    is ArrayBuffer -&gt; Frame.Binary(false, Int8Array(data).unsafeCast&lt;ByteArray&gt;())</span>
<span class="lineno">  39 </span><span class="error">                    is String -&gt; Frame.Text(data)</span>
<span class="lineno">  40 </span><span class="error">                    else -&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/jvm/src/io/ktor/network/sockets/TimeoutExceptionsJvm.kt:74:5</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `java.net.SocketTimeoutException`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  71 </span> * close it with [SocketTimeoutException]).
<span class="lineno">  72 </span> */
<span class="lineno">  73 </span>private fun ByteChannelWithMappedExceptions(request: HttpRequestData) = ByteChannel { cause -&gt;
<span class="lineno">  74 </span>    <span class="error">when (cause?.rootCause) {</span>
<span class="lineno">  75 </span><span class="error">        is java.net.SocketTimeoutException -&gt; SocketTimeoutException(request, cause)</span>
<span class="lineno">  76 </span><span class="error">        else -&gt; cause</span>
<span class="lineno">  77 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-curl/posix/src/io/ktor/client/engine/curl/CurlProcessor.kt:71:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `CurlFail`, `CurlSuccess`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  68 </span>    private fun processPoll(result: List&lt;CurlResponseData&gt;) {
<span class="lineno">  69 </span>        result.forEach { response -&gt;
<span class="lineno">  70 </span>            val task = responseConsumers[response.request]!!
<span class="lineno">  71 </span>            <span class="error">when (response) {</span>
<span class="lineno">  72 </span><span class="error">                is CurlSuccess -&gt; task.complete(response)</span>
<span class="lineno">  73 </span><span class="error">                is CurlFail -&gt; task.completeExceptionally(response.cause)</span>
<span class="lineno">  74 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-curl/posix/src/io/ktor/client/engine/curl/internal/CurlRaw.kt:72:69</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.NoContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.WriteChannelContent`, `OutgoingContent.ByteArrayContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  69 </span>    override fun toString(): String = &quot;CurlFail($cause)&quot;
<span class="lineno">  70 </span>}
<span class="lineno">  71 </span>
<span class="lineno">  72 </span>internal suspend fun OutgoingContent.toCurlByteArray(): ByteArray = <span class="error">when (this@toCurlByteArray) {</span>
<span class="lineno">  73 </span><span class="error">    is OutgoingContent.ByteArrayContent -&gt; bytes()</span>
<span class="lineno">  74 </span><span class="error">    is OutgoingContent.WriteChannelContent -&gt; GlobalScope.writer(coroutineContext) {</span>
<span class="lineno">  75 </span><span class="error">        writeTo(channel)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-features/ktor-client-json/common/src/io/ktor/client/features/json/JsonFeature.kt:115:41</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `EmptyContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 112 </span>
<span class="lineno"> 113 </span>                context.headers.remove(HttpHeaders.ContentType)
<span class="lineno"> 114 </span>
<span class="lineno"> 115 </span>                val serializedContent = <span class="error">when (payload) {</span>
<span class="lineno"> 116 </span><span class="error">                    is EmptyContent -&gt; feature.serializer.write(Unit, contentType)</span>
<span class="lineno"> 117 </span><span class="error">                    else -&gt; feature.serializer.write(payload, contentType)</span>
<span class="lineno"> 118 </span><span class="error">                }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-features/ktor-client-json/ktor-client-serialization/common/src/io/ktor/client/features/json/serializer/KotlinxSerializer.kt:87:59</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Map&lt;*, *&gt;`, `Set&lt;*&gt;`, `Array&lt;*&gt;`, `List&lt;*&gt;`, `JsonElement`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  84 </span>
<span class="lineno">  85 </span>@Suppress(&quot;UNCHECKED_CAST&quot;)
<span class="lineno">  86 </span>@OptIn(ImplicitReflectionSerializer::class)
<span class="lineno">  87 </span>private fun buildSerializer(value: Any): KSerializer&lt;*&gt; = <span class="error">when (value) {</span>
<span class="lineno">  88 </span><span class="error">    is JsonElement -&gt; JsonElementSerializer</span>
<span class="lineno">  89 </span><span class="error">    is List&lt;*&gt; -&gt; value.elementSerializer().list</span>
<span class="lineno">  90 </span><span class="error">    is Array&lt;*&gt; -&gt; value.firstOrNull()?.let { buildSerializer(it) } ?: String.serializer().list</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-features/ktor-client-logging/common/src/io/ktor/client/features/logging/ObservingUtils.kt:12:88</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.WriteChannelContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.ByteArrayContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">   9 </span>import io.ktor.utils.io.*
<span class="lineno">  10 </span>import kotlinx.coroutines.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span>internal suspend fun OutgoingContent.observe(log: ByteWriteChannel): OutgoingContent = <span class="error">when (this) {</span>
<span class="lineno">  13 </span><span class="error">    is OutgoingContent.ByteArrayContent -&gt; {</span>
<span class="lineno">  14 </span><span class="error">        log.writeFully(bytes())</span>
<span class="lineno">  15 </span><span class="error">        log.close()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-features/ktor-client-tracing/ktor-client-tracing-stetho/android/src/io/ktor/client/features/tracing/KtorInterceptorRequest.kt:34:39</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.ByteArrayContent`, `OutgoingContent.WriteChannelContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.ProtocolUpgrade`, `OutgoingContent.NoContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  31 </span>        return null
<span class="lineno">  32 </span>    }
<span class="lineno">  33 </span>
<span class="lineno">  34 </span>    override fun body(): ByteArray? = <span class="error">when (val body = requestData.body) {</span>
<span class="lineno">  35 </span><span class="error">        is OutgoingContent.NoContent -&gt; null</span>
<span class="lineno">  36 </span><span class="error">        is OutgoingContent.ProtocolUpgrade -&gt; null</span>
<span class="lineno">  37 </span><span class="error">        is OutgoingContent.ReadChannelContent -&gt; runBlocking { body.readFrom().toByteArray() }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-ios/darwin/src/io/ktor/client/engine/ios/IosUtils.kt:16:60</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.NoContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.WriteChannelContent`, `OutgoingContent.ByteArrayContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  13 </span>import kotlinx.coroutines.*
<span class="lineno">  14 </span>import platform.Foundation.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span>internal suspend fun OutgoingContent.toNSData(): NSData? = <span class="error">when (this) {</span>
<span class="lineno">  17 </span><span class="error">    is OutgoingContent.ByteArrayContent -&gt; bytes().toNSData()</span>
<span class="lineno">  18 </span><span class="error">    is OutgoingContent.WriteChannelContent -&gt; GlobalScope.writer(Dispatchers.Unconfined) {</span>
<span class="lineno">  19 </span><span class="error">        writeTo(channel)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-jetty/jvm/src/io/ktor/client/engine/jetty/JettyHttpRequest.kt:85:5</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.ProtocolUpgrade`, `OutgoingContent.WriteChannelContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.ByteArrayContent`, `OutgoingContent.NoContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  82 </span>}
<span class="lineno">  83 </span>
<span class="lineno">  84 </span>private fun sendRequestBody(request: JettyHttp2Request, content: OutgoingContent, callContext: CoroutineContext) {
<span class="lineno">  85 </span>    <span class="error">when (content) {</span>
<span class="lineno">  86 </span><span class="error">        is OutgoingContent.NoContent -&gt; return</span>
<span class="lineno">  87 </span><span class="error">        is OutgoingContent.ByteArrayContent -&gt; GlobalScope.launch(callContext) {</span>
<span class="lineno">  88 </span><span class="error">            request.write(ByteBuffer.wrap(content.bytes()))</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-mock/common/src/io/ktor/client/engine/mock/MockUtils.kt:18:56</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.WriteChannelContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.ByteArrayContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  15 </span>
<span class="lineno">  16 </span>@Suppress(&quot;KDocMissingDocumentation&quot;)
<span class="lineno">  17 </span>@KtorExperimentalAPI
<span class="lineno">  18 </span>suspend fun OutgoingContent.toByteArray(): ByteArray = <span class="error">when (this) {</span>
<span class="lineno">  19 </span><span class="error">    is OutgoingContent.ByteArrayContent -&gt; bytes()</span>
<span class="lineno">  20 </span><span class="error">    is OutgoingContent.ReadChannelContent -&gt; readFrom().toByteArray()</span>
<span class="lineno">  21 </span><span class="error">    is OutgoingContent.WriteChannelContent -&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-mock/common/src/io/ktor/client/engine/mock/MockUtils.kt:29:66</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.WriteChannelContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.ByteArrayContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  26 </span>
<span class="lineno">  27 </span>@Suppress(&quot;KDocMissingDocumentation&quot;)
<span class="lineno">  28 </span>@KtorExperimentalAPI
<span class="lineno">  29 </span>suspend fun OutgoingContent.toByteReadPacket(): ByteReadPacket = <span class="error">when (this) {</span>
<span class="lineno">  30 </span><span class="error">    is OutgoingContent.ByteArrayContent -&gt; ByteReadPacket(bytes())</span>
<span class="lineno">  31 </span><span class="error">    is OutgoingContent.ReadChannelContent -&gt; readFrom().readRemaining()</span>
<span class="lineno">  32 </span><span class="error">    is OutgoingContent.WriteChannelContent -&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt:160:84</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `java.net.SocketTimeoutException`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 157 </span>        }
<span class="lineno"> 158 </span>    }.channel
<span class="lineno"> 159 </span>
<span class="lineno"> 160 </span>private fun mapExceptions(cause: Throwable, request: HttpRequestData): Throwable = <span class="error">when (cause) {</span>
<span class="lineno"> 161 </span><span class="error">    is java.net.SocketTimeoutException -&gt; SocketTimeoutException(request, cause)</span>
<span class="lineno"> 162 </span><span class="error">    else -&gt; cause</span>
<span class="lineno"> 163 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt:186:97</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.NoContent`, `OutgoingContent.WriteChannelContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.ByteArrayContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 183 </span>    return builder.build()
<span class="lineno"> 184 </span>}
<span class="lineno"> 185 </span>
<span class="lineno"> 186 </span>internal fun OutgoingContent.convertToOkHttpBody(callContext: CoroutineContext): RequestBody? = <span class="error">when (this) {</span>
<span class="lineno"> 187 </span><span class="error">    is OutgoingContent.ByteArrayContent -&gt; RequestBody.create(null, bytes())</span>
<span class="lineno"> 188 </span><span class="error">    is OutgoingContent.ReadChannelContent -&gt; StreamRequestBody(contentLength) { readFrom() }</span>
<span class="lineno"> 189 </span><span class="error">    is OutgoingContent.WriteChannelContent -&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpWebsocketSession.kt:57:17</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Frame.Close`, `Frame.Text`, `Frame.Binary`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  54 </span>
<span class="lineno">  55 </span>        try {
<span class="lineno">  56 </span>            for (frame in channel) {
<span class="lineno">  57 </span>                <span class="error">when (frame) {</span>
<span class="lineno">  58 </span><span class="error">                    is Frame.Binary -&gt; websocket.send(frame.data.toByteString(0, frame.data.size))</span>
<span class="lineno">  59 </span><span class="error">                    is Frame.Text -&gt; websocket.send(String(frame.data))</span>
<span class="lineno">  60 </span><span class="error">                    is Frame.Close -&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkUtils.kt:26:39</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `java.net.SocketTimeoutException`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  23 </span>                    return
<span class="lineno">  24 </span>                }
<span class="lineno">  25 </span>
<span class="lineno">  26 </span>                val mappedException = <span class="error">when (cause) {</span>
<span class="lineno">  27 </span><span class="error">                    is java.net.SocketTimeoutException -&gt; if (cause.message?.contains(&quot;connect&quot;) == true) {</span>
<span class="lineno">  28 </span><span class="error">                        ConnectTimeoutException(requestData, cause)</span>
<span class="lineno">  29 </span><span class="error">                    } else {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-tests/common/src/io/ktor/client/tests/utils/Generators.kt:27:23</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `PartData.BinaryItem`, `PartData.FormItem`, `PartData.FileItem`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  24 </span>    val list = this@makeString
<span class="lineno">  25 </span>    list.forEach {
<span class="lineno">  26 </span>        append(&quot;${it.name!!}\n&quot;)
<span class="lineno">  27 </span>        val content = <span class="error">when (it) {</span>
<span class="lineno">  28 </span><span class="error">            is PartData.FileItem -&gt; filenameContentTypeAndContentString(it.provider, it.headers)</span>
<span class="lineno">  29 </span><span class="error">            is PartData.FormItem -&gt; it.value</span>
<span class="lineno">  30 </span><span class="error">            is PartData.BinaryItem -&gt; filenameContentTypeAndContentString(it.provider, it.headers)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth-jwt/jvm/src/io/ktor/auth/jwt/JWTAuth.kt:282:63</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `HttpAuthHeader.Single`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 279 </span>    return validate(call, credentials)
<span class="lineno"> 280 </span>}
<span class="lineno"> 281 </span>
<span class="lineno"> 282 </span>private fun HttpAuthHeader.getBlob(schemes: JWTAuthSchemes) = <span class="error">when {</span>
<span class="lineno"> 283 </span><span class="error">    this is HttpAuthHeader.Single &amp;&amp; authScheme in schemes -&gt; blob</span>
<span class="lineno"> 284 </span><span class="error">    else -&gt; null</span>
<span class="lineno"> 285 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/BasicAuth.kt:108:5</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `HttpAuthHeader.Single`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 105 </span> */
<span class="lineno"> 106 </span>@KtorExperimentalAPI
<span class="lineno"> 107 </span>fun ApplicationRequest.basicAuthenticationCredentials(charset: Charset? = null): UserPasswordCredential? {
<span class="lineno"> 108 </span>    <span class="error">when (val authHeader = parseAuthorizationHeader()) {</span>
<span class="lineno"> 109 </span><span class="error">        is HttpAuthHeader.Single -&gt; {</span>
<span class="lineno"> 110 </span><span class="error">            // Verify the auth scheme is HTTP Basic. According to RFC 2617, the authorization scheme should not be case</span>
<span class="lineno"> 111 </span><span class="error">            // sensitive; thus BASIC, or Basic, or basic are all valid.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/FormAuth.kt:167:5</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `FormAuthChallenge.Redirect`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 164 </span>    challenge: FormAuthChallenge,
<span class="lineno"> 165 </span>    credentials: UserPasswordCredential?
<span class="lineno"> 166 </span>) {
<span class="lineno"> 167 </span>    <span class="error">when (challenge) {</span>
<span class="lineno"> 168 </span><span class="error">        FormAuthChallenge.Unauthorized -&gt; call.respond(UnauthorizedResponse())</span>
<span class="lineno"> 169 </span><span class="error">        is FormAuthChallenge.Redirect -&gt; call.respondRedirect(challenge.url(call, credentials))</span>
<span class="lineno"> 170 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuth.kt:200:5</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OAuthServerSettings.OAuth2ServerSettings`, `OAuthServerSettings.OAuth1aServerSettings`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 197 </span>    provider: OAuthServerSettings,
<span class="lineno"> 198 </span>    callbackUrl: String
<span class="lineno"> 199 </span>) {
<span class="lineno"> 200 </span>    <span class="error">when (provider) {</span>
<span class="lineno"> 201 </span><span class="error">        is OAuthServerSettings.OAuth1aServerSettings -&gt; {</span>
<span class="lineno"> 202 </span><span class="error">            withContext(dispatcher) {</span>
<span class="lineno"> 203 </span><span class="error">                val requestToken = simpleOAuth1aStep1(client, provider, callbackUrl)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuth.kt:231:5</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OAuthServerSettings.OAuth2ServerSettings`, `OAuthServerSettings.OAuth1aServerSettings`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 228 </span>    configure: HttpRequestBuilder.() -&gt; Unit = {},
<span class="lineno"> 229 </span>    block: suspend (OAuthAccessTokenResponse) -&gt; Unit
<span class="lineno"> 230 </span>) {
<span class="lineno"> 231 </span>    <span class="error">when (provider) {</span>
<span class="lineno"> 232 </span><span class="error">        is OAuthServerSettings.OAuth1aServerSettings -&gt; {</span>
<span class="lineno"> 233 </span><span class="error">            val tokens = call.oauth1aHandleCallback()</span>
<span class="lineno"> 234 </span><span class="error">            if (tokens == null) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-serialization/jvm/src/io/ktor/serialization/SerializationConverter.kt:116:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `BinaryFormat`, `StringFormat`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 113 </span>        @Suppress(&quot;UNCHECKED_CAST&quot;)
<span class="lineno"> 114 </span>        val serializer = serializerForSending(value) as KSerializer&lt;Any&gt;
<span class="lineno"> 115 </span>
<span class="lineno"> 116 </span>        return <span class="error">when (format) {</span>
<span class="lineno"> 117 </span><span class="error">            is StringFormat -&gt; {</span>
<span class="lineno"> 118 </span><span class="error">                val content = format.stringify(serializer, value)</span>
<span class="lineno"> 119 </span><span class="error">                TextContent(content, contentType.withCharset(context.call.suitableCharset()))</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-serialization/jvm/src/io/ktor/serialization/SerializationConverter.kt:137:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `BinaryFormat`, `StringFormat`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 134 </span>        val serializer = serializerByTypeInfo(request.typeInfo)
<span class="lineno"> 135 </span>        val contentPacket = channel.readRemaining()
<span class="lineno"> 136 </span>
<span class="lineno"> 137 </span>        return <span class="error">when (format) {</span>
<span class="lineno"> 138 </span><span class="error">            is StringFormat -&gt; format.parse(serializer, contentPacket.readText(charset))</span>
<span class="lineno"> 139 </span><span class="error">            is BinaryFormat -&gt; format.load(serializer, contentPacket.readBytes())</span>
<span class="lineno"> 140 </span><span class="error">            else -&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/Cookie.kt:187:74</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `CookieEncoding`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 184 </span> * Encode cookie value using the specified [encoding]
<span class="lineno"> 185 </span> */
<span class="lineno"> 186 </span>@KtorExperimentalAPI
<span class="lineno"> 187 </span>fun encodeCookieValue(value: String, encoding: CookieEncoding): String = <span class="error">when (encoding) {</span>
<span class="lineno"> 188 </span><span class="error">    CookieEncoding.RAW -&gt; when {</span>
<span class="lineno"> 189 </span><span class="error">        value.any { it.shouldEscapeInCookies() } -&gt; throw IllegalArgumentException(&quot;The cookie value contains characters that couldn't be encoded in RAW format. Consider URL_ENCODING mode&quot;)</span>
<span class="lineno"> 190 </span><span class="error">        else -&gt; value</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/Cookie.kt:205:81</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `CookieEncoding`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 202 </span> * Decode cookie value using the specified [encoding]
<span class="lineno"> 203 </span> */
<span class="lineno"> 204 </span>@KtorExperimentalAPI
<span class="lineno"> 205 </span>fun decodeCookieValue(encodedValue: String, encoding: CookieEncoding): String = <span class="error">when (encoding) {</span>
<span class="lineno"> 206 </span><span class="error">    CookieEncoding.RAW, CookieEncoding.DQUOTES -&gt; when {</span>
<span class="lineno"> 207 </span><span class="error">        encodedValue.trimStart().startsWith(&quot;\&quot;&quot;) &amp;&amp; encodedValue.trimEnd().endsWith(&quot;\&quot;&quot;) -&gt;</span>
<span class="lineno"> 208 </span><span class="error">            encodedValue.trim().removeSurrounding(&quot;\&quot;&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/Ranges.kt:86:5</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `ContentRange.Suffix`, `ContentRange.TailFrom`, `ContentRange.Bounded`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  83 </span>}
<span class="lineno">  84 </span>
<span class="lineno">  85 </span>internal fun List&lt;ContentRange&gt;.toLongRanges(contentLength: Long) = map {
<span class="lineno">  86 </span>    <span class="error">when (it) {</span>
<span class="lineno">  87 </span><span class="error">        is ContentRange.Bounded -&gt; it.from..it.to.coerceAtMost(contentLength - 1)</span>
<span class="lineno">  88 </span><span class="error">        is ContentRange.TailFrom -&gt; it.from until contentLength</span>
<span class="lineno">  89 </span><span class="error">        is ContentRange.Suffix -&gt; (contentLength - it.lastCount).coerceAtLeast(0L) until contentLength</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/RangesSpecifier.kt:25:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `ContentRange.Suffix`, `ContentRange.TailFrom`, `ContentRange.Bounded`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  22 </span>     */
<span class="lineno">  23 </span>    fun isValid(rangeUnitPredicate: (String) -&gt; Boolean = { it == RangeUnits.Bytes.unitToken }): Boolean =
<span class="lineno">  24 </span>        rangeUnitPredicate(unit) &amp;&amp; ranges.none {
<span class="lineno">  25 </span>            <span class="error">when (it) {</span>
<span class="lineno">  26 </span><span class="error">                is ContentRange.Bounded -&gt; it.from &lt; 0 || it.to &lt; it.from</span>
<span class="lineno">  27 </span><span class="error">                is ContentRange.TailFrom -&gt; it.from &lt; 0</span>
<span class="lineno">  28 </span><span class="error">                is ContentRange.Suffix -&gt; it.lastCount &lt; 0</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/auth/HttpAuthHeader.kt:144:68</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `HeaderValueEncoding`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 141 </span>         */
<span class="lineno"> 142 </span>        fun parameter(name: String): String? = parameters.firstOrNull { it.name == name }?.value
<span class="lineno"> 143 </span>
<span class="lineno"> 144 </span>        private fun String.encode(encoding: HeaderValueEncoding) = <span class="error">when (encoding) {</span>
<span class="lineno"> 145 </span><span class="error">            HeaderValueEncoding.QUOTED_WHEN_REQUIRED -&gt; escapeIfNeeded()</span>
<span class="lineno"> 146 </span><span class="error">            HeaderValueEncoding.QUOTED_ALWAYS -&gt; quote()</span>
<span class="lineno"> 147 </span><span class="error">            HeaderValueEncoding.URI_ENCODE -&gt; encodeURLParameter()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/parsing/Debug.kt:7:58</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `RangeGrammar`, `AnyOfGrammar`, `AtLeastOne`, `ManyGrammar`, `MaybeGrammar`, `OrGrammar`, `SequenceGrammar`, `NamedGrammar`, `RawGrammar`, `StringGrammar`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">   4 </span>
<span class="lineno">   5 </span>package io.ktor.http.parsing
<span class="lineno">   6 </span>
<span class="lineno">   7 </span>internal fun Grammar.printDebug(offset: Int = 0): Unit = <span class="error">when (this) {</span>
<span class="lineno">   8 </span><span class="error">    is StringGrammar -&gt; printlnWithOffset(offset, &quot;STRING[${Regex.escape(value)}]&quot;)</span>
<span class="lineno">   9 </span><span class="error">    is RawGrammar -&gt; printlnWithOffset(offset, &quot;STRING[$value]&quot;)</span>
<span class="lineno">  10 </span><span class="error">    is NamedGrammar -&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/parsing/regex/RegexParserGenerator.kt:53:24</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `AtLeastOne`, `ManyGrammar`, `MaybeGrammar`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  50 </span>        GrammarRegex(expression.toString(), groupsCount, shouldGroup)
<span class="lineno">  51 </span>    }
<span class="lineno">  52 </span>    is SimpleGrammar -&gt; {
<span class="lineno">  53 </span>        val operator = <span class="error">when (this) {</span>
<span class="lineno">  54 </span><span class="error">            is MaybeGrammar -&gt; '?'</span>
<span class="lineno">  55 </span><span class="error">            is ManyGrammar -&gt; '*'</span>
<span class="lineno">  56 </span><span class="error">            is AtLeastOne -&gt; '+'</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/websocket/WebSocketSession.kt:98:18</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `CancellationException`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  95 </span> */
<span class="lineno">  96 </span>@InternalAPI
<span class="lineno">  97 </span>suspend fun WebSocketSession.closeExceptionally(cause: Throwable) {
<span class="lineno">  98 </span>    val reason = <span class="error">when (cause) {</span>
<span class="lineno">  99 </span><span class="error">        is CancellationException -&gt; CloseReason(CloseReason.Codes.NORMAL, &quot;&quot;)</span>
<span class="lineno"> 100 </span><span class="error">        else -&gt; CloseReason(CloseReason.Codes.INTERNAL_ERROR, cause.toString())</span>
<span class="lineno"> 101 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/js/src/io/ktor/http/cio/websocket/FrameJs.kt:96:20</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `FrameType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  93 </span>            fin: Boolean,
<span class="lineno">  94 </span>            frameType: FrameType,
<span class="lineno">  95 </span>            data: ByteArray
<span class="lineno">  96 </span>        ): Frame = <span class="error">when (frameType) {</span>
<span class="lineno">  97 </span><span class="error">            FrameType.BINARY -&gt; Binary(fin, data)</span>
<span class="lineno">  98 </span><span class="error">            FrameType.TEXT -&gt; Text(fin, data)</span>
<span class="lineno">  99 </span><span class="error">            FrameType.CLOSE -&gt; Close(data)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/CIOMultipartData.kt:54:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `MultipartEvent.MultipartPart`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  51 </span>
<span class="lineno">  52 </span>    private suspend fun eventToData(evt: MultipartEvent): PartData? {
<span class="lineno">  53 </span>        return try {
<span class="lineno">  54 </span>            <span class="error">when (evt) {</span>
<span class="lineno">  55 </span><span class="error">                is MultipartEvent.MultipartPart -&gt; partToData(evt)</span>
<span class="lineno">  56 </span><span class="error">                else -&gt; {</span>
<span class="lineno">  57 </span><span class="error">                    evt.release()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/websocket/DefaultWebSocketSessionImpl.kt:101:17</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Frame.Ping`, `Frame.Pong`, `Frame.Close`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  98 </span>        var closeFramePresented = false
<span class="lineno">  99 </span>        try {
<span class="lineno"> 100 </span>            raw.incoming.consumeEach { frame -&gt;
<span class="lineno"> 101 </span>                <span class="error">when (frame) {</span>
<span class="lineno"> 102 </span><span class="error">                    is Frame.Close -&gt; {</span>
<span class="lineno"> 103 </span><span class="error">                        outgoing.send(Frame.Close(frame.readReason() ?: NORMAL_CLOSE))</span>
<span class="lineno"> 104 </span><span class="error">                        closeFramePresented = true</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/websocket/Frame.kt:118:20</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `FrameType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 115 </span>            fin: Boolean,
<span class="lineno"> 116 </span>            frameType: FrameType,
<span class="lineno"> 117 </span>            data: ByteArray
<span class="lineno"> 118 </span>        ): Frame = <span class="error">when (frameType) {</span>
<span class="lineno"> 119 </span><span class="error">            FrameType.BINARY -&gt; Binary(fin, data)</span>
<span class="lineno"> 120 </span><span class="error">            FrameType.TEXT -&gt; Text(fin, data)</span>
<span class="lineno"> 121 </span><span class="error">            FrameType.CLOSE -&gt; Close(data)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/websocket/FrameParser.kt:62:46</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `State`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  59 </span>        if (handleStep(bb)) frame(bb)
<span class="lineno">  60 </span>    }
<span class="lineno">  61 </span>
<span class="lineno">  62 </span>    private fun handleStep(bb: ByteBuffer) = <span class="error">when (state.get()!!) {</span>
<span class="lineno">  63 </span><span class="error">        State.HEADER0 -&gt; parseHeader1(bb)</span>
<span class="lineno">  64 </span><span class="error">        State.LENGTH -&gt; parseLength(bb)</span>
<span class="lineno">  65 </span><span class="error">        State.MASK_KEY -&gt; parseMaskKey(bb)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/websocket/WebSocketReader.kt:77:13</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `State`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  74 </span>
<span class="lineno">  75 </span>    private suspend fun parseLoop(buffer: ByteBuffer) {
<span class="lineno">  76 </span>        while (buffer.hasRemaining()) {
<span class="lineno">  77 </span>            <span class="error">when (state) {</span>
<span class="lineno">  78 </span><span class="error">                State.HEADER -&gt; {</span>
<span class="lineno">  79 </span><span class="error">                    frameParser.frame(buffer)</span>
<span class="lineno">  80 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/websocket/WebSocketWriter.kt:51:17</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `FlushRequest`, `Frame`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  48 </span>        buffer.clear()
<span class="lineno">  49 </span>        try {
<span class="lineno">  50 </span>            loop@ for (message in queue) {
<span class="lineno">  51 </span>                <span class="error">when (message) {</span>
<span class="lineno">  52 </span><span class="error">                    is Frame -&gt; if (drainQueueAndSerialize(message, buffer)) break@loop</span>
<span class="lineno">  53 </span><span class="error">                    is FlushRequest -&gt; message.complete() // we don't need writeChannel.flush() here as we do flush at end of every drainQueueAndSerialize</span>
<span class="lineno">  54 </span><span class="error">                    else -&gt; throw IllegalArgumentException(&quot;unknown message $message&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/websocket/WebSocketWriter.kt:99:17</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Frame`, `Frame.Close`, `FlushRequest`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  96 </span>        while (true) {
<span class="lineno">  97 </span>            while (flush == null &amp;&amp; !closeSent &amp;&amp; serializer.remainingCapacity &gt; 0) {
<span class="lineno">  98 </span>                val message = queue.poll() ?: break
<span class="lineno">  99 </span>                <span class="error">when (message) {</span>
<span class="lineno"> 100 </span><span class="error">                    is FlushRequest -&gt; flush = message</span>
<span class="lineno"> 101 </span><span class="error">                    is Frame.Close -&gt; {</span>
<span class="lineno"> 102 </span><span class="error">                        serializer.enqueue(message)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/posix/src/io/ktor/http/cio/websocket/FrameNative.kt:96:20</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `FrameType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  93 </span>            fin: Boolean,
<span class="lineno">  94 </span>            frameType: FrameType,
<span class="lineno">  95 </span>            data: ByteArray
<span class="lineno">  96 </span>        ): Frame = <span class="error">when (frameType) {</span>
<span class="lineno">  97 </span><span class="error">            FrameType.BINARY -&gt; Binary(fin, data)</span>
<span class="lineno">  98 </span><span class="error">            FrameType.TEXT -&gt; Text(fin, data)</span>
<span class="lineno">  99 </span><span class="error">            FrameType.CLOSE -&gt; Close(data)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/ChannelLittleEndian.kt:89:12</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ByteOrder`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  86 </span>@PublishedApi
<span class="lineno">  87 </span>@Suppress(&quot;DEPRECATION_ERROR&quot;)
<span class="lineno">  88 </span>internal inline fun &lt;T&gt; ByteReadChannel.toLittleEndian(value: T, reverseBlock: T.() -&gt; T): T {
<span class="lineno">  89 </span>    return <span class="error">when (readByteOrder) {</span>
<span class="lineno">  90 </span><span class="error">        ByteOrder.LITTLE_ENDIAN -&gt; value</span>
<span class="lineno">  91 </span><span class="error">        else -&gt; value.reverseBlock()</span>
<span class="lineno">  92 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/ChannelLittleEndian.kt:97:12</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ByteOrder`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  94 </span>
<span class="lineno">  95 </span>@Suppress(&quot;DEPRECATION_ERROR&quot;)
<span class="lineno">  96 </span>private inline fun &lt;T&gt; ByteWriteChannel.toLittleEndian(value: T, reverseBlock: T.() -&gt; T): T {
<span class="lineno">  97 </span>    return <span class="error">when (writeByteOrder) {</span>
<span class="lineno">  98 </span><span class="error">        ByteOrder.LITTLE_ENDIAN -&gt; value</span>
<span class="lineno">  99 </span><span class="error">        else -&gt; value.reverseBlock()</span>
<span class="lineno"> 100 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/ChannelLittleEndian.kt:105:12</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ByteOrder`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 102 </span>
<span class="lineno"> 103 </span>@PublishedApi
<span class="lineno"> 104 </span>internal inline fun &lt;T&gt; T.reverseIfNeeded(byteOrder: ByteOrder, reverseBlock: T.() -&gt; T): T {
<span class="lineno"> 105 </span>    return <span class="error">when (byteOrder) {</span>
<span class="lineno"> 106 </span><span class="error">        ByteOrder.BIG_ENDIAN -&gt; this</span>
<span class="lineno"> 107 </span><span class="error">        else -&gt; reverseBlock()</span>
<span class="lineno"> 108 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/ReadSession.kt:84:48</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `HasReadSession`, `SuspendableReadSession`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  81 </span>@PublishedApi
<span class="lineno">  82 </span>internal suspend fun ByteReadChannel.requestBuffer(desiredSize: Int): Buffer? {
<span class="lineno">  83 </span>    @Suppress(&quot;DEPRECATION&quot;)
<span class="lineno">  84 </span>    val readSession: SuspendableReadSession? = <span class="error">when {</span>
<span class="lineno">  85 </span><span class="error">        this is SuspendableReadSession -&gt; this</span>
<span class="lineno">  86 </span><span class="error">        this is HasReadSession -&gt; startReadSession()</span>
<span class="lineno">  87 </span><span class="error">        else -&gt; null</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/ReadSession.kt:145:80</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `HasReadSession`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 142 </span>}
<span class="lineno"> 143 </span>
<span class="lineno"> 144 </span>@Suppress(&quot;DEPRECATION&quot;, &quot;NOTHING_TO_INLINE&quot;)
<span class="lineno"> 145 </span>private inline fun ByteReadChannel.readSessionFor(): SuspendableReadSession? = <span class="error">when {</span>
<span class="lineno"> 146 </span><span class="error">    this is HasReadSession -&gt; startReadSession()</span>
<span class="lineno"> 147 </span><span class="error">    else -&gt; null</span>
<span class="lineno"> 148 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/WriterSession.kt:100:80</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `HasWriteSession`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  97 </span>}
<span class="lineno">  98 </span>
<span class="lineno">  99 </span>@Suppress(&quot;DEPRECATION&quot;, &quot;NOTHING_TO_INLINE&quot;)
<span class="lineno"> 100 </span>private inline fun ByteWriteChannel.writeSessionFor(): WriterSuspendSession? = <span class="error">when {</span>
<span class="lineno"> 101 </span><span class="error">    this is HasWriteSession -&gt; beginWriteSession()</span>
<span class="lineno"> 102 </span><span class="error">    else -&gt; null</span>
<span class="lineno"> 103 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/charsets/Encoding.kt:164:43</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `AbstractInput`, `ByteReadPacket`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 161 </span>    }
<span class="lineno"> 162 </span>}
<span class="lineno"> 163 </span>
<span class="lineno"> 164 </span>internal fun Input.sizeEstimate(): Long = <span class="error">when (this) {</span>
<span class="lineno"> 165 </span><span class="error">    is ByteReadPacket -&gt; remaining</span>
<span class="lineno"> 166 </span><span class="error">    is AbstractInput -&gt; maxOf(remaining, 16)</span>
<span class="lineno"> 167 </span><span class="error">    else -&gt; 16</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/InputLittleEndian.kt:285:12</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ByteOrder`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 282 </span>    read: () -&gt; T,
<span class="lineno"> 283 </span>    reverse: T.() -&gt; T
<span class="lineno"> 284 </span>): T {
<span class="lineno"> 285 </span>    return <span class="error">when (byteOrder) {</span>
<span class="lineno"> 286 </span><span class="error">        ByteOrder.BIG_ENDIAN -&gt; read()</span>
<span class="lineno"> 287 </span><span class="error">        else -&gt; read().reverse()</span>
<span class="lineno"> 288 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/OutputLittleEndian.kt:183:9</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ByteOrder`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 180 </span>    reverse: T.() -&gt; T
<span class="lineno"> 181 </span>) {
<span class="lineno"> 182 </span>    write(
<span class="lineno"> 183 </span>        <span class="error">when (byteOrder) {</span>
<span class="lineno"> 184 </span><span class="error">            ByteOrder.BIG_ENDIAN -&gt; value</span>
<span class="lineno"> 185 </span><span class="error">            else -&gt; value.reverse()</span>
<span class="lineno"> 186 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/internal/CancellableReusableContinuation.kt:36:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Throwable`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  33 </span>        loop@while (true) {
<span class="lineno">  34 </span>            val before = state.value
<span class="lineno">  35 </span>
<span class="lineno">  36 </span>            <span class="error">when (before) {</span>
<span class="lineno">  37 </span><span class="error">                null -&gt; {</span>
<span class="lineno">  38 </span><span class="error">                    if (!state.compareAndSet(null, actual)) continue@loop</span>
<span class="lineno">  39 </span><span class="error">                    parent(actual.context)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/jvm/javaio/Blocking.kt:143:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Continuation&lt;*&gt;`, `Thread`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 140 </span>                }
<span class="lineno"> 141 </span>            }
<span class="lineno"> 142 </span>
<span class="lineno"> 143 </span>            <span class="error">when (before) {</span>
<span class="lineno"> 144 </span><span class="error">                is Thread -&gt; LockSupport.unpark(before)</span>
<span class="lineno"> 145 </span><span class="error">                is Continuation&lt;*&gt; -&gt; result.exceptionOrNull()?.let { before.resumeWithException(it) }</span>
<span class="lineno"> 146 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/ktor-network-tls/jvm/src/io/ktor/network/tls/Parser.kt:79:5</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ServerKeyExchangeType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  76 </span>
<span class="lineno">  77 </span>internal fun ByteReadPacket.readCurveParams(): NamedCurve {
<span class="lineno">  78 </span>    val type = readByte().toInt() and 0xff
<span class="lineno">  79 </span>    <span class="error">when (ServerKeyExchangeType.byCode(type)) {</span>
<span class="lineno">  80 </span><span class="error">        ServerKeyExchangeType.NamedCurve -&gt; {</span>
<span class="lineno">  81 </span><span class="error">            val curveId = readShort()</span>
<span class="lineno">  82 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/ktor-network-tls/jvm/src/io/ktor/network/tls/Render.kt:112:77</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `ECPublicKey`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 109 </span>internal fun serverFinished(handshakeHash: ByteArray, secretKey: SecretKey, length: Int = 12): ByteArray =
<span class="lineno"> 110 </span>    PRF(secretKey, SERVER_FINISHED_LABEL, handshakeHash, length)
<span class="lineno"> 111 </span>
<span class="lineno"> 112 </span>internal fun BytePacketBuilder.writePublicKeyUncompressed(key: PublicKey) = <span class="error">when (key) {</span>
<span class="lineno"> 113 </span><span class="error">    is ECPublicKey -&gt; {</span>
<span class="lineno"> 114 </span><span class="error">        val fieldSize = key.params.curve.field.fieldSize</span>
<span class="lineno"> 115 </span><span class="error">        writeECPoint(key.w, fieldSize)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/ktor-network-tls/jvm/src/io/ktor/network/tls/TLSClientHandshake.kt:62:17</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `TLSRecordType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  59 </span>                val record = if (useCipher) cipher.decrypt(rawRecord) else rawRecord
<span class="lineno">  60 </span>                val packet = record.packet
<span class="lineno">  61 </span>
<span class="lineno">  62 </span>                <span class="error">when (record.type) {</span>
<span class="lineno">  63 </span><span class="error">                    TLSRecordType.Alert -&gt; {</span>
<span class="lineno">  64 </span><span class="error">                        val level = TLSAlertLevel.byCode(packet.readByte().toInt())</span>
<span class="lineno">  65 </span><span class="error">                        val code = TLSAlertType.byCode(packet.readByte().toInt())</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/ktor-network-tls/jvm/src/io/ktor/network/tls/TLSClientHandshake.kt:255:21</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SecretExchangeType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 252 </span>                    check(packet.isEmpty)
<span class="lineno"> 253 </span>                }
<span class="lineno"> 254 </span>                TLSHandshakeType.ServerKeyExchange -&gt; {
<span class="lineno"> 255 </span>                    <span class="error">when (exchangeType) {</span>
<span class="lineno"> 256 </span><span class="error">                        ECDHE -&gt; {</span>
<span class="lineno"> 257 </span><span class="error">                            val curve = packet.readCurveParams()</span>
<span class="lineno"> 258 </span><span class="error">                            val point = packet.readECPoint(curve.fieldSize)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/ktor-network-tls/jvm/src/io/ktor/network/tls/TLSClientHandshake.kt:334:9</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SecretExchangeType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 331 </span>    }
<span class="lineno"> 332 </span>
<span class="lineno"> 333 </span>    private fun generatePreSecret(encryptionInfo: EncryptionInfo?): ByteArray =
<span class="lineno"> 334 </span>        <span class="error">when (serverHello.cipherSuite.exchangeType) {</span>
<span class="lineno"> 335 </span><span class="error">            RSA -&gt; ByteArray(48).also {</span>
<span class="lineno"> 336 </span><span class="error">                config.random.nextBytes(it)</span>
<span class="lineno"> 337 </span><span class="error">                it[0] = 0x03</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/ktor-network-tls/jvm/src/io/ktor/network/tls/TLSClientHandshake.kt:354:22</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SecretExchangeType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 351 </span>        preSecret: ByteArray,
<span class="lineno"> 352 </span>        encryptionInfo: EncryptionInfo?
<span class="lineno"> 353 </span>    ) {
<span class="lineno"> 354 </span>        val packet = <span class="error">when (exchangeType) {</span>
<span class="lineno"> 355 </span><span class="error">            RSA -&gt; buildPacket {</span>
<span class="lineno"> 356 </span><span class="error">                writeEncryptedPreMasterSecret(preSecret, serverCertificate.publicKey, config.random)</span>
<span class="lineno"> 357 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/ktor-network-tls/jvm/src/io/ktor/network/tls/cipher/Cipher.kt:18:13</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `CipherType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  15 </span>
<span class="lineno">  16 </span>    companion object {
<span class="lineno">  17 </span>        fun fromSuite(suite: CipherSuite, keyMaterial: ByteArray): TLSCipher =
<span class="lineno">  18 </span>            <span class="error">when (suite.cipherType) {</span>
<span class="lineno">  19 </span><span class="error">                CipherType.GCM -&gt; GCMCipher(suite, keyMaterial)</span>
<span class="lineno">  20 </span><span class="error">                CipherType.CBC -&gt; CBCCipher(suite, keyMaterial)</span>
<span class="lineno">  21 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/netty/NettyPlatformBenchmark.kt:55:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `HttpRequest`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  52 </span>
<span class="lineno">  53 </span>    class BenchmarkServerHandler internal constructor(service: ScheduledExecutorService) : ChannelInboundHandlerAdapter() {
<span class="lineno">  54 </span>        override fun channelRead(ctx: ChannelHandlerContext, msg: Any) {
<span class="lineno">  55 </span>            <span class="error">when (msg) {</span>
<span class="lineno">  56 </span><span class="error">                is HttpRequest -&gt; try {</span>
<span class="lineno">  57 </span><span class="error">                    process(ctx, msg)</span>
<span class="lineno">  58 </span><span class="error">                } finally {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/Compression.kt:94:50</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.ProtocolUpgrade`, `OutgoingContent.ByteArrayContent`, `OutgoingContent.NoContent`, `OutgoingContent.WriteChannelContent`, `OutgoingContent.ReadChannelContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  91 </span>        ) {
<span class="lineno">  92 </span>            val encoderOptions = encoders.firstOrNull { encoder -&gt; encoder.conditions.all { it(call, message) } }
<span class="lineno">  93 </span>
<span class="lineno">  94 </span>            val channel: () -&gt; ByteReadChannel = <span class="error">when (message) {</span>
<span class="lineno">  95 </span><span class="error">                is OutgoingContent.ReadChannelContent -&gt; ({ message.readFrom() })</span>
<span class="lineno">  96 </span><span class="error">                is OutgoingContent.WriteChannelContent -&gt; {</span>
<span class="lineno">  97 </span><span class="error">                    if (encoderOptions != null) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/ConditionalHeaders.kt:119:5</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `VersionCheckResult`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 116 </span>    if (putHeader) {
<span class="lineno"> 117 </span>        response.header(HttpHeaders.ETag, etag)
<span class="lineno"> 118 </span>    }
<span class="lineno"> 119 </span>    <span class="error">when (result) {</span>
<span class="lineno"> 120 </span><span class="error">        VersionCheckResult.NOT_MODIFIED,</span>
<span class="lineno"> 121 </span><span class="error">        VersionCheckResult.PRECONDITION_FAILED -&gt; respond(result.statusCode)</span>
<span class="lineno"> 122 </span><span class="error">        VersionCheckResult.OK -&gt; block()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/DoubleReceive.kt:92:17</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `CachedTransformationResult.Success&lt;*&gt;`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  89 </span>
<span class="lineno">  90 </span>                val transformed = finishedRequest.value
<span class="lineno">  91 </span>
<span class="lineno">  92 </span>                <span class="error">when {</span>
<span class="lineno">  93 </span><span class="error">                    transformed is CachedTransformationResult.Success&lt;*&gt; -&gt; throw RequestAlreadyConsumedException()</span>
<span class="lineno">  94 </span><span class="error">                    !request.type.isInstance(transformed) -&gt; throw CannotTransformContentToTypeException(type)</span>
<span class="lineno">  95 </span><span class="error">                }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/PartialContent.kt:125:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `EntityTagVersion`, `LastModifiedVersion`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 122 </span>        val versions = conditionalHeadersFeature?.versionsFor(content) ?: content.defaultVersions
<span class="lineno"> 123 </span>
<span class="lineno"> 124 </span>        return versions.all { version -&gt;
<span class="lineno"> 125 </span>            <span class="error">when (version) {</span>
<span class="lineno"> 126 </span><span class="error">                is LastModifiedVersion -&gt; checkLastModified(version, ifRange)</span>
<span class="lineno"> 127 </span><span class="error">                is EntityTagVersion -&gt; checkEntityTags(version, ifRange)</span>
<span class="lineno"> 128 </span><span class="error">                else -&gt; true</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/PartialContent.kt:137:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `LastModifiedVersion`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 134 </span>        val actualDate = actual.lastModified.truncateToSeconds()
<span class="lineno"> 135 </span>
<span class="lineno"> 136 </span>        return ifRange.all { condition -&gt;
<span class="lineno"> 137 </span>            <span class="error">when (condition) {</span>
<span class="lineno"> 138 </span><span class="error">                is LastModifiedVersion -&gt; actualDate &lt;= condition.lastModified</span>
<span class="lineno"> 139 </span><span class="error">                else -&gt; true</span>
<span class="lineno"> 140 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/PartialContent.kt:146:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `EntityTagVersion`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 143 </span>
<span class="lineno"> 144 </span>    private fun checkEntityTags(actual: EntityTagVersion, ifRange: List&lt;Version&gt;): Boolean {
<span class="lineno"> 145 </span>        return ifRange.all { condition -&gt;
<span class="lineno"> 146 </span>            <span class="error">when (condition) {</span>
<span class="lineno"> 147 </span><span class="error">                is EntityTagVersion -&gt; actual.etag == condition.etag</span>
<span class="lineno"> 148 </span><span class="error">                else -&gt; true</span>
<span class="lineno"> 149 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/StatusPages.kt:77:22</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `HttpStatusCode`, `OutgoingContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  74 </span>        val call = context.call
<span class="lineno">  75 </span>        if (call.attributes.contains(key)) return
<span class="lineno">  76 </span>
<span class="lineno">  77 </span>        val status = <span class="error">when (message) {</span>
<span class="lineno">  78 </span><span class="error">            is OutgoingContent -&gt; message.status</span>
<span class="lineno">  79 </span><span class="error">            is HttpStatusCode -&gt; message</span>
<span class="lineno">  80 </span><span class="error">            else -&gt; null</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/http/content/DefaultTransform.kt:16:99</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `URIFileContent`, `HttpStatusCode`, `ByteArray`, `String`, `OutgoingContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  13 </span>/**
<span class="lineno">  14 </span> * Default outgoing content transformation
<span class="lineno">  15 </span> */
<span class="lineno">  16 </span>fun PipelineContext&lt;Any, ApplicationCall&gt;.transformDefaultContent(value: Any): OutgoingContent? = <span class="error">when (value) {</span>
<span class="lineno">  17 </span><span class="error">    is OutgoingContent -&gt; value</span>
<span class="lineno">  18 </span><span class="error">    is String -&gt; {</span>
<span class="lineno">  19 </span><span class="error">        val contentType = call.defaultTextContentType(null)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/Routing.kt:109:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Routing`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 106 </span> * Gets an [Application] for this [Route] by scanning the hierarchy to the root
<span class="lineno"> 107 </span> */
<span class="lineno"> 108 </span>val Route.application: Application
<span class="lineno"> 109 </span>    get() = <span class="error">when {</span>
<span class="lineno"> 110 </span><span class="error">        this is Routing -&gt; application</span>
<span class="lineno"> 111 </span><span class="error">        else -&gt; parent?.application</span>
<span class="lineno"> 112 </span><span class="error">            ?: throw UnsupportedOperationException(&quot;Cannot retrieve application from unattached routing entry&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RoutingBuilder.kt:226:24</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `RoutingPathSegmentKind`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 223 </span>    val parts = RoutingPath.parse(path).parts
<span class="lineno"> 224 </span>    var current: Route = this
<span class="lineno"> 225 </span>    for ((value, kind) in parts) {
<span class="lineno"> 226 </span>        val selector = <span class="error">when (kind) {</span>
<span class="lineno"> 227 </span><span class="error">            RoutingPathSegmentKind.Parameter -&gt; PathSegmentSelectorBuilder.parseParameter(value)</span>
<span class="lineno"> 228 </span><span class="error">            RoutingPathSegmentKind.Constant -&gt; PathSegmentSelectorBuilder.parseConstant(value)</span>
<span class="lineno"> 229 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RoutingResolve.kt:133:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `RoutingResolveResult.Success`, `RoutingResolveResult.Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 130 </span>            }
<span class="lineno"> 131 </span>
<span class="lineno"> 132 </span>            val subtreeResult = resolve(child, segmentIndex + selectorResult.segmentIncrement)
<span class="lineno"> 133 </span>            <span class="error">when (subtreeResult) {</span>
<span class="lineno"> 134 </span><span class="error">                is RoutingResolveResult.Failure -&gt; {</span>
<span class="lineno"> 135 </span><span class="error">                    // subtree didn't match, skip to next child, remember first failed entry</span>
<span class="lineno"> 136 </span><span class="error">                    if (failEntry == null) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/sessions/SessionSerializerReflection.kt:95:41</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `MutableList&lt;*&gt;`, `KMutableProperty1&lt;T, *&gt;`, `List&lt;*&gt;`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  92 </span>        val originalValue = p.get(instance)
<span class="lineno">  93 </span>
<span class="lineno">  94 </span>        when {
<span class="lineno">  95 </span>            isListType(p.returnType) -&gt; <span class="error">when {</span>
<span class="lineno">  96 </span><span class="error">                value !is List&lt;*&gt; -&gt; assignValue(instance, p, coerceType(p.returnType, value))</span>
<span class="lineno">  97 </span><span class="error">                p is KMutableProperty1&lt;T, *&gt; -&gt; p.setter.call(instance, coerceType(p.returnType, value))</span>
<span class="lineno">  98 </span><span class="error">                originalValue is MutableList&lt;*&gt; -&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/sessions/SessionSerializerReflection.kt:106:40</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `MutableSet&lt;*&gt;`, `KMutableProperty1&lt;T, *&gt;`, `Set&lt;*&gt;`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 103 </span>                }
<span class="lineno"> 104 </span>                else -&gt; throw IllegalStateException(&quot;Couldn't inject property ${p.name} from value $value&quot;)
<span class="lineno"> 105 </span>            }
<span class="lineno"> 106 </span>            isSetType(p.returnType) -&gt; <span class="error">when {</span>
<span class="lineno"> 107 </span><span class="error">                value !is Set&lt;*&gt; -&gt; assignValue(instance, p, coerceType(p.returnType, value))</span>
<span class="lineno"> 108 </span><span class="error">                p is KMutableProperty1&lt;T, *&gt; -&gt; p.setter.call(instance, coerceType(p.returnType, value))</span>
<span class="lineno"> 109 </span><span class="error">                originalValue is MutableSet&lt;*&gt; -&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/sessions/SessionSerializerReflection.kt:117:40</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `MutableMap&lt;*, *&gt;`, `KMutableProperty1&lt;T, *&gt;`, `Map&lt;*, *&gt;`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 114 </span>                }
<span class="lineno"> 115 </span>                else -&gt; throw IllegalStateException(&quot;Couldn't inject property ${p.name} from value $value&quot;)
<span class="lineno"> 116 </span>            }
<span class="lineno"> 117 </span>            isMapType(p.returnType) -&gt; <span class="error">when {</span>
<span class="lineno"> 118 </span><span class="error">                value !is Map&lt;*, *&gt; -&gt; assignValue(instance, p, coerceType(p.returnType, value))</span>
<span class="lineno"> 119 </span><span class="error">                p is KMutableProperty1&lt;T, *&gt; -&gt; p.setter.call(instance, coerceType(p.returnType, value))</span>
<span class="lineno"> 120 </span><span class="error">                originalValue is MutableMap&lt;*, *&gt; -&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/sessions/SessionSerializerReflection.kt:174:32</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Map&lt;*, *&gt;`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 171 </span>                        ?: throw IllegalArgumentException(&quot;Couldn't coerce type ${value::class.java} to $type&quot;)
<span class="lineno"> 172 </span>                }
<span class="lineno"> 173 </span>            }
<span class="lineno"> 174 </span>            isMapType(type) -&gt; <span class="error">when (value) {</span>
<span class="lineno"> 175 </span><span class="error">                !is Map&lt;*, *&gt; -&gt; throw IllegalArgumentException(&quot;Couldn't coerce type ${value::class.java} to $type&quot;)</span>
<span class="lineno"> 176 </span><span class="error">                else -&gt; {</span>
<span class="lineno"> 177 </span><span class="error">                    val keyType = type.arguments[0].type</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/sessions/SessionSerializerReflection.kt:236:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Class&lt;*&gt;`, `ParameterizedType`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 233 </span>    private fun KType.toJavaClass() = javaType.toJavaClass()
<span class="lineno"> 234 </span>
<span class="lineno"> 235 </span>    private fun Type.toJavaClass(): Class&lt;*&gt; =
<span class="lineno"> 236 </span>        <span class="error">when (this) {</span>
<span class="lineno"> 237 </span><span class="error">            is ParameterizedType -&gt; this.rawType.toJavaClass()</span>
<span class="lineno"> 238 </span><span class="error">            is Class&lt;*&gt; -&gt; this</span>
<span class="lineno"> 239 </span><span class="error">            else -&gt; throw IllegalArgumentException(&quot;Bad type $this&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/sessions/SessionSerializerReflection.kt:353:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Class&lt;*&gt;`, `ParameterizedType`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 350 </span>    }
<span class="lineno"> 351 </span>
<span class="lineno"> 352 </span>    private fun getRawType(type: KType): Class&lt;*&gt;? = type.javaType.let { javaType -&gt;
<span class="lineno"> 353 </span>        <span class="error">when (javaType) {</span>
<span class="lineno"> 354 </span><span class="error">            is ParameterizedType -&gt; javaType.rawType as? Class&lt;*&gt;</span>
<span class="lineno"> 355 </span><span class="error">            is Class&lt;*&gt; -&gt; javaType</span>
<span class="lineno"> 356 </span><span class="error">            else -&gt; null</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/sessions/SessionsBuilder.kt:131:19</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `HeaderIdSessionBuilder&lt;S&gt;`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 128 </span>    builder: HeaderSessionBuilder&lt;S&gt;
<span class="lineno"> 129 </span>) {
<span class="lineno"> 130 </span>    val transport = SessionTransportHeader(name, builder.transformers)
<span class="lineno"> 131 </span>    val tracker = <span class="error">when {</span>
<span class="lineno"> 132 </span><span class="error">        storage != null &amp;&amp; builder is HeaderIdSessionBuilder&lt;S&gt; -&gt; SessionTrackerById(</span>
<span class="lineno"> 133 </span><span class="error">            sessionType,</span>
<span class="lineno"> 134 </span><span class="error">            builder.serializer,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/util/DispatcherWithShutdown.kt:40:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ShutdownPhase`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  37 </span>    }
<span class="lineno">  38 </span>
<span class="lineno">  39 </span>    override fun isDispatchNeeded(context: CoroutineContext): Boolean {
<span class="lineno">  40 </span>        return <span class="error">when (shutdownPhase) {</span>
<span class="lineno">  41 </span><span class="error">            ShutdownPhase.None -&gt; delegate?.isDispatchNeeded(context) ?: true</span>
<span class="lineno">  42 </span><span class="error">            else -&gt; true</span>
<span class="lineno">  43 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/util/DispatcherWithShutdown.kt:47:9</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ShutdownPhase`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  44 </span>    }
<span class="lineno">  45 </span>
<span class="lineno">  46 </span>    override fun dispatch(context: CoroutineContext, block: Runnable) {
<span class="lineno">  47 </span>        <span class="error">when (shutdownPhase) {</span>
<span class="lineno">  48 </span><span class="error">            ShutdownPhase.None -&gt; {</span>
<span class="lineno">  49 </span><span class="error">                try {</span>
<span class="lineno">  50 </span><span class="error">                    delegate?.dispatch(context, block) ?: return dispatch(context, block)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/util/ReflectionUtils.kt:44:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `KVariance?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  41 </span>
<span class="lineno">  42 </span>private class BoundTypeAdapter(val type: KTypeProjection) : WildcardType {
<span class="lineno">  43 </span>    override fun getLowerBounds(): Array&lt;Type&gt; {
<span class="lineno">  44 </span>        return <span class="error">when (type.variance) {</span>
<span class="lineno">  45 </span><span class="error">            null, KVariance.OUT -&gt; arrayOf(Any::class.java)</span>
<span class="lineno">  46 </span><span class="error">            else -&gt; arrayOf(type.type!!.toJavaType())</span>
<span class="lineno">  47 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/util/ReflectionUtils.kt:51:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `KVariance?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  48 </span>    }
<span class="lineno">  49 </span>
<span class="lineno">  50 </span>    override fun getUpperBounds(): Array&lt;Type&gt; {
<span class="lineno">  51 </span>        return <span class="error">when (type.variance) {</span>
<span class="lineno">  52 </span><span class="error">            null, KVariance.IN -&gt; arrayOf(Any::class.java)</span>
<span class="lineno">  53 </span><span class="error">            else -&gt; arrayOf(type.type!!.toJavaType())</span>
<span class="lineno">  54 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-host-common/jvm/src/io/ktor/server/engine/BaseApplicationResponse.kt:51:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.ProtocolUpgrade`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  48 </span>
<span class="lineno">  49 </span>        content.status?.let { status(it) } ?: status() ?: status(HttpStatusCode.OK)
<span class="lineno">  50 </span>        content.headers.forEach { name, values -&gt;
<span class="lineno">  51 </span>            <span class="error">when (name) {</span>
<span class="lineno">  52 </span><span class="error">                HttpHeaders.TransferEncoding -&gt; transferEncodingSet = true</span>
<span class="lineno">  53 </span><span class="error">                HttpHeaders.Upgrade -&gt; {</span>
<span class="lineno">  54 </span><span class="error">                    if (content !is OutgoingContent.ProtocolUpgrade)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-host-common/jvm/src/io/ktor/server/engine/BaseApplicationResponse.kt:72:17</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.NoContent`, `OutgoingContent.ProtocolUpgrade`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  69 </span>                headers.append(HttpHeaders.ContentLength, contentLength.toStringFast(), safeOnly = false)
<span class="lineno">  70 </span>            }
<span class="lineno">  71 </span>            !transferEncodingSet -&gt; {
<span class="lineno">  72 </span>                <span class="error">when (content) {</span>
<span class="lineno">  73 </span><span class="error">                    is OutgoingContent.ProtocolUpgrade -&gt; {</span>
<span class="lineno">  74 </span><span class="error">                    }</span>
<span class="lineno">  75 </span><span class="error">                    is OutgoingContent.NoContent -&gt; headers.append(HttpHeaders.ContentLength, &quot;0&quot;, safeOnly = false)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-host-common/jvm/src/io/ktor/server/engine/BaseApplicationResponse.kt:98:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.NoContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.WriteChannelContent`, `OutgoingContent.ByteArrayContent`, `OutgoingContent.ProtocolUpgrade`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  95 </span>     * Process response outgoing [content]
<span class="lineno">  96 </span>     */
<span class="lineno">  97 </span>    protected open suspend fun respondOutgoingContent(content: OutgoingContent) {
<span class="lineno">  98 </span>        <span class="error">when (content) {</span>
<span class="lineno">  99 </span><span class="error">            is OutgoingContent.ProtocolUpgrade -&gt; {</span>
<span class="lineno"> 100 </span><span class="error">                commitHeaders(content)</span>
<span class="lineno"> 101 </span><span class="error">                return respondUpgrade(content)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-host-common/jvm/src/io/ktor/server/engine/DefaultEnginePipeline.kt:99:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `UnsupportedMediaTypeException`, `NotFoundException`, `BadRequestException`, `ChannelIOException`, `ClosedChannelException`, `CancellationException`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  96 </span>            &quot;(request error: $cause)&quot;
<span class="lineno">  97 </span>        }
<span class="lineno">  98 </span>
<span class="lineno">  99 </span>        <span class="error">when (cause) {</span>
<span class="lineno"> 100 </span><span class="error">            is CancellationException -&gt; log.info(&quot;$status: $logString, cancelled&quot;)</span>
<span class="lineno"> 101 </span><span class="error">            is ClosedChannelException -&gt; log.info(&quot;$status: $logString, channel closed&quot;)</span>
<span class="lineno"> 102 </span><span class="error">            is ChannelIOException -&gt; log.info(&quot;$status: $logString, channel failed&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationCallHandler.kt:23:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `ApplicationCall`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  20 </span>        DefaultUncaughtExceptionHandler(logger)
<span class="lineno">  21 </span>
<span class="lineno">  22 </span>    override fun channelRead(ctx: ChannelHandlerContext, msg: Any) {
<span class="lineno">  23 </span>        <span class="error">when (msg) {</span>
<span class="lineno">  24 </span><span class="error">            is ApplicationCall -&gt; handleRequest(ctx, msg)</span>
<span class="lineno">  25 </span><span class="error">            else -&gt; ctx.fireChannelRead(msg)</span>
<span class="lineno">  26 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationResponse.kt:52:31</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `LastHttpContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  49 </span>
<span class="lineno">  50 </span>        if (!responseMessageSent) {
<span class="lineno">  51 </span>            val message = responseMessage(chunked, bytes)
<span class="lineno">  52 </span>            responseChannel = <span class="error">when (message) {</span>
<span class="lineno">  53 </span><span class="error">                is LastHttpContent -&gt; ByteReadChannel.Empty</span>
<span class="lineno">  54 </span><span class="error">                else -&gt; ByteReadChannel(bytes)</span>
<span class="lineno">  55 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyMultipartDataSupport.kt:106:52</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Attribute`, `FileUpload`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 103 </span>        }
<span class="lineno"> 104 </span>    }
<span class="lineno"> 105 </span>
<span class="lineno"> 106 </span>    private fun convert(part: InterfaceHttpData) = <span class="error">when (part) {</span>
<span class="lineno"> 107 </span><span class="error">        is FileUpload -&gt; PartData.FileItem(</span>
<span class="lineno"> 108 </span><span class="error">            provider = {</span>
<span class="lineno"> 109 </span><span class="error">                when {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/cio/RequestBodyHandler.kt:140:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `ReferenceCounted`, `ByteChannel`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 137 </span>                null
<span class="lineno"> 138 </span>            } ?: break
<span class="lineno"> 139 </span>
<span class="lineno"> 140 </span>            <span class="error">when (e) {</span>
<span class="lineno"> 141 </span><span class="error">                is ByteChannel -&gt; e.close()</span>
<span class="lineno"> 142 </span><span class="error">                is ReferenceCounted -&gt; e.release()</span>
<span class="lineno"> 143 </span><span class="error">                else -&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/http1/NettyHttp1Handler.kt:73:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `HttpContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  70 </span>    }
<span class="lineno">  71 </span>
<span class="lineno">  72 </span>    private fun content(context: ChannelHandlerContext, message: HttpRequest): ByteReadChannel {
<span class="lineno">  73 </span>        return <span class="error">when (message) {</span>
<span class="lineno">  74 </span><span class="error">            is HttpContent -&gt; {</span>
<span class="lineno">  75 </span><span class="error">                val bodyHandler = context.pipeline().get(RequestBodyHandler::class.java)</span>
<span class="lineno">  76 </span><span class="error">                bodyHandler.newChannel().also { bodyHandler.channelRead(context, message) }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/http2/NettyHttp2Handler.kt:35:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Http2ResetFrame`, `Http2DataFrame`, `Http2HeadersFrame`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  32 </span>        get() = handlerJob
<span class="lineno">  33 </span>
<span class="lineno">  34 </span>    override fun channelRead(context: ChannelHandlerContext, message: Any?) {
<span class="lineno">  35 </span>        <span class="error">when (message) {</span>
<span class="lineno">  36 </span><span class="error">            is Http2HeadersFrame -&gt; {</span>
<span class="lineno">  37 </span><span class="error">                startHttp2(context, message.headers())</span>
<span class="lineno">  38 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/JAASBridge.kt:16:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `ServletApplicationRequest`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  13 </span> */
<span class="lineno">  14 </span>@KtorExperimentalAPI
<span class="lineno">  15 </span>val ApplicationRequest.javaSecurityPrincipal: Principal?
<span class="lineno">  16 </span>    get() = <span class="error">when (this) {</span>
<span class="lineno">  17 </span><span class="error">        is ServletApplicationRequest -&gt; servletRequest.userPrincipal</span>
<span class="lineno">  18 </span><span class="error">        else -&gt; null</span>
<span class="lineno">  19 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/EngineTestSuite.kt:705:21</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `PartData.FileItem`, `PartData.FormItem`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 702 </span>                val response = StringBuilder()
<span class="lineno"> 703 </span>
<span class="lineno"> 704 </span>                call.receiveMultipart().readAllParts().sortedBy { it.name }.forEach { part -&gt;
<span class="lineno"> 705 </span>                    <span class="error">when (part) {</span>
<span class="lineno"> 706 </span><span class="error">                        is PartData.FormItem -&gt; response.append(&quot;${part.name}=${part.value}\n&quot;)</span>
<span class="lineno"> 707 </span><span class="error">                        is PartData.FileItem -&gt; response.append(&quot;file:${part.name},${part.originalFileName},${part.provider().readText()}\n&quot;)</span>
<span class="lineno"> 708 </span><span class="error">                    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/EngineTestSuite.kt:755:21</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `PartData.FileItem`, `PartData.FormItem`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 752 </span>                val response = StringBuilder()
<span class="lineno"> 753 </span>
<span class="lineno"> 754 </span>                call.receiveMultipart().forEachPart { part -&gt;
<span class="lineno"> 755 </span>                    <span class="error">when (part) {</span>
<span class="lineno"> 756 </span><span class="error">                        is PartData.FormItem -&gt; response.append(&quot;${part.name}=${part.value}\n&quot;)</span>
<span class="lineno"> 757 </span><span class="error">                        is PartData.FileItem -&gt; response.append(&quot;file:${part.name},${part.originalFileName},${part.streamProvider().bufferedReader().lineSequence().count()}\n&quot;)</span>
<span class="lineno"> 758 </span><span class="error">                    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/HighLoadHttpGenerator.kt:190:17</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ParseState`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 187 </span>
<span class="lineno"> 188 </span>        private fun parseLoop(bb: ByteBuffer) {
<span class="lineno"> 189 </span>            while (bb.hasRemaining()) {
<span class="lineno"> 190 </span>                <span class="error">when (parseState) {</span>
<span class="lineno"> 191 </span><span class="error">                    ParseState.EOL -&gt; findEol(bb)</span>
<span class="lineno"> 192 </span><span class="error">                    ParseState.HTTP -&gt; findHttp(bb)</span>
<span class="lineno"> 193 </span><span class="error">                    ParseState.SPACE -&gt; skipSpaces(bb)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/TestApplicationRequest.kt:120:24</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `PartData.FormItem`, `PartData.BinaryItem`, `PartData.FileItem`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 117 </span>                    append(&quot;$key: ${values.joinToString(&quot;;&quot;)}\r\n&quot;)
<span class="lineno"> 118 </span>                }
<span class="lineno"> 119 </span>                append(&quot;\r\n&quot;)
<span class="lineno"> 120 </span>                append(<span class="error">when (it) {</span>
<span class="lineno"> 121 </span><span class="error">                    is PartData.FileItem -&gt; {</span>
<span class="lineno"> 122 </span><span class="error">                        it.provider().asStream().copyTo(channel.toOutputStream())</span>
<span class="lineno"> 123 </span><span class="error">                        &quot;&quot;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/client/TestHttpClientEngine.kt:82:72</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OutgoingContent.ProtocolUpgrade`, `OutgoingContent.WriteChannelContent`, `OutgoingContent.ReadChannelContent`, `OutgoingContent.ByteArrayContent`, `OutgoingContent.NoContent`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  79 </span>        }
<span class="lineno">  80 </span>    }
<span class="lineno">  81 </span>
<span class="lineno">  82 </span>    private fun OutgoingContent.toByteReadChannel(): ByteReadChannel = <span class="error">when (this) {</span>
<span class="lineno">  83 </span><span class="error">        is OutgoingContent.NoContent -&gt; ByteReadChannel.Empty</span>
<span class="lineno">  84 </span><span class="error">        is OutgoingContent.ByteArrayContent -&gt; ByteReadChannel(bytes())</span>
<span class="lineno">  85 </span><span class="error">        is OutgoingContent.ReadChannelContent -&gt; readFrom()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/common/src/io/ktor/util/pipeline/Pipeline.kt:321:17</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `PipelinePhaseRelation.After`, `PipelinePhaseRelation.Before`, `PipelinePhaseRelation.Last`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 318 </span>                    else -&gt; (fromPhaseOrContent as PhaseContent&lt;*, *&gt;).relation
<span class="lineno"> 319 </span>                }
<span class="lineno"> 320 </span>
<span class="lineno"> 321 </span>                <span class="error">when (fromPhaseRelation) {</span>
<span class="lineno"> 322 </span><span class="error">                    is PipelinePhaseRelation.Last -&gt; addPhase(fromPhase)</span>
<span class="lineno"> 323 </span><span class="error">                    is PipelinePhaseRelation.Before -&gt; insertPhaseBefore(</span>
<span class="lineno"> 324 </span><span class="error">                        fromPhaseRelation.relativeTo,</span>
</code></pre>
      </li>
    </ul>
  </details>
  <details id="UseCompositionInsteadOfInheritance" open="open">
    <summary class="rule-container"><span class="rule">UseCompositionInsteadOfInheritance: 336 </span><span class="description">This rule reports a file using inheritance.</span></summary>
    <ul>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-android/jvm/src/io/ktor/client/engine/android/AndroidClientEngine.kt:23:1</span><span class="message">The class `AndroidClientEngine` is using inheritance, consider using composition instead.

Does `AndroidClientEngine` want to expose the complete interface (`close`) of `HttpClientEngineBase` such that `AndroidClientEngine` can be used where `HttpClientEngineBase` is expected? Indicates __inheritance__.

Does `AndroidClientEngine` want only some/part of the behavior exposed by `HttpClientEngineBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  20 </span>import javax.net.ssl.*
<span class="lineno">  21 </span>import kotlin.coroutines.*
<span class="lineno">  22 </span>
<span class="lineno">  23 </span><span class="error">/**</span>
<span class="lineno">  24 </span><span class="error"> * Android client engine</span>
<span class="lineno">  25 </span><span class="error"> */</span>
<span class="lineno">  26 </span><span class="error">class AndroidClientEngine(override val config: AndroidEngineConfig) : HttpClientEngineBase(&quot;ktor-android&quot;) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-android/jvm/src/io/ktor/client/engine/android/AndroidEngineConfig.kt:12:1</span><span class="message">The class `AndroidEngineConfig` is using inheritance, consider using composition instead.

Does `AndroidEngineConfig` want to expose the complete interface (`empty public interface`) of `HttpClientEngineConfig` such that `AndroidEngineConfig` can be used where `HttpClientEngineConfig` is expected? Indicates __inheritance__.

Does `AndroidEngineConfig` want only some/part of the behavior exposed by `HttpClientEngineConfig`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import javax.net.ssl.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">/**</span>
<span class="lineno">  13 </span><span class="error"> * Configuration for [Android] client engine.</span>
<span class="lineno">  14 </span><span class="error"> */</span>
<span class="lineno">  15 </span><span class="error">class AndroidEngineConfig : HttpClientEngineConfig() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-apache/jvm/src/io/ktor/client/engine/apache/ApacheEngine.kt:20:1</span><span class="message">The class `ApacheEngine` is using inheritance, consider using composition instead.

Does `ApacheEngine` want to expose the complete interface (`close`) of `HttpClientEngineBase` such that `ApacheEngine` can be used where `HttpClientEngineBase` is expected? Indicates __inheritance__.

Does `ApacheEngine` want only some/part of the behavior exposed by `HttpClientEngineBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  17 </span>private const val MAX_CONNECTIONS_COUNT = 1000
<span class="lineno">  18 </span>private const val IO_THREAD_COUNT_DEFAULT = 4
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">internal class ApacheEngine(override val config: ApacheEngineConfig) : HttpClientEngineBase(&quot;ktor-apache&quot;) {</span>
<span class="lineno">  21 </span><span class="error"></span>
<span class="lineno">  22 </span><span class="error">    override val dispatcher by lazy {</span>
<span class="lineno">  23 </span><span class="error">        Dispatchers.clientDispatcher(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-apache/jvm/src/io/ktor/client/engine/apache/ApacheEngineConfig.kt:12:1</span><span class="message">The class `ApacheEngineConfig` is using inheritance, consider using composition instead.

Does `ApacheEngineConfig` want to expose the complete interface (`empty public interface`) of `HttpClientEngineConfig` such that `ApacheEngineConfig` can be used where `HttpClientEngineConfig` is expected? Indicates __inheritance__.

Does `ApacheEngineConfig` want only some/part of the behavior exposed by `HttpClientEngineConfig`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import org.apache.http.impl.nio.client.*
<span class="lineno">  10 </span>import javax.net.ssl.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">/**</span>
<span class="lineno">  13 </span><span class="error"> * Configuration for [Apache] implementation of [HttpClientEngineFactory].</span>
<span class="lineno">  14 </span><span class="error"> */</span>
<span class="lineno">  15 </span><span class="error">class ApacheEngineConfig : HttpClientEngineConfig() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-cio/jvm/src/io/ktor/client/engine/cio/CIOEngine.kt:21:1</span><span class="message">The class `CIOEngine` is using inheritance, consider using composition instead.

Does `CIOEngine` want to expose the complete interface (`close`) of `HttpClientEngineBase` such that `CIOEngine` can be used where `HttpClientEngineBase` is expected? Indicates __inheritance__.

Does `CIOEngine` want only some/part of the behavior exposed by `HttpClientEngineBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  18 </span>import java.util.concurrent.*
<span class="lineno">  19 </span>import kotlin.coroutines.*
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">internal class CIOEngine(override val config: CIOEngineConfig) : HttpClientEngineBase(&quot;ktor-cio&quot;) {</span>
<span class="lineno">  22 </span><span class="error"></span>
<span class="lineno">  23 </span><span class="error">    override val dispatcher by lazy { Dispatchers.clientDispatcher(config.threadsCount, &quot;ktor-cio-dispatcher&quot;) }</span>
<span class="lineno">  24 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-cio/jvm/src/io/ktor/client/engine/cio/CIOEngineConfig.kt:11:1</span><span class="message">The class `CIOEngineConfig` is using inheritance, consider using composition instead.

Does `CIOEngineConfig` want to expose the complete interface (`empty public interface`) of `HttpClientEngineConfig` such that `CIOEngineConfig` can be used where `HttpClientEngineConfig` is expected? Indicates __inheritance__.

Does `CIOEngineConfig` want only some/part of the behavior exposed by `HttpClientEngineConfig`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.client.features.*
<span class="lineno">   9 </span>import io.ktor.network.tls.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * Configuration for [CIO] client engine.</span>
<span class="lineno">  13 </span><span class="error"> */</span>
<span class="lineno">  14 </span><span class="error">class CIOEngineConfig : HttpClientEngineConfig() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/call/SavedCall.kt:18:1</span><span class="message">The class `SavedHttpCall` is using inheritance, consider using composition instead.

Does `SavedHttpCall` want to expose the complete interface (`toString, receive`) of `HttpClientCall` such that `SavedHttpCall` can be used where `HttpClientCall` is expected? Indicates __inheritance__.

Does `SavedHttpCall` want only some/part of the behavior exposed by `HttpClientCall`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>import kotlin.coroutines.*
<span class="lineno">  16 </span>
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">internal class SavedHttpCall(client: HttpClient) : HttpClientCall(client)</span>
<span class="lineno">  19 </span>
<span class="lineno">  20 </span>internal class SavedHttpRequest(
<span class="lineno">  21 </span>    override val call: SavedHttpCall, origin: HttpRequest
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/call/SavedCall.kt:24:1</span><span class="message">The class `SavedHttpResponse` is using inheritance, consider using composition instead.

Does `SavedHttpResponse` want to expose the complete interface (`toString`) of `HttpResponse` such that `SavedHttpResponse` can be used where `HttpResponse` is expected? Indicates __inheritance__.

Does `SavedHttpResponse` want only some/part of the behavior exposed by `HttpResponse`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  21 </span>    override val call: SavedHttpCall, origin: HttpRequest
<span class="lineno">  22 </span>) : HttpRequest by origin
<span class="lineno">  23 </span>
<span class="lineno">  24 </span><span class="error">internal class SavedHttpResponse(</span>
<span class="lineno">  25 </span><span class="error">    override val call: SavedHttpCall, body: ByteArray, origin: HttpResponse</span>
<span class="lineno">  26 </span><span class="error">) : HttpResponse() {</span>
<span class="lineno">  27 </span><span class="error">    override val status: HttpStatusCode = origin.status</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/DefaultResponseValidation.kt:51:1</span><span class="message">The class `RedirectResponseException` is using inheritance, consider using composition instead.

Does `RedirectResponseException` want to expose the complete interface (`empty public interface`) of `ResponseException` such that `RedirectResponseException` can be used where `ResponseException` is expected? Indicates __inheritance__.

Does `RedirectResponseException` want only some/part of the behavior exposed by `ResponseException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  48 </span>    @Transient val response: HttpResponse
<span class="lineno">  49 </span>) : IllegalStateException(&quot;Bad response: $response&quot;)
<span class="lineno">  50 </span>
<span class="lineno">  51 </span><span class="error">/**</span>
<span class="lineno">  52 </span><span class="error"> * Unhandled redirect exception.</span>
<span class="lineno">  53 </span><span class="error"> */</span>
<span class="lineno">  54 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/DefaultResponseValidation.kt:59:1</span><span class="message">The class `ServerResponseException` is using inheritance, consider using composition instead.

Does `ServerResponseException` want to expose the complete interface (`empty public interface`) of `ResponseException` such that `ServerResponseException` can be used where `ResponseException` is expected? Indicates __inheritance__.

Does `ServerResponseException` want only some/part of the behavior exposed by `ResponseException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  56 </span>    override val message: String? = &quot;Unhandled redirect: ${response.call.request.url}. Status: ${response.status}&quot;
<span class="lineno">  57 </span>}
<span class="lineno">  58 </span>
<span class="lineno">  59 </span><span class="error">/**</span>
<span class="lineno">  60 </span><span class="error"> * Server error exception.</span>
<span class="lineno">  61 </span><span class="error"> */</span>
<span class="lineno">  62 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/DefaultResponseValidation.kt:69:1</span><span class="message">The class `ClientRequestException` is using inheritance, consider using composition instead.

Does `ClientRequestException` want to expose the complete interface (`empty public interface`) of `ResponseException` such that `ClientRequestException` can be used where `ResponseException` is expected? Indicates __inheritance__.

Does `ClientRequestException` want only some/part of the behavior exposed by `ResponseException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  66 </span>    override val message: String? = &quot;Server error(${response.call.request.url}: ${response.status}.&quot;
<span class="lineno">  67 </span>}
<span class="lineno">  68 </span>
<span class="lineno">  69 </span><span class="error">/**</span>
<span class="lineno">  70 </span><span class="error"> * Bad client request exception.</span>
<span class="lineno">  71 </span><span class="error"> */</span>
<span class="lineno">  72 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/cache/storage/UnlimitedCacheStorage.kt:11:1</span><span class="message">The class `UnlimitedCacheStorage` is using inheritance, consider using composition instead.

Does `UnlimitedCacheStorage` want to expose the complete interface (`findByUrl, find, store`) of `HttpCacheStorage` such that `UnlimitedCacheStorage` can be used where `HttpCacheStorage` is expected? Indicates __inheritance__.

Does `UnlimitedCacheStorage` want only some/part of the behavior exposed by `HttpCacheStorage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.http.*
<span class="lineno">   9 </span>import io.ktor.util.collections.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class UnlimitedCacheStorage : HttpCacheStorage() {</span>
<span class="lineno">  12 </span><span class="error">    private val store = ConcurrentMap&lt;Url, MutableSet&lt;HttpCacheEntry&gt;&gt;()</span>
<span class="lineno">  13 </span><span class="error"></span>
<span class="lineno">  14 </span><span class="error">    override fun store(url: Url, value: HttpCacheEntry) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/observer/DelegatedCall.kt:38:1</span><span class="message">The class `DelegatedCall` is using inheritance, consider using composition instead.

Does `DelegatedCall` want to expose the complete interface (`toString, receive`) of `HttpClientCall` such that `DelegatedCall` can be used where `HttpClientCall` is expected? Indicates __inheritance__.

Does `DelegatedCall` want only some/part of the behavior exposed by `HttpClientCall`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  35 </span>    client, content, this
<span class="lineno">  36 </span>)
<span class="lineno">  37 </span>
<span class="lineno">  38 </span><span class="error">internal class DelegatedCall(</span>
<span class="lineno">  39 </span><span class="error">    client: HttpClient,</span>
<span class="lineno">  40 </span><span class="error">    content: ByteReadChannel,</span>
<span class="lineno">  41 </span><span class="error">    originCall: HttpClientCall</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/observer/DelegatedCall.kt:55:1</span><span class="message">The class `DelegatedResponse` is using inheritance, consider using composition instead.

Does `DelegatedResponse` want to expose the complete interface (`toString`) of `HttpResponse` such that `DelegatedResponse` can be used where `HttpResponse` is expected? Indicates __inheritance__.

Does `DelegatedResponse` want only some/part of the behavior exposed by `HttpResponse`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  52 </span>    origin: HttpRequest
<span class="lineno">  53 </span>) : HttpRequest by origin
<span class="lineno">  54 </span>
<span class="lineno">  55 </span><span class="error">internal class DelegatedResponse(</span>
<span class="lineno">  56 </span><span class="error">    override val call: HttpClientCall,</span>
<span class="lineno">  57 </span><span class="error">    override val content: ByteReadChannel,</span>
<span class="lineno">  58 </span><span class="error">    private val origin: HttpResponse</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/features/websocket/WebSocketContent.kt:15:1</span><span class="message">The class `WebSocketContent` is using inheritance, consider using composition instead.

Does `WebSocketContent` want to expose the complete interface (`verify, pipeTo`) of `ClientUpgradeContent` such that `WebSocketContent` can be used where `ClientUpgradeContent` is expected? Indicates __inheritance__.

Does `WebSocketContent` want only some/part of the behavior exposed by `ClientUpgradeContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>private const val WEBSOCKET_VERSION = &quot;13&quot;
<span class="lineno">  13 </span>private const val NONCE_SIZE = 16
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">internal class WebSocketContent : ClientUpgradeContent() {</span>
<span class="lineno">  16 </span><span class="error">    private val nonce: String = buildString {</span>
<span class="lineno">  17 </span><span class="error">        val nonce = generateNonce(NONCE_SIZE)</span>
<span class="lineno">  18 </span><span class="error">        append(nonce.encodeBase64())</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/request/Content.kt:12:1</span><span class="message">The class `ClientUpgradeContent` is using inheritance, consider using composition instead.

Does `ClientUpgradeContent` want to expose the complete interface (`empty public interface`) of `NoContent` such that `ClientUpgradeContent` can be used where `NoContent` is expected? Indicates __inheritance__.

Does `ClientUpgradeContent` want only some/part of the behavior exposed by `NoContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import io.ktor.util.*
<span class="lineno">  10 </span>import io.ktor.utils.io.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  13 </span><span class="error">@InternalAPI</span>
<span class="lineno">  14 </span><span class="error">abstract class ClientUpgradeContent : OutgoingContent.NoContent() {</span>
<span class="lineno">  15 </span><span class="error">    private val content: ByteChannel by lazy { ByteChannel() }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/request/HttpRequestPipeline.kt:11:1</span><span class="message">The class `HttpRequestPipeline` is using inheritance, consider using composition instead.

Does `HttpRequestPipeline` want to expose the complete interface (`merge, afterIntercepted, intercept, insertPhaseBefore, insertPhaseAfter, addPhase, execute`) of `Pipeline` such that `HttpRequestPipeline` can be used where `Pipeline` is expected? Indicates __inheritance__.

Does `HttpRequestPipeline` want only some/part of the behavior exposed by `Pipeline`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.client.call.*
<span class="lineno">   9 </span>import io.ktor.util.pipeline.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * [HttpClient] Pipeline used for executing [HttpRequest].</span>
<span class="lineno">  13 </span><span class="error"> */</span>
<span class="lineno">  14 </span><span class="error">class HttpRequestPipeline : Pipeline&lt;Any, HttpRequestBuilder&gt;(Before, State, Transform, Render, Send) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/request/HttpRequestPipeline.kt:47:1</span><span class="message">The class `HttpSendPipeline` is using inheritance, consider using composition instead.

Does `HttpSendPipeline` want to expose the complete interface (`merge, afterIntercepted, intercept, insertPhaseBefore, insertPhaseAfter, addPhase, execute`) of `Pipeline` such that `HttpSendPipeline` can be used where `Pipeline` is expected? Indicates __inheritance__.

Does `HttpSendPipeline` want only some/part of the behavior exposed by `Pipeline`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  44 </span>    }
<span class="lineno">  45 </span>}
<span class="lineno">  46 </span>
<span class="lineno">  47 </span><span class="error">/**</span>
<span class="lineno">  48 </span><span class="error"> * [HttpClient] Pipeline used for sending [HttpRequest] to remote server.</span>
<span class="lineno">  49 </span><span class="error"> */</span>
<span class="lineno">  50 </span><span class="error">class HttpSendPipeline : Pipeline&lt;Any, HttpRequestBuilder&gt;(Before, State, Monitoring, Engine, Receive) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/request/forms/FormDataContent.kt:18:1</span><span class="message">The class `FormDataContent` is using inheritance, consider using composition instead.

Does `FormDataContent` want to expose the complete interface (`bytes`) of `ByteArrayContent` such that `FormDataContent` can be used where `ByteArrayContent` is expected? Indicates __inheritance__.

Does `FormDataContent` want only some/part of the behavior exposed by `ByteArrayContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>@ThreadLocal
<span class="lineno">  16 </span>private val RN_BYTES = &quot;\r\n&quot;.toByteArray()
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">/**</span>
<span class="lineno">  19 </span><span class="error"> * [OutgoingContent] with for application/x-www-form-urlencoded formatted request.</span>
<span class="lineno">  20 </span><span class="error"> *</span>
<span class="lineno">  21 </span><span class="error"> * @param formData: data to send.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/request/forms/FormDataContent.kt:35:1</span><span class="message">The class `MultiPartFormDataContent` is using inheritance, consider using composition instead.

Does `MultiPartFormDataContent` want to expose the complete interface (`writeTo`) of `WriteChannelContent` such that `MultiPartFormDataContent` can be used where `WriteChannelContent` is expected? Indicates __inheritance__.

Does `MultiPartFormDataContent` want only some/part of the behavior exposed by `WriteChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  32 </span>}
<span class="lineno">  33 </span>
<span class="lineno">  34 </span>
<span class="lineno">  35 </span><span class="error">/**</span>
<span class="lineno">  36 </span><span class="error"> * [OutgoingContent] for multipart/form-data formatted request.</span>
<span class="lineno">  37 </span><span class="error"> *</span>
<span class="lineno">  38 </span><span class="error"> * @param parts: form part data</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/statement/DefaultHttpResponse.kt:15:1</span><span class="message">The class `DefaultHttpResponse` is using inheritance, consider using composition instead.

Does `DefaultHttpResponse` want to expose the complete interface (`toString`) of `HttpResponse` such that `DefaultHttpResponse` can be used where `HttpResponse` is expected? Indicates __inheritance__.

Does `DefaultHttpResponse` want only some/part of the behavior exposed by `HttpResponse`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>import io.ktor.utils.io.*
<span class="lineno">  13 </span>import kotlin.coroutines.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">@InternalAPI</span>
<span class="lineno">  16 </span><span class="error">class DefaultHttpResponse(</span>
<span class="lineno">  17 </span><span class="error">    override val call: HttpClientCall, responseData: HttpResponseData</span>
<span class="lineno">  18 </span><span class="error">) : HttpResponse() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/statement/HttpResponsePipeline.kt:11:1</span><span class="message">The class `HttpResponsePipeline` is using inheritance, consider using composition instead.

Does `HttpResponsePipeline` want to expose the complete interface (`merge, afterIntercepted, intercept, insertPhaseBefore, insertPhaseAfter, addPhase, execute`) of `Pipeline` such that `HttpResponsePipeline` can be used where `Pipeline` is expected? Indicates __inheritance__.

Does `HttpResponsePipeline` want only some/part of the behavior exposed by `Pipeline`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.client.call.*
<span class="lineno">   9 </span>import io.ktor.util.pipeline.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * [HttpClient] Pipeline used for executing [HttpResponse].</span>
<span class="lineno">  13 </span><span class="error"> */</span>
<span class="lineno">  14 </span><span class="error">class HttpResponsePipeline : Pipeline&lt;HttpResponseContainer, HttpClientCall&gt;(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/common/src/io/ktor/client/statement/HttpResponsePipeline.kt:49:1</span><span class="message">The class `HttpReceivePipeline` is using inheritance, consider using composition instead.

Does `HttpReceivePipeline` want to expose the complete interface (`merge, afterIntercepted, intercept, insertPhaseBefore, insertPhaseAfter, addPhase, execute`) of `Pipeline` such that `HttpReceivePipeline` can be used where `Pipeline` is expected? Indicates __inheritance__.

Does `HttpReceivePipeline` want only some/part of the behavior exposed by `Pipeline`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  46 </span>    }
<span class="lineno">  47 </span>}
<span class="lineno">  48 </span>
<span class="lineno">  49 </span><span class="error">/**</span>
<span class="lineno">  50 </span><span class="error"> * [HttpClient] Pipeline used for receiving [HttpResponse] without any processing.</span>
<span class="lineno">  51 </span><span class="error"> */</span>
<span class="lineno">  52 </span><span class="error">class HttpReceivePipeline : Pipeline&lt;HttpResponse, HttpClientCall&gt;(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/js/src/io/ktor/client/engine/js/JsClientEngine.kt:21:1</span><span class="message">The class `JsClientEngine` is using inheritance, consider using composition instead.

Does `JsClientEngine` want to expose the complete interface (`close`) of `HttpClientEngineBase` such that `JsClientEngine` can be used where `HttpClientEngineBase` is expected? Indicates __inheritance__.

Does `JsClientEngine` want only some/part of the behavior exposed by `HttpClientEngineBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  18 </span>import org.w3c.dom.events.*
<span class="lineno">  19 </span>import kotlin.coroutines.*
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">internal class JsClientEngine(override val config: HttpClientEngineConfig) : HttpClientEngineBase(&quot;ktor-js&quot;) {</span>
<span class="lineno">  22 </span><span class="error"></span>
<span class="lineno">  23 </span><span class="error">    override val dispatcher = Dispatchers.Default</span>
<span class="lineno">  24 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/js/src/io/ktor/network/sockets/TimeoutExceptionsJs.kt:9:1</span><span class="message">The class `ConnectTimeoutException` is using inheritance, consider using composition instead.

Does `ConnectTimeoutException` want to expose the complete interface (`empty public interface`) of `IOException` such that `ConnectTimeoutException` can be used where `IOException` is expected? Indicates __inheritance__.

Does `ConnectTimeoutException` want only some/part of the behavior exposed by `IOException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>
<span class="lineno">   7 </span>import io.ktor.utils.io.errors.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">/**</span>
<span class="lineno">  10 </span><span class="error"> * This exception is thrown in case connect timeout exceeded.</span>
<span class="lineno">  11 </span><span class="error"> */</span>
<span class="lineno">  12 </span><span class="error">actual class ConnectTimeoutException actual constructor(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/js/src/io/ktor/network/sockets/TimeoutExceptionsJs.kt:16:1</span><span class="message">The class `SocketTimeoutException` is using inheritance, consider using composition instead.

Does `SocketTimeoutException` want to expose the complete interface (`empty public interface`) of `IOException` such that `SocketTimeoutException` can be used where `IOException` is expected? Indicates __inheritance__.

Does `SocketTimeoutException` want only some/part of the behavior exposed by `IOException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>    message: String, cause: Throwable?
<span class="lineno">  14 </span>) : IOException(message, cause)
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">/**</span>
<span class="lineno">  17 </span><span class="error"> * This exception is thrown in case socket timeout (read or write) exceeded.</span>
<span class="lineno">  18 </span><span class="error"> */</span>
<span class="lineno">  19 </span><span class="error">actual class SocketTimeoutException actual constructor(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/jvm/src/io/ktor/client/content/LocalFileContent.kt:14:1</span><span class="message">The class `LocalFileContent` is using inheritance, consider using composition instead.

Does `LocalFileContent` want to expose the complete interface (`readFrom, readFrom`) of `ReadChannelContent` such that `LocalFileContent` can be used where `ReadChannelContent` is expected? Indicates __inheritance__.

Does `LocalFileContent` want only some/part of the behavior exposed by `ReadChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import io.ktor.utils.io.*
<span class="lineno">  12 </span>import java.io.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">/**</span>
<span class="lineno">  15 </span><span class="error"> * OutgoingContent representing a local [file] with a specified [contentType], [expires] date and [caching]</span>
<span class="lineno">  16 </span><span class="error"> *</span>
<span class="lineno">  17 </span><span class="error"> * @param file specifies the File to be served to a client</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/jvm/src/io/ktor/client/utils/CIOJvm.kt:18:1</span><span class="message">The class `ByteBufferPool` is using inheritance, consider using composition instead.

Does `ByteBufferPool` want to expose the complete interface (`dispose, recycle, borrow`) of `DefaultPool` such that `ByteBufferPool` can be used where `DefaultPool` is expected? Indicates __inheritance__.

Does `ByteBufferPool` want only some/part of the behavior exposed by `DefaultPool`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>@InternalAPI
<span class="lineno">  16 </span>val HttpClientDefaultPool = ByteBufferPool()
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">@InternalAPI</span>
<span class="lineno">  19 </span><span class="error">class ByteBufferPool : DefaultPool&lt;ByteBuffer&gt;(DEFAULT_HTTP_POOL_SIZE) {</span>
<span class="lineno">  20 </span><span class="error">    override fun produceInstance(): ByteBuffer = ByteBuffer.allocate(DEFAULT_HTTP_BUFFER_SIZE)!!</span>
<span class="lineno">  21 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/posix/src/io/ktor/network/sockets/TimeoutExceptionsNative.kt:9:1</span><span class="message">The class `ConnectTimeoutException` is using inheritance, consider using composition instead.

Does `ConnectTimeoutException` want to expose the complete interface (`empty public interface`) of `IOException` such that `ConnectTimeoutException` can be used where `IOException` is expected? Indicates __inheritance__.

Does `ConnectTimeoutException` want only some/part of the behavior exposed by `IOException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>
<span class="lineno">   7 </span>import io.ktor.utils.io.errors.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">/**</span>
<span class="lineno">  10 </span><span class="error"> * This exception is thrown in case connect timeout exceeded.</span>
<span class="lineno">  11 </span><span class="error"> */</span>
<span class="lineno">  12 </span><span class="error">actual class ConnectTimeoutException actual constructor(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-core/posix/src/io/ktor/network/sockets/TimeoutExceptionsNative.kt:16:1</span><span class="message">The class `SocketTimeoutException` is using inheritance, consider using composition instead.

Does `SocketTimeoutException` want to expose the complete interface (`empty public interface`) of `IOException` such that `SocketTimeoutException` can be used where `IOException` is expected? Indicates __inheritance__.

Does `SocketTimeoutException` want only some/part of the behavior exposed by `IOException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>    message: String, cause: Throwable?
<span class="lineno">  14 </span>) : IOException(message, cause)
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">/**</span>
<span class="lineno">  17 </span><span class="error"> * This exception is thrown in case socket timeout (read or write) exceeded.</span>
<span class="lineno">  18 </span><span class="error"> */</span>
<span class="lineno">  19 </span><span class="error">actual class SocketTimeoutException actual constructor(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-curl/posix/src/io/ktor/client/engine/curl/CurlClientEngine.kt:18:1</span><span class="message">The class `CurlClientEngine` is using inheritance, consider using composition instead.

Does `CurlClientEngine` want to expose the complete interface (`close`) of `HttpClientEngineBase` such that `CurlClientEngine` can be used where `HttpClientEngineBase` is expected? Indicates __inheritance__.

Does `CurlClientEngine` want only some/part of the behavior exposed by `HttpClientEngineBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>import kotlinx.coroutines.*
<span class="lineno">  16 </span>import io.ktor.utils.io.*
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">internal class CurlClientEngine(</span>
<span class="lineno">  19 </span><span class="error">    override val config: CurlClientEngineConfig</span>
<span class="lineno">  20 </span><span class="error">) : HttpClientEngineBase(&quot;ktor-curl&quot;) {</span>
<span class="lineno">  21 </span><span class="error">    override val dispatcher = Dispatchers.Unconfined</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-curl/posix/src/io/ktor/client/engine/curl/CurlClientEngineConfig.kt:9:1</span><span class="message">The class `CurlClientEngineConfig` is using inheritance, consider using composition instead.

Does `CurlClientEngineConfig` want to expose the complete interface (`empty public interface`) of `HttpClientEngineConfig` such that `CurlClientEngineConfig` can be used where `HttpClientEngineConfig` is expected? Indicates __inheritance__.

Does `CurlClientEngineConfig` want only some/part of the behavior exposed by `HttpClientEngineConfig`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>
<span class="lineno">   7 </span>import io.ktor.client.engine.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">class CurlClientEngineConfig : HttpClientEngineConfig()</span>
<span class="lineno">  10 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-curl/posix/src/io/ktor/client/engine/curl/internal/CurlRaw.kt:55:1</span><span class="message">The class `CurlSuccess` is using inheritance, consider using composition instead.

Does `CurlSuccess` want to expose the complete interface (`empty public interface`) of `CurlResponseData` such that `CurlSuccess` can be used where `CurlResponseData` is expected? Indicates __inheritance__.

Does `CurlSuccess` want only some/part of the behavior exposed by `CurlResponseData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  52 </span>    val request: CurlRequestData
<span class="lineno">  53 </span>)
<span class="lineno">  54 </span>
<span class="lineno">  55 </span><span class="error">internal class CurlSuccess(</span>
<span class="lineno">  56 </span><span class="error">    request: CurlRequestData,</span>
<span class="lineno">  57 </span><span class="error">    val status: Int,</span>
<span class="lineno">  58 </span><span class="error">    val version: UInt,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-curl/posix/src/io/ktor/client/engine/curl/internal/CurlRaw.kt:65:1</span><span class="message">The class `CurlFail` is using inheritance, consider using composition instead.

Does `CurlFail` want to expose the complete interface (`empty public interface`) of `CurlResponseData` such that `CurlFail` can be used where `CurlResponseData` is expected? Indicates __inheritance__.

Does `CurlFail` want only some/part of the behavior exposed by `CurlResponseData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  62 </span>    override fun toString(): String = &quot;CurlSuccess(${HttpStatusCode.fromValue(status)})&quot;
<span class="lineno">  63 </span>}
<span class="lineno">  64 </span>
<span class="lineno">  65 </span><span class="error">internal class CurlFail(</span>
<span class="lineno">  66 </span><span class="error">    request: CurlRequestData,</span>
<span class="lineno">  67 </span><span class="error">    val cause: Throwable</span>
<span class="lineno">  68 </span><span class="error">) : CurlResponseData(request) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-features/ktor-client-json/ktor-client-json-tests/jvm/src/io/ktor/client/features/json/tests/JsonTest.kt:25:1</span><span class="message">The class `JsonTest` is using inheritance, consider using composition instead.

Does `JsonTest` want to expose the complete interface (`stopServer, startServer`) of `TestWithKtor` such that `JsonTest` can be used where `TestWithKtor` is expected? Indicates __inheritance__.

Does `JsonTest` want only some/part of the behavior exposed by `TestWithKtor`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  22 </span>import kotlinx.serialization.*
<span class="lineno">  23 </span>import kotlin.test.*
<span class="lineno">  24 </span>
<span class="lineno">  25 </span><span class="error">/** Base class for JSON tests. */</span>
<span class="lineno">  26 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  27 </span><span class="error">abstract class JsonTest : TestWithKtor() {</span>
<span class="lineno">  28 </span><span class="error">    val widget = Widget(&quot;Foo&quot;, 1000, listOf(&quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;))</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-features/ktor-client-logging/common/src/io/ktor/client/features/logging/ObservingUtils.kt:37:1</span><span class="message">The class `LoggingContent` is using inheritance, consider using composition instead.

Does `LoggingContent` want to expose the complete interface (`readFrom, readFrom`) of `ReadChannelContent` such that `LoggingContent` can be used where `ReadChannelContent` is expected? Indicates __inheritance__.

Does `LoggingContent` want only some/part of the behavior exposed by `ReadChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  34 </span>    }
<span class="lineno">  35 </span>}
<span class="lineno">  36 </span>
<span class="lineno">  37 </span><span class="error">internal class LoggingContent(private val channel: ByteReadChannel) : OutgoingContent.ReadChannelContent() {</span>
<span class="lineno">  38 </span><span class="error">    override fun readFrom(): ByteReadChannel = channel</span>
<span class="lineno">  39 </span><span class="error">}</span>
<span class="lineno">  40 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-ios/darwin/src/io/ktor/client/engine/ios/IosClientEngine.kt:14:1</span><span class="message">The class `IosClientEngine` is using inheritance, consider using composition instead.

Does `IosClientEngine` want to expose the complete interface (`close`) of `HttpClientEngineBase` such that `IosClientEngine` can be used where `HttpClientEngineBase` is expected? Indicates __inheritance__.

Does `IosClientEngine` want only some/part of the behavior exposed by `HttpClientEngineBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import kotlinx.coroutines.*
<span class="lineno">  12 </span>import platform.Foundation.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">internal class IosClientEngine(override val config: IosClientEngineConfig) : HttpClientEngineBase(&quot;ktor-ios&quot;) {</span>
<span class="lineno">  15 </span><span class="error"></span>
<span class="lineno">  16 </span><span class="error">    override val dispatcher = Dispatchers.Unconfined</span>
<span class="lineno">  17 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-ios/darwin/src/io/ktor/client/engine/ios/IosClientEngineConfig.kt:20:1</span><span class="message">The class `IosClientEngineConfig` is using inheritance, consider using composition instead.

Does `IosClientEngineConfig` want to expose the complete interface (`empty public interface`) of `HttpClientEngineConfig` such that `IosClientEngineConfig` can be used where `HttpClientEngineConfig` is expected? Indicates __inheritance__.

Does `IosClientEngineConfig` want only some/part of the behavior exposed by `HttpClientEngineConfig`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  17 </span>    completionHandler: (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -&gt; Unit
<span class="lineno">  18 </span>) -&gt; Unit
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">/**</span>
<span class="lineno">  21 </span><span class="error"> * Custom [IosClientEngine] config.</span>
<span class="lineno">  22 </span><span class="error"> */</span>
<span class="lineno">  23 </span><span class="error">class IosClientEngineConfig : HttpClientEngineConfig() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-jetty/jvm/src/io/ktor/client/engine/jetty/JettyEngineConfig.kt:11:1</span><span class="message">The class `JettyEngineConfig` is using inheritance, consider using composition instead.

Does `JettyEngineConfig` want to expose the complete interface (`empty public interface`) of `HttpClientEngineConfig` such that `JettyEngineConfig` can be used where `HttpClientEngineConfig` is expected? Indicates __inheritance__.

Does `JettyEngineConfig` want only some/part of the behavior exposed by `HttpClientEngineConfig`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import org.eclipse.jetty.util.ssl.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * Configuration for [Jetty] implementation of [HttpClientEngineFactory].</span>
<span class="lineno">  13 </span><span class="error"> */</span>
<span class="lineno">  14 </span><span class="error">class JettyEngineConfig : HttpClientEngineConfig() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-jetty/jvm/src/io/ktor/client/engine/jetty/JettyHttp2Engine.kt:16:1</span><span class="message">The class `JettyHttp2Engine` is using inheritance, consider using composition instead.

Does `JettyHttp2Engine` want to expose the complete interface (`close`) of `HttpClientEngineBase` such that `JettyHttp2Engine` can be used where `HttpClientEngineBase` is expected? Indicates __inheritance__.

Does `JettyHttp2Engine` want only some/part of the behavior exposed by `HttpClientEngineBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import org.eclipse.jetty.http2.client.*
<span class="lineno">  14 </span>import org.eclipse.jetty.util.thread.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">internal class JettyHttp2Engine(override val config: JettyEngineConfig) : HttpClientEngineBase(&quot;ktor-jetty&quot;) {</span>
<span class="lineno">  17 </span><span class="error"></span>
<span class="lineno">  18 </span><span class="error">    override val dispatcher: CoroutineDispatcher by lazy {</span>
<span class="lineno">  19 </span><span class="error">        Dispatchers.clientDispatcher(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-mock/common/src/io/ktor/client/engine/mock/MockEngine.kt:14:1</span><span class="message">The class `MockEngine` is using inheritance, consider using composition instead.

Does `MockEngine` want to expose the complete interface (`close`) of `HttpClientEngineBase` such that `MockEngine` can be used where `HttpClientEngineBase` is expected? Indicates __inheritance__.

Does `MockEngine` want only some/part of the behavior exposed by `HttpClientEngineBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import kotlinx.atomicfu.locks.*
<span class="lineno">  12 </span>import kotlinx.coroutines.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">/**</span>
<span class="lineno">  15 </span><span class="error"> * [HttpClientEngine] for writing tests without network.</span>
<span class="lineno">  16 </span><span class="error"> */</span>
<span class="lineno">  17 </span><span class="error">class MockEngine(override val config: MockEngineConfig) : HttpClientEngineBase(&quot;ktor-mock&quot;) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-mock/common/src/io/ktor/client/engine/mock/MockEngineConfig.kt:23:1</span><span class="message">The class `MockEngineConfig` is using inheritance, consider using composition instead.

Does `MockEngineConfig` want to expose the complete interface (`empty public interface`) of `HttpClientEngineConfig` such that `MockEngineConfig` can be used where `HttpClientEngineConfig` is expected? Indicates __inheritance__.

Does `MockEngineConfig` want only some/part of the behavior exposed by `HttpClientEngineConfig`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  20 </span> */
<span class="lineno">  21 </span>class MockRequestHandleScope(internal val callContext: CoroutineContext)
<span class="lineno">  22 </span>
<span class="lineno">  23 </span><span class="error">/**</span>
<span class="lineno">  24 </span><span class="error"> * [HttpClientEngineConfig] for [MockEngine].</span>
<span class="lineno">  25 </span><span class="error"> */</span>
<span class="lineno">  26 </span><span class="error">class MockEngineConfig : HttpClientEngineConfig() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpConfig.kt:10:1</span><span class="message">The class `OkHttpConfig` is using inheritance, consider using composition instead.

Does `OkHttpConfig` want to expose the complete interface (`empty public interface`) of `HttpClientEngineConfig` such that `OkHttpConfig` can be used where `HttpClientEngineConfig` is expected? Indicates __inheritance__.

Does `OkHttpConfig` want only some/part of the behavior exposed by `HttpClientEngineConfig`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import io.ktor.client.engine.*
<span class="lineno">   8 </span>import okhttp3.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">/**</span>
<span class="lineno">  11 </span><span class="error"> * Configuration for [OkHttp] client engine.</span>
<span class="lineno">  12 </span><span class="error"> */</span>
<span class="lineno">  13 </span><span class="error">class OkHttpConfig : HttpClientEngineConfig() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt:26:1</span><span class="message">The class `OkHttpEngine` is using inheritance, consider using composition instead.

Does `OkHttpEngine` want to expose the complete interface (`close`) of `HttpClientEngineBase` such that `OkHttpEngine` can be used where `HttpClientEngineBase` is expected? Indicates __inheritance__.

Does `OkHttpEngine` want only some/part of the behavior exposed by `HttpClientEngineBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  23 </span>import java.util.concurrent.*
<span class="lineno">  24 </span>import kotlin.coroutines.*
<span class="lineno">  25 </span>
<span class="lineno">  26 </span><span class="error">@InternalAPI</span>
<span class="lineno">  27 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  28 </span><span class="error">class OkHttpEngine(override val config: OkHttpConfig) : HttpClientEngineBase(&quot;ktor-okhttp&quot;) {</span>
<span class="lineno">  29 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-tests/jvm/src/io/ktor/client/tests/BuildersTest.kt:18:1</span><span class="message">The class `BuildersTest` is using inheritance, consider using composition instead.

Does `BuildersTest` want to expose the complete interface (`stopServer, startServer`) of `TestWithKtor` such that `BuildersTest` can be used where `TestWithKtor` is expected? Indicates __inheritance__.

Does `BuildersTest` want only some/part of the behavior exposed by `TestWithKtor`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>import io.ktor.server.netty.*
<span class="lineno">  16 </span>import kotlin.test.*
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  19 </span><span class="error">abstract class BuildersTest(val factory: HttpClientEngineFactory&lt;*&gt;) : TestWithKtor() {</span>
<span class="lineno">  20 </span><span class="error">    override val server: ApplicationEngine = embeddedServer(Netty, serverPort) {</span>
<span class="lineno">  21 </span><span class="error">        routing {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-tests/jvm/src/io/ktor/client/tests/HttpClientTest.kt:26:1</span><span class="message">The class `HttpClientTest` is using inheritance, consider using composition instead.

Does `HttpClientTest` want to expose the complete interface (`stopServer, startServer`) of `TestWithKtor` such that `HttpClientTest` can be used where `TestWithKtor` is expected? Indicates __inheritance__.

Does `HttpClientTest` want only some/part of the behavior exposed by `TestWithKtor`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  23 </span>import kotlin.coroutines.*
<span class="lineno">  24 </span>import kotlin.test.*
<span class="lineno">  25 </span>
<span class="lineno">  26 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  27 </span><span class="error">abstract class HttpClientTest(private val factory: HttpClientEngineFactory&lt;*&gt;) : TestWithKtor() {</span>
<span class="lineno">  28 </span><span class="error">    override val server: ApplicationEngine = embeddedServer(Netty, serverPort) {</span>
<span class="lineno">  29 </span><span class="error">        routing {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-client/ktor-client-tests/jvm/src/io/ktor/client/tests/MultithreadedTest.kt:27:1</span><span class="message">The class `MultithreadedTest` is using inheritance, consider using composition instead.

Does `MultithreadedTest` want to expose the complete interface (`stopServer, startServer`) of `TestWithKtor` such that `MultithreadedTest` can be used where `TestWithKtor` is expected? Indicates __inheritance__.

Does `MultithreadedTest` want only some/part of the behavior exposed by `TestWithKtor`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  24 </span>private const val TEST_SIZE = 100_000
<span class="lineno">  25 </span>private const val DEFAULT_THREADS_COUNT = 32
<span class="lineno">  26 </span>
<span class="lineno">  27 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  28 </span><span class="error">abstract class MultithreadedTest(private val factory: HttpClientEngineFactory&lt;*&gt;) : TestWithKtor() {</span>
<span class="lineno">  29 </span><span class="error">    private val counter: AtomicInteger = AtomicInteger()</span>
<span class="lineno">  30 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth-jwt/jvm/src/io/ktor/auth/jwt/JWTAuth.kt:47:1</span><span class="message">The class `JWTAuthenticationProvider` is using inheritance, consider using composition instead.

Does `JWTAuthenticationProvider` want to expose the complete interface (`skipWhen`) of `AuthenticationProvider` such that `JWTAuthenticationProvider` can be used where `AuthenticationProvider` is expected? Indicates __inheritance__.

Does `JWTAuthenticationProvider` want only some/part of the behavior exposed by `AuthenticationProvider`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  44 </span> */
<span class="lineno">  45 </span>typealias JWTConfigureFunction = Verification.() -&gt; Unit
<span class="lineno">  46 </span>
<span class="lineno">  47 </span><span class="error">/**</span>
<span class="lineno">  48 </span><span class="error"> * JWT authentication provider that will be registered with the specified [name]</span>
<span class="lineno">  49 </span><span class="error"> */</span>
<span class="lineno">  50 </span><span class="error">class JWTAuthenticationProvider internal constructor(config: Configuration) : AuthenticationProvider(config) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth-jwt/jvm/src/io/ktor/auth/jwt/JWTAuth.kt:59:5</span><span class="message">The class `Configuration` is using inheritance, consider using composition instead.

Does `Configuration` want to expose the complete interface (`skipWhen`) of `Configuration` such that `Configuration` can be used where `Configuration` is expected? Indicates __inheritance__.

Does `Configuration` want only some/part of the behavior exposed by `Configuration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  56 </span>    internal val authenticationFunction = config.authenticationFunction
<span class="lineno">  57 </span>    internal val challengeFunction: JWTAuthChallengeFunction = config.challenge
<span class="lineno">  58 </span>
<span class="lineno">  59 </span>    <span class="error">/**</span>
<span class="lineno">  60 </span><span class="error">     * JWT auth provider configuration</span>
<span class="lineno">  61 </span><span class="error">     */</span>
<span class="lineno">  62 </span><span class="error">    class Configuration internal constructor(name: String?) : AuthenticationProvider.Configuration(name) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/Authentication.kt:64:5</span><span class="message">The class `LambdaProviderConfig` is using inheritance, consider using composition instead.

Does `LambdaProviderConfig` want to expose the complete interface (`skipWhen`) of `Configuration` such that `LambdaProviderConfig` can be used where `Configuration` is expected? Indicates __inheritance__.

Does `LambdaProviderConfig` want only some/part of the behavior exposed by `Configuration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  61 </span>        internal fun copy(): Configuration = Configuration(providers)
<span class="lineno">  62 </span>    }
<span class="lineno">  63 </span>
<span class="lineno">  64 </span>    <span class="error">private class LambdaProviderConfig(name: String?) : AuthenticationProvider.Configuration(name) {</span>
<span class="lineno">  65 </span><span class="error">        internal fun buildProvider() = AuthenticationProvider(this)</span>
<span class="lineno">  66 </span><span class="error">    }</span>
<span class="lineno">  67 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/Authentication.kt:319:1</span><span class="message">The class `AuthenticationRouteSelector` is using inheritance, consider using composition instead.

Does `AuthenticationRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `AuthenticationRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `AuthenticationRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 316 </span>    return authenticatedRoute
<span class="lineno"> 317 </span>}
<span class="lineno"> 318 </span>
<span class="lineno"> 319 </span><span class="error">/**</span>
<span class="lineno"> 320 </span><span class="error"> * An authentication route node that is used by [Authentication] feature</span>
<span class="lineno"> 321 </span><span class="error"> * and usually created by [Route.authenticate] DSL function so generally there is no need to instantiate it directly</span>
<span class="lineno"> 322 </span><span class="error"> * unless you are writing an extension</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/AuthenticationFailedCause.kt:21:5</span><span class="message">The class `Error` is using inheritance, consider using composition instead.

Does `Error` want to expose the complete interface (`empty public interface`) of `AuthenticationFailedCause` such that `Error` can be used where `AuthenticationFailedCause` is expected? Indicates __inheritance__.

Does `Error` want only some/part of the behavior exposed by `AuthenticationFailedCause`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  18 </span>     */
<span class="lineno">  19 </span>    object InvalidCredentials : AuthenticationFailedCause()
<span class="lineno">  20 </span>
<span class="lineno">  21 </span>    <span class="error">/**</span>
<span class="lineno">  22 </span><span class="error">     * Represents a case when authentication mechanism failed</span>
<span class="lineno">  23 </span><span class="error">     * @param message describing the cause of the authentication failure</span>
<span class="lineno">  24 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/AuthenticationPipeline.kt:10:1</span><span class="message">The class `AuthenticationPipeline` is using inheritance, consider using composition instead.

Does `AuthenticationPipeline` want to expose the complete interface (`merge, afterIntercepted, intercept, insertPhaseBefore, insertPhaseAfter, addPhase, execute`) of `Pipeline` such that `AuthenticationPipeline` can be used where `Pipeline` is expected? Indicates __inheritance__.

Does `AuthenticationPipeline` want only some/part of the behavior exposed by `Pipeline`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import io.ktor.application.*
<span class="lineno">   8 </span>import io.ktor.util.pipeline.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">/**</span>
<span class="lineno">  11 </span><span class="error"> * Represents authentication [Pipeline] for checking and requesting authentication</span>
<span class="lineno">  12 </span><span class="error"> */</span>
<span class="lineno">  13 </span><span class="error">class AuthenticationPipeline : Pipeline&lt;AuthenticationContext, ApplicationCall&gt;(CheckAuthentication, RequestAuthentication) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/AuthenticationProvider.kt:93:5</span><span class="message">The class `NamedConfiguration` is using inheritance, consider using composition instead.

Does `NamedConfiguration` want to expose the complete interface (`skipWhen`) of `Configuration` such that `NamedConfiguration` can be used where `Configuration` is expected? Indicates __inheritance__.

Does `NamedConfiguration` want only some/part of the behavior exposed by `Configuration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  90 </span>        }
<span class="lineno">  91 </span>    }
<span class="lineno">  92 </span>
<span class="lineno">  93 </span>    <span class="error">private class NamedConfiguration(name: String?) : Configuration(name)</span>
<span class="lineno">  94 </span>}
<span class="lineno">  95 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/BasicAuth.kt:15:1</span><span class="message">The class `BasicAuthenticationProvider` is using inheritance, consider using composition instead.

Does `BasicAuthenticationProvider` want to expose the complete interface (`skipWhen`) of `AuthenticationProvider` such that `BasicAuthenticationProvider` can be used where `AuthenticationProvider` is expected? Indicates __inheritance__.

Does `BasicAuthenticationProvider` want only some/part of the behavior exposed by `AuthenticationProvider`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>import io.ktor.utils.io.charsets.*
<span class="lineno">  13 </span>import kotlin.text.Charsets
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">/**</span>
<span class="lineno">  16 </span><span class="error"> * Represents a Basic authentication provider</span>
<span class="lineno">  17 </span><span class="error"> * @property name is the name of the provider, or `null` for a default provider</span>
<span class="lineno">  18 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/BasicAuth.kt:28:5</span><span class="message">The class `Configuration` is using inheritance, consider using composition instead.

Does `Configuration` want to expose the complete interface (`skipWhen`) of `Configuration` such that `Configuration` can be used where `Configuration` is expected? Indicates __inheritance__.

Does `Configuration` want only some/part of the behavior exposed by `Configuration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  25 </span>
<span class="lineno">  26 </span>    internal val authenticationFunction = configuration.authenticationFunction
<span class="lineno">  27 </span>
<span class="lineno">  28 </span>    <span class="error">/**</span>
<span class="lineno">  29 </span><span class="error">     * Basic auth configuration</span>
<span class="lineno">  30 </span><span class="error">     */</span>
<span class="lineno">  31 </span><span class="error">    class Configuration internal constructor(name: String?) : AuthenticationProvider.Configuration(name) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/DigestAuth.kt:14:1</span><span class="message">The class `DigestAuthenticationProvider` is using inheritance, consider using composition instead.

Does `DigestAuthenticationProvider` want to expose the complete interface (`skipWhen`) of `AuthenticationProvider` such that `DigestAuthenticationProvider` can be used where `AuthenticationProvider` is expected? Indicates __inheritance__.

Does `DigestAuthenticationProvider` want only some/part of the behavior exposed by `AuthenticationProvider`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import io.ktor.util.*
<span class="lineno">  12 </span>import java.security.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">/**</span>
<span class="lineno">  15 </span><span class="error"> * Represents a Digest authentication provider</span>
<span class="lineno">  16 </span><span class="error"> * @property realm specifies value to be passed in `WWW-Authenticate` header</span>
<span class="lineno">  17 </span><span class="error"> * @property algorithmName Message digest algorithm to be used. Usually only `MD5` is supported by clients.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/DigestAuth.kt:34:5</span><span class="message">The class `Configuration` is using inheritance, consider using composition instead.

Does `Configuration` want to expose the complete interface (`skipWhen`) of `Configuration` such that `Configuration` can be used where `Configuration` is expected? Indicates __inheritance__.

Does `Configuration` want only some/part of the behavior exposed by `Configuration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  31 </span>    @KtorExperimentalAPI
<span class="lineno">  32 </span>    internal val userNameRealmPasswordDigestProvider: suspend (String, String) -&gt; ByteArray? = config.digestProvider
<span class="lineno">  33 </span>
<span class="lineno">  34 </span>    <span class="error">/**</span>
<span class="lineno">  35 </span><span class="error">     * Digest auth configuration</span>
<span class="lineno">  36 </span><span class="error">     */</span>
<span class="lineno">  37 </span><span class="error">    class Configuration internal constructor(name: String?) : AuthenticationProvider.Configuration(name) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/ForbiddenResponse.kt:11:1</span><span class="message">The class `ForbiddenResponse` is using inheritance, consider using composition instead.

Does `ForbiddenResponse` want to expose the complete interface (`empty public interface`) of `NoContent` such that `ForbiddenResponse` can be used where `NoContent` is expected? Indicates __inheritance__.

Does `ForbiddenResponse` want only some/part of the behavior exposed by `NoContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.http.*
<span class="lineno">   9 </span>import io.ktor.http.auth.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * Response content with `403 Forbidden` status code and `WWW-Authenticate` header of supplied [challenges]</span>
<span class="lineno">  13 </span><span class="error"> * @param challenges to be passed with `WWW-Authenticate` header</span>
<span class="lineno">  14 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/FormAuth.kt:13:1</span><span class="message">The class `FormAuthenticationProvider` is using inheritance, consider using composition instead.

Does `FormAuthenticationProvider` want to expose the complete interface (`skipWhen`) of `AuthenticationProvider` such that `FormAuthenticationProvider` can be used where `AuthenticationProvider` is expected? Indicates __inheritance__.

Does `FormAuthenticationProvider` want only some/part of the behavior exposed by `AuthenticationProvider`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import io.ktor.response.*
<span class="lineno">  11 </span>import io.ktor.util.pipeline.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">/**</span>
<span class="lineno">  14 </span><span class="error"> * Represents a form-based authentication provider</span>
<span class="lineno">  15 </span><span class="error"> */</span>
<span class="lineno">  16 </span><span class="error">class FormAuthenticationProvider internal constructor(config: Configuration) : AuthenticationProvider(config) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/FormAuth.kt:26:5</span><span class="message">The class `Configuration` is using inheritance, consider using composition instead.

Does `Configuration` want to expose the complete interface (`skipWhen`) of `Configuration` such that `Configuration` can be used where `Configuration` is expected? Indicates __inheritance__.

Does `Configuration` want only some/part of the behavior exposed by `Configuration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  23 </span>    internal val authenticationFunction: AuthenticationFunction&lt;UserPasswordCredential&gt; =
<span class="lineno">  24 </span>        config.authenticationFunction
<span class="lineno">  25 </span>
<span class="lineno">  26 </span>    <span class="error">/**</span>
<span class="lineno">  27 </span><span class="error">     * Form auth provider configuration</span>
<span class="lineno">  28 </span><span class="error">     */</span>
<span class="lineno">  29 </span><span class="error">    class Configuration internal constructor(name: String?) : AuthenticationProvider.Configuration(name) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/FormAuth.kt:146:5</span><span class="message">The class `Redirect` is using inheritance, consider using composition instead.

Does `Redirect` want to expose the complete interface (`empty public interface`) of `FormAuthChallenge` such that `Redirect` can be used where `FormAuthChallenge` is expected? Indicates __inheritance__.

Does `Redirect` want only some/part of the behavior exposed by `FormAuthChallenge`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 143 </span>@Suppress(&quot;DEPRECATION_ERROR&quot;)
<span class="lineno"> 144 </span>@Deprecated(&quot;Use challenge {} instead.&quot;, level = DeprecationLevel.ERROR)
<span class="lineno"> 145 </span>sealed class FormAuthChallenge {
<span class="lineno"> 146 </span>    <span class="error">/**</span>
<span class="lineno"> 147 </span><span class="error">     * Redirect to an URL provided by the given function.</span>
<span class="lineno"> 148 </span><span class="error">     * @property url is a function receiving [ApplicationCall] and [UserPasswordCredential] and returning an URL to redirect to.</span>
<span class="lineno"> 149 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuth.kt:67:5</span><span class="message">The class `OAuth1aServerSettings` is using inheritance, consider using composition instead.

Does `OAuth1aServerSettings` want to expose the complete interface (`empty public interface`) of `OAuthServerSettings` such that `OAuth1aServerSettings` can be used where `OAuthServerSettings` is expected? Indicates __inheritance__.

Does `OAuth1aServerSettings` want only some/part of the behavior exposed by `OAuthServerSettings`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  64 </span> * @property version OAuth version (1a or 2)
<span class="lineno">  65 </span> */
<span class="lineno">  66 </span>sealed class OAuthServerSettings(val name: String, val version: OAuthVersion) {
<span class="lineno">  67 </span>    <span class="error">/**</span>
<span class="lineno">  68 </span><span class="error">     * OAuth1a server settings</span>
<span class="lineno">  69 </span><span class="error">     * @property requestTokenUrl OAuth server token request URL</span>
<span class="lineno">  70 </span><span class="error">     * @property authorizeUrl OAuth server authorization page URL</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuth.kt:85:5</span><span class="message">The class `OAuth2ServerSettings` is using inheritance, consider using composition instead.

Does `OAuth2ServerSettings` want to expose the complete interface (`empty public interface`) of `OAuthServerSettings` such that `OAuth2ServerSettings` can be used where `OAuthServerSettings` is expected? Indicates __inheritance__.

Does `OAuth2ServerSettings` want only some/part of the behavior exposed by `OAuthServerSettings`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  82 </span>        val consumerSecret: String
<span class="lineno">  83 </span>    ) : OAuthServerSettings(name, OAuthVersion.V10a)
<span class="lineno">  84 </span>
<span class="lineno">  85 </span>    <span class="error">/**</span>
<span class="lineno">  86 </span><span class="error">     * OAuth2 server settings</span>
<span class="lineno">  87 </span><span class="error">     * @property authorizeUrl OAuth server authorization page URL</span>
<span class="lineno">  88 </span><span class="error">     * @property accessTokenUrl OAuth server access token request URL</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuth.kt:119:5</span><span class="message">The class `TokenPair` is using inheritance, consider using composition instead.

Does `TokenPair` want to expose the complete interface (`empty public interface`) of `OAuthCallback` such that `TokenPair` can be used where `OAuthCallback` is expected? Indicates __inheritance__.

Does `TokenPair` want only some/part of the behavior exposed by `OAuthCallback`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 116 </span> * OAauth callback parameters
<span class="lineno"> 117 </span> */
<span class="lineno"> 118 </span>sealed class OAuthCallback {
<span class="lineno"> 119 </span>    <span class="error">/**</span>
<span class="lineno"> 120 </span><span class="error">     * An OAuth1a token pair callback parameters</span>
<span class="lineno"> 121 </span><span class="error">     * @property token OAuth1a token</span>
<span class="lineno"> 122 </span><span class="error">     * @property tokenSecret OAuth1a token secret</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuth.kt:126:5</span><span class="message">The class `TokenSingle` is using inheritance, consider using composition instead.

Does `TokenSingle` want to expose the complete interface (`empty public interface`) of `OAuthCallback` such that `TokenSingle` can be used where `OAuthCallback` is expected? Indicates __inheritance__.

Does `TokenSingle` want only some/part of the behavior exposed by `OAuthCallback`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 123 </span>     */
<span class="lineno"> 124 </span>    data class TokenPair(val token: String, val tokenSecret: String) : OAuthCallback()
<span class="lineno"> 125 </span>
<span class="lineno"> 126 </span>    <span class="error">/**</span>
<span class="lineno"> 127 </span><span class="error">     * OAuth2 token callback parameter</span>
<span class="lineno"> 128 </span><span class="error">     * @property token OAuth2 token provided by server</span>
<span class="lineno"> 129 </span><span class="error">     * @property state passed from a client (ktor server) during authorization startup</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuth.kt:138:5</span><span class="message">The class `OAuth1a` is using inheritance, consider using composition instead.

Does `OAuth1a` want to expose the complete interface (`empty public interface`) of `OAuthAccessTokenResponse` such that `OAuth1a` can be used where `OAuthAccessTokenResponse` is expected? Indicates __inheritance__.

Does `OAuth1a` want only some/part of the behavior exposed by `OAuthAccessTokenResponse`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 135 </span> * OAuth access token acquired from the server
<span class="lineno"> 136 </span> */
<span class="lineno"> 137 </span>sealed class OAuthAccessTokenResponse : Principal {
<span class="lineno"> 138 </span>    <span class="error">/**</span>
<span class="lineno"> 139 </span><span class="error">     * OAuth1a access token acquired from the server</span>
<span class="lineno"> 140 </span><span class="error">     * @property token itself</span>
<span class="lineno"> 141 </span><span class="error">     * @property tokenSecret token secret to be used with [token]</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuth.kt:150:5</span><span class="message">The class `OAuth2` is using inheritance, consider using composition instead.

Does `OAuth2` want to expose the complete interface (`empty public interface`) of `OAuthAccessTokenResponse` such that `OAuth2` can be used where `OAuthAccessTokenResponse` is expected? Indicates __inheritance__.

Does `OAuth2` want only some/part of the behavior exposed by `OAuthAccessTokenResponse`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 147 </span>        val extraParameters: Parameters = Parameters.Empty
<span class="lineno"> 148 </span>    ) : OAuthAccessTokenResponse()
<span class="lineno"> 149 </span>
<span class="lineno"> 150 </span>    <span class="error">/**</span>
<span class="lineno"> 151 </span><span class="error">     * OAuth2 access token acquired from the server</span>
<span class="lineno"> 152 </span><span class="error">     * @property accessToken access token from server</span>
<span class="lineno"> 153 </span><span class="error">     * @property tokenType OAuth2 token type (usually Bearer)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuth1a.kt:275:5</span><span class="message">The class `MissingTokenException` is using inheritance, consider using composition instead.

Does `MissingTokenException` want to expose the complete interface (`empty public interface`) of `OAuth1aException` such that `MissingTokenException` can be used where `OAuth1aException` is expected? Indicates __inheritance__.

Does `MissingTokenException` want only some/part of the behavior exposed by `OAuth1aException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 272 </span>@KtorExperimentalAPI
<span class="lineno"> 273 </span>sealed class OAuth1aException(message: String) : Exception(message) {
<span class="lineno"> 274 </span>
<span class="lineno"> 275 </span>    <span class="error">/**</span>
<span class="lineno"> 276 </span><span class="error">     * Thrown when an OAuth1a server didn't provide access token</span>
<span class="lineno"> 277 </span><span class="error">     */</span>
<span class="lineno"> 278 </span><span class="error">    class MissingTokenException : OAuth1aException(&quot;The OAuth1a server didn't provide access token&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuth1a.kt:280:5</span><span class="message">The class `UnknownException` is using inheritance, consider using composition instead.

Does `UnknownException` want to expose the complete interface (`empty public interface`) of `OAuth1aException` such that `UnknownException` can be used where `OAuth1aException` is expected? Indicates __inheritance__.

Does `UnknownException` want only some/part of the behavior exposed by `OAuth1aException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 277 </span>     */
<span class="lineno"> 278 </span>    class MissingTokenException : OAuth1aException(&quot;The OAuth1a server didn't provide access token&quot;)
<span class="lineno"> 279 </span>
<span class="lineno"> 280 </span>    <span class="error">/**</span>
<span class="lineno"> 281 </span><span class="error">     * Represents any other OAuth1a error</span>
<span class="lineno"> 282 </span><span class="error">     */</span>
<span class="lineno"> 283 </span><span class="error">    @KtorExperimentalAPI</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuth2.kt:352:5</span><span class="message">The class `InvalidGrant` is using inheritance, consider using composition instead.

Does `InvalidGrant` want to expose the complete interface (`empty public interface`) of `OAuth2Exception` such that `InvalidGrant` can be used where `OAuth2Exception` is expected? Indicates __inheritance__.

Does `InvalidGrant` want only some/part of the behavior exposed by `OAuth2Exception`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 349 </span> */
<span class="lineno"> 350 </span>@KtorExperimentalAPI
<span class="lineno"> 351 </span>sealed class OAuth2Exception(message: String, val errorCode: String?) : Exception(message) {
<span class="lineno"> 352 </span>    <span class="error">/**</span>
<span class="lineno"> 353 </span><span class="error">     * OAuth2 server responded error=&quot;invalid_grant&quot;</span>
<span class="lineno"> 354 </span><span class="error">     */</span>
<span class="lineno"> 355 </span><span class="error">    @KtorExperimentalAPI</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuth2.kt:358:5</span><span class="message">The class `MissingAccessToken` is using inheritance, consider using composition instead.

Does `MissingAccessToken` want to expose the complete interface (`empty public interface`) of `OAuth2Exception` such that `MissingAccessToken` can be used where `OAuth2Exception` is expected? Indicates __inheritance__.

Does `MissingAccessToken` want only some/part of the behavior exposed by `OAuth2Exception`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 355 </span>    @KtorExperimentalAPI
<span class="lineno"> 356 </span>    class InvalidGrant(message: String) : OAuth2Exception(message, &quot;invalid_grant&quot;)
<span class="lineno"> 357 </span>
<span class="lineno"> 358 </span>    <span class="error">/**</span>
<span class="lineno"> 359 </span><span class="error">     * Thrown when an OAuth2 server replied with successful HTTP status and expected content type that was successfully</span>
<span class="lineno"> 360 </span><span class="error">     * decoded but the response doesn't contain error code nor access token</span>
<span class="lineno"> 361 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuth2.kt:367:5</span><span class="message">The class `UnsupportedGrantType` is using inheritance, consider using composition instead.

Does `UnsupportedGrantType` want to expose the complete interface (`empty public interface`) of `OAuth2Exception` such that `UnsupportedGrantType` can be used where `OAuth2Exception` is expected? Indicates __inheritance__.

Does `UnsupportedGrantType` want only some/part of the behavior exposed by `OAuth2Exception`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 364 </span>        &quot;OAuth2 server response is OK neither error nor access token provided&quot;, null
<span class="lineno"> 365 </span>    )
<span class="lineno"> 366 </span>
<span class="lineno"> 367 </span>    <span class="error">/**</span>
<span class="lineno"> 368 </span><span class="error">     * Throw when an OAuth2 server replied with error &quot;unsupported_grant_type&quot;</span>
<span class="lineno"> 369 </span><span class="error">     * @param grantType that was passed to the server</span>
<span class="lineno"> 370 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuth2.kt:380:5</span><span class="message">The class `UnknownException` is using inheritance, consider using composition instead.

Does `UnknownException` want to expose the complete interface (`empty public interface`) of `OAuth2Exception` such that `UnknownException` can be used where `OAuth2Exception` is expected? Indicates __inheritance__.

Does `UnknownException` want only some/part of the behavior exposed by `OAuth2Exception`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 377 </span>        }
<span class="lineno"> 378 </span>    }
<span class="lineno"> 379 </span>
<span class="lineno"> 380 </span>    <span class="error">/**</span>
<span class="lineno"> 381 </span><span class="error">     * OAuth2 server responded with an error code [errorCode]</span>
<span class="lineno"> 382 </span><span class="error">     * @param errorCode the OAuth2 server replied with</span>
<span class="lineno"> 383 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuthProcedure.kt:19:1</span><span class="message">The class `OAuthAuthenticationProvider` is using inheritance, consider using composition instead.

Does `OAuthAuthenticationProvider` want to expose the complete interface (`skipWhen`) of `AuthenticationProvider` such that `OAuthAuthenticationProvider` can be used where `AuthenticationProvider` is expected? Indicates __inheritance__.

Does `OAuthAuthenticationProvider` want only some/part of the behavior exposed by `AuthenticationProvider`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span> */
<span class="lineno">  17 </span>val OAuthKey: Any = &quot;OAuth&quot;
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">/**</span>
<span class="lineno">  20 </span><span class="error"> * Represents an OAuth provider for [Authentication] feature</span>
<span class="lineno">  21 </span><span class="error"> */</span>
<span class="lineno">  22 </span><span class="error">class OAuthAuthenticationProvider internal constructor(config : Configuration) : AuthenticationProvider(config) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/OAuthProcedure.kt:28:5</span><span class="message">The class `Configuration` is using inheritance, consider using composition instead.

Does `Configuration` want to expose the complete interface (`skipWhen`) of `Configuration` such that `Configuration` can be used where `Configuration` is expected? Indicates __inheritance__.

Does `Configuration` want only some/part of the behavior exposed by `Configuration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  25 </span>    internal val providerLookup: ApplicationCall.() -&gt; OAuthServerSettings? = config.providerLookup
<span class="lineno">  26 </span>    internal val urlProvider: ApplicationCall.(OAuthServerSettings) -&gt; String = config.urlProvider
<span class="lineno">  27 </span>
<span class="lineno">  28 </span>    <span class="error">/**</span>
<span class="lineno">  29 </span><span class="error">     * OAuth provider configuration</span>
<span class="lineno">  30 </span><span class="error">     */</span>
<span class="lineno">  31 </span><span class="error">    class Configuration internal constructor(name: String?) : AuthenticationProvider.Configuration(name) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/SessionAuth.kt:15:1</span><span class="message">The class `SessionAuthenticationProvider` is using inheritance, consider using composition instead.

Does `SessionAuthenticationProvider` want to expose the complete interface (`skipWhen`) of `AuthenticationProvider` such that `SessionAuthenticationProvider` can be used where `AuthenticationProvider` is expected? Indicates __inheritance__.

Does `SessionAuthenticationProvider` want only some/part of the behavior exposed by `AuthenticationProvider`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>import io.ktor.util.pipeline.*
<span class="lineno">  13 </span>import kotlin.reflect.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">/**</span>
<span class="lineno">  16 </span><span class="error"> * Represents a session-based authentication provider</span>
<span class="lineno">  17 </span><span class="error"> * @property type of session</span>
<span class="lineno">  18 </span><span class="error"> * @property challenge to be used if there is no session</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/SessionAuth.kt:32:5</span><span class="message">The class `Configuration` is using inheritance, consider using composition instead.

Does `Configuration` want to expose the complete interface (`skipWhen`) of `Configuration` such that `Configuration` can be used where `Configuration` is expected? Indicates __inheritance__.

Does `Configuration` want only some/part of the behavior exposed by `Configuration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  29 </span>    @PublishedApi
<span class="lineno">  30 </span>    internal val validator: AuthenticationFunction&lt;T&gt; = config.validator
<span class="lineno">  31 </span>
<span class="lineno">  32 </span>    <span class="error">/**</span>
<span class="lineno">  33 </span><span class="error">     * Session auth configuration</span>
<span class="lineno">  34 </span><span class="error">     */</span>
<span class="lineno">  35 </span><span class="error">    class Configuration&lt;T : Any&gt; @PublishedApi internal constructor(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/SessionAuth.kt:191:5</span><span class="message">The class `Redirect` is using inheritance, consider using composition instead.

Does `Redirect` want to expose the complete interface (`empty public interface`) of `SessionAuthChallenge` such that `Redirect` can be used where `SessionAuthChallenge` is expected? Indicates __inheritance__.

Does `Redirect` want only some/part of the behavior exposed by `SessionAuthChallenge`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 188 </span>@Suppress(&quot;DEPRECATION_ERROR&quot;)
<span class="lineno"> 189 </span>@Deprecated(&quot;Use challenge {} instead.&quot;, level = DeprecationLevel.ERROR)
<span class="lineno"> 190 </span>sealed class SessionAuthChallenge&lt;in T : Any&gt; {
<span class="lineno"> 191 </span>    <span class="error">/**</span>
<span class="lineno"> 192 </span><span class="error">     * Redirect to an URL provided by the given function.</span>
<span class="lineno"> 193 </span><span class="error">     * @property url is a function receiving [ApplicationCall] and [UserPasswordCredential] and returning an URL to redirect to.</span>
<span class="lineno"> 194 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-auth/jvm/src/io/ktor/auth/UnauthorizedResponse.kt:11:1</span><span class="message">The class `UnauthorizedResponse` is using inheritance, consider using composition instead.

Does `UnauthorizedResponse` want to expose the complete interface (`empty public interface`) of `NoContent` such that `UnauthorizedResponse` can be used where `NoContent` is expected? Indicates __inheritance__.

Does `UnauthorizedResponse` want only some/part of the behavior exposed by `NoContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.http.*
<span class="lineno">   9 </span>import io.ktor.http.auth.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * Response content with `401 Unauthorized` status code and `WWW-Authenticate` header of supplied [challenges]</span>
<span class="lineno">  13 </span><span class="error"> * @param challenges to be passed with `WWW-Authenticate` header</span>
<span class="lineno">  14 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-freemarker/jvm/src/io/ktor/freemarker/FreeMarker.kt:63:5</span><span class="message">The class `FreeMarkerOutgoingContent` is using inheritance, consider using composition instead.

Does `FreeMarkerOutgoingContent` want to expose the complete interface (`writeTo`) of `WriteChannelContent` such that `FreeMarkerOutgoingContent` can be used where `WriteChannelContent` is expected? Indicates __inheritance__.

Does `FreeMarkerOutgoingContent` want only some/part of the behavior exposed by `WriteChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  60 </span>        )
<span class="lineno">  61 </span>    }
<span class="lineno">  62 </span>
<span class="lineno">  63 </span>    <span class="error">private class FreeMarkerOutgoingContent(</span>
<span class="lineno">  64 </span><span class="error">        val template: Template,</span>
<span class="lineno">  65 </span><span class="error">        val model: Any?,</span>
<span class="lineno">  66 </span><span class="error">        etag: String?,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-gson/jvm/src/io/ktor/gson/GsonSupport.kt:70:1</span><span class="message">The class `UnsupportedNullValuesException` is using inheritance, consider using composition instead.

Does `UnsupportedNullValuesException` want to expose the complete interface (`empty public interface`) of `ContentTransformationException` such that `UnsupportedNullValuesException` can be used where `ContentTransformationException` is expected? Indicates __inheritance__.

Does `UnsupportedNullValuesException` want only some/part of the behavior exposed by `ContentTransformationException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  67 </span>    }
<span class="lineno">  68 </span>}
<span class="lineno">  69 </span>
<span class="lineno">  70 </span><span class="error">internal class UnsupportedNullValuesException :</span>
<span class="lineno">  71 </span><span class="error">    ContentTransformationException(&quot;Receiving null values is not supported&quot;)</span>
<span class="lineno">  72 </span>
<span class="lineno">  73 </span>private fun Gson.isExcluded(type: KClass&lt;*&gt;) =
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-html-builder/jvm/src/io/ktor/html/RespondHtml.kt:23:1</span><span class="message">The class `HtmlContent` is using inheritance, consider using composition instead.

Does `HtmlContent` want to expose the complete interface (`writeTo`) of `WriteChannelContent` such that `HtmlContent` can be used where `WriteChannelContent` is expected? Indicates __inheritance__.

Does `HtmlContent` want only some/part of the behavior exposed by `WriteChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  20 </span>    respond(HtmlContent(status, block))
<span class="lineno">  21 </span>}
<span class="lineno">  22 </span>
<span class="lineno">  23 </span><span class="error">/**</span>
<span class="lineno">  24 </span><span class="error"> * Represents an [OutgoingContent] using `kotlinx.html` builder.</span>
<span class="lineno">  25 </span><span class="error"> */</span>
<span class="lineno">  26 </span><span class="error">class HtmlContent(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-html-builder/jvm/src/io/ktor/html/Template.kt:52:1</span><span class="message">The class `PlaceholderItem` is using inheritance, consider using composition instead.

Does `PlaceholderItem` want to expose the complete interface (`apply, invoke`) of `Placeholder` such that `PlaceholderItem` can be used where `Placeholder` is expected? Indicates __inheritance__.

Does `PlaceholderItem` want only some/part of the behavior exposed by `Placeholder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  49 </span>    }
<span class="lineno">  50 </span>}
<span class="lineno">  51 </span>
<span class="lineno">  52 </span><span class="error">/**</span>
<span class="lineno">  53 </span><span class="error"> * Item of a placeholder list when it is expanded</span>
<span class="lineno">  54 </span><span class="error"> */</span>
<span class="lineno">  55 </span><span class="error">class PlaceholderItem&lt;TOuter&gt;(val index: Int, val collection: List&lt;PlaceholderItem&lt;TOuter&gt;&gt;) : Placeholder&lt;TOuter&gt;() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-locations/jvm/src/io/ktor/locations/BackwardCompatibleImpl.kt:42:1</span><span class="message">The class `BackwardCompatibleImpl` is using inheritance, consider using composition instead.

Does `BackwardCompatibleImpl` want to expose the complete interface (`href, href, instantiate, getOrCreateInfo`) of `LocationsImpl` such that `BackwardCompatibleImpl` can be used where `LocationsImpl` is expected? Indicates __inheritance__.

Does `BackwardCompatibleImpl` want only some/part of the behavior exposed by `LocationsImpl`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  39 </span>    abstract fun href(location: Any, builder: URLBuilder)
<span class="lineno">  40 </span>}
<span class="lineno">  41 </span>
<span class="lineno">  42 </span><span class="error">@OptIn(KtorExperimentalLocationsAPI::class)</span>
<span class="lineno">  43 </span><span class="error">internal class BackwardCompatibleImpl(</span>
<span class="lineno">  44 </span><span class="error">    application: Application,</span>
<span class="lineno">  45 </span><span class="error">    routeService: LocationRouteService</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-locations/jvm/src/io/ktor/locations/Locations.kt:162:1</span><span class="message">The class `LocationPropertyInfoImpl` is using inheritance, consider using composition instead.

Does `LocationPropertyInfoImpl` want to expose the complete interface (`toString, equals, hashCode`) of `LocationPropertyInfo` such that `LocationPropertyInfoImpl` can be used where `LocationPropertyInfo` is expected? Indicates __inheritance__.

Does `LocationPropertyInfoImpl` want only some/part of the behavior exposed by `LocationPropertyInfo`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 159 </span>@KtorExperimentalLocationsAPI
<span class="lineno"> 160 </span>class LocationRoutingException(message: String) : Exception(message)
<span class="lineno"> 161 </span>
<span class="lineno"> 162 </span><span class="error">@KtorExperimentalLocationsAPI</span>
<span class="lineno"> 163 </span><span class="error">internal class LocationPropertyInfoImpl(</span>
<span class="lineno"> 164 </span><span class="error">    name: String,</span>
<span class="lineno"> 165 </span><span class="error">    val kGetter: KProperty1.Getter&lt;Any, Any?&gt;,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-mustache/jvm/src/io/ktor/mustache/Mustache.kt:69:5</span><span class="message">The class `MustacheOutgoingContent` is using inheritance, consider using composition instead.

Does `MustacheOutgoingContent` want to expose the complete interface (`writeTo`) of `WriteChannelContent` such that `MustacheOutgoingContent` can be used where `WriteChannelContent` is expected? Indicates __inheritance__.

Does `MustacheOutgoingContent` want only some/part of the behavior exposed by `WriteChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  66 </span>        )
<span class="lineno">  67 </span>    }
<span class="lineno">  68 </span>
<span class="lineno">  69 </span>    <span class="error">/**</span>
<span class="lineno">  70 </span><span class="error">     * Content which is responded when Mustache templates are rendered.</span>
<span class="lineno">  71 </span><span class="error">     *</span>
<span class="lineno">  72 </span><span class="error">     * @param template the compiled [com.github.mustachejava.Mustache] template</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-pebble/jvm/src/io/ktor/pebble/Pebble.kt:70:5</span><span class="message">The class `PebbleOutgoingContent` is using inheritance, consider using composition instead.

Does `PebbleOutgoingContent` want to expose the complete interface (`writeTo`) of `WriteChannelContent` such that `PebbleOutgoingContent` can be used where `WriteChannelContent` is expected? Indicates __inheritance__.

Does `PebbleOutgoingContent` want only some/part of the behavior exposed by `WriteChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  67 </span>        )
<span class="lineno">  68 </span>    }
<span class="lineno">  69 </span>
<span class="lineno">  70 </span>    <span class="error">/**</span>
<span class="lineno">  71 </span><span class="error">     * Content which is responded when Pebble templates are rendered.</span>
<span class="lineno">  72 </span><span class="error">     *</span>
<span class="lineno">  73 </span><span class="error">     * @param template the compiled [com.mitchellbosecke.pebble.template.PebbleTemplate] template</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-server-sessions/jvm/src/io/ktor/sessions/Cache.kt:144:1</span><span class="message">The class `SoftReferenceCache` is using inheritance, consider using composition instead.

Does `SoftReferenceCache` want to expose the complete interface (`invalidateAll, invalidate, invalidate, peek, getOrCompute`) of `ReferenceCache` such that `SoftReferenceCache` can be used where `ReferenceCache` is expected? Indicates __inheritance__.

Does `SoftReferenceCache` want only some/part of the behavior exposed by `ReferenceCache`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 141 </span>internal class CacheSoftReference&lt;out K, V&gt;(override val key: K, value: V, queue: ReferenceQueue&lt;V&gt;) : SoftReference&lt;V&gt;(value, queue), CacheReference&lt;K&gt;
<span class="lineno"> 142 </span>internal class CacheWeakReference&lt;out K, V&gt;(override val key: K, value: V, queue: ReferenceQueue&lt;V&gt;) : WeakReference&lt;V&gt;(value, queue), CacheReference&lt;K&gt;
<span class="lineno"> 143 </span>
<span class="lineno"> 144 </span><span class="error">internal class SoftReferenceCache&lt;K : Any, V : Any&gt;(calc: suspend (K) -&gt; V) : ReferenceCache&lt;K, V, CacheSoftReference&lt;K, V&gt;&gt;(calc, { k, v, q -&gt; CacheSoftReference(k, v, q) })</span>
<span class="lineno"> 145 </span>internal class WeakReferenceCache&lt;K : Any, V : Any&gt;(calc: suspend (K) -&gt; V) : ReferenceCache&lt;K, V, CacheWeakReference&lt;K, V&gt;&gt;(calc, { k, v, q -&gt; CacheWeakReference(k, v, q) })
<span class="lineno"> 146 </span>
<span class="lineno"> 147 </span>internal class BaseTimeoutCache&lt;in K : Any, V : Any&gt;(val timeoutValue: Long,
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-server-sessions/jvm/src/io/ktor/sessions/Cache.kt:145:1</span><span class="message">The class `WeakReferenceCache` is using inheritance, consider using composition instead.

Does `WeakReferenceCache` want to expose the complete interface (`invalidateAll, invalidate, invalidate, peek, getOrCompute`) of `ReferenceCache` such that `WeakReferenceCache` can be used where `ReferenceCache` is expected? Indicates __inheritance__.

Does `WeakReferenceCache` want only some/part of the behavior exposed by `ReferenceCache`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 142 </span>internal class CacheWeakReference&lt;out K, V&gt;(override val key: K, value: V, queue: ReferenceQueue&lt;V&gt;) : WeakReference&lt;V&gt;(value, queue), CacheReference&lt;K&gt;
<span class="lineno"> 143 </span>
<span class="lineno"> 144 </span>internal class SoftReferenceCache&lt;K : Any, V : Any&gt;(calc: suspend (K) -&gt; V) : ReferenceCache&lt;K, V, CacheSoftReference&lt;K, V&gt;&gt;(calc, { k, v, q -&gt; CacheSoftReference(k, v, q) })
<span class="lineno"> 145 </span><span class="error">internal class WeakReferenceCache&lt;K : Any, V : Any&gt;(calc: suspend (K) -&gt; V) : ReferenceCache&lt;K, V, CacheWeakReference&lt;K, V&gt;&gt;(calc, { k, v, q -&gt; CacheWeakReference(k, v, q) })</span>
<span class="lineno"> 146 </span>
<span class="lineno"> 147 </span>internal class BaseTimeoutCache&lt;in K : Any, V : Any&gt;(val timeoutValue: Long,
<span class="lineno"> 148 </span>                                                     val touchOnGet: Boolean,
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-server-sessions/jvm/src/io/ktor/sessions/Cache.kt:222:1</span><span class="message">The class `KeyState` is using inheritance, consider using composition instead.

Does `KeyState` want to expose the complete interface (`empty public interface`) of `ListElement` such that `KeyState` can be used where `ListElement` is expected? Indicates __inheritance__.

Does `KeyState` want only some/part of the behavior exposed by `ListElement`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 219 </span>    }
<span class="lineno"> 220 </span>}
<span class="lineno"> 221 </span>
<span class="lineno"> 222 </span><span class="error">private class KeyState&lt;K&gt;(key: K, val timeout: Long) : ListElement&lt;KeyState&lt;K&gt;&gt;() {</span>
<span class="lineno"> 223 </span><span class="error">    val key: WeakReference&lt;K&gt; = WeakReference(key)</span>
<span class="lineno"> 224 </span><span class="error">    var lastAccess = System.currentTimeMillis()</span>
<span class="lineno"> 225 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-thymeleaf/jvm/src/io/ktor/thymeleaf/Thymeleaf.kt:70:5</span><span class="message">The class `ThymeleafOutgoingContent` is using inheritance, consider using composition instead.

Does `ThymeleafOutgoingContent` want to expose the complete interface (`writeTo`) of `WriteChannelContent` such that `ThymeleafOutgoingContent` can be used where `WriteChannelContent` is expected? Indicates __inheritance__.

Does `ThymeleafOutgoingContent` want only some/part of the behavior exposed by `WriteChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  67 </span>        )
<span class="lineno">  68 </span>    }
<span class="lineno">  69 </span>
<span class="lineno">  70 </span>    <span class="error">private class ThymeleafOutgoingContent(</span>
<span class="lineno">  71 </span><span class="error">        val engine: TemplateEngine,</span>
<span class="lineno">  72 </span><span class="error">        val template: String,</span>
<span class="lineno">  73 </span><span class="error">        val model: Map&lt;String, Any&gt;,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-velocity/jvm/src/io/ktor/velocity/Velocity.kt:68:5</span><span class="message">The class `VelocityOutgoingContent` is using inheritance, consider using composition instead.

Does `VelocityOutgoingContent` want to expose the complete interface (`writeTo`) of `WriteChannelContent` such that `VelocityOutgoingContent` can be used where `WriteChannelContent` is expected? Indicates __inheritance__.

Does `VelocityOutgoingContent` want only some/part of the behavior exposed by `WriteChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  65 </span>        )
<span class="lineno">  66 </span>    }
<span class="lineno">  67 </span>
<span class="lineno">  68 </span>    <span class="error">private class VelocityOutgoingContent(</span>
<span class="lineno">  69 </span><span class="error">        val template: Template,</span>
<span class="lineno">  70 </span><span class="error">        val model: Map&lt;String, Any&gt;,</span>
<span class="lineno">  71 </span><span class="error">        etag: String?,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-webjars/jvm/src/io/ktor/webjars/Webjars.kt:124:1</span><span class="message">The class `InputStreamContent` is using inheritance, consider using composition instead.

Does `InputStreamContent` want to expose the complete interface (`readFrom, readFrom`) of `ReadChannelContent` such that `InputStreamContent` can be used where `ReadChannelContent` is expected? Indicates __inheritance__.

Does `InputStreamContent` want only some/part of the behavior exposed by `ReadChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 121 </span>
<span class="lineno"> 122 </span>}
<span class="lineno"> 123 </span>
<span class="lineno"> 124 </span><span class="error">private class InputStreamContent(</span>
<span class="lineno"> 125 </span><span class="error">    val input: InputStream,</span>
<span class="lineno"> 126 </span><span class="error">    override val contentType: ContentType,</span>
<span class="lineno"> 127 </span><span class="error">    lastModified: GMTDate</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-websockets/jvm/src/io/ktor/websocket/Routing.kt:206:1</span><span class="message">The class `WebSocketProtocolsSelector` is using inheritance, consider using composition instead.

Does `WebSocketProtocolsSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `WebSocketProtocolsSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `WebSocketProtocolsSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 203 </span>    }
<span class="lineno"> 204 </span>}
<span class="lineno"> 205 </span>
<span class="lineno"> 206 </span><span class="error">private class WebSocketProtocolsSelector(</span>
<span class="lineno"> 207 </span><span class="error">    val requiredProtocol: String</span>
<span class="lineno"> 208 </span><span class="error">) : RouteSelector(RouteSelectorEvaluation.qualityConstant) {</span>
<span class="lineno"> 209 </span><span class="error">    override fun evaluate(context: RoutingResolveContext, segmentIndex: Int): RouteSelectorEvaluation {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-features/ktor-websockets/jvm/src/io/ktor/websocket/WebSocketUpgrade.kt:17:1</span><span class="message">The class `WebSocketUpgrade` is using inheritance, consider using composition instead.

Does `WebSocketUpgrade` want to expose the complete interface (`upgrade`) of `ProtocolUpgrade` such that `WebSocketUpgrade` can be used where `ProtocolUpgrade` is expected? Indicates __inheritance__.

Does `WebSocketUpgrade` want only some/part of the behavior exposed by `ProtocolUpgrade`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  14 </span>import io.ktor.utils.io.*
<span class="lineno">  15 </span>import kotlin.coroutines.*
<span class="lineno">  16 </span>
<span class="lineno">  17 </span><span class="error">/**</span>
<span class="lineno">  18 </span><span class="error"> * An [OutgoingContent] response object that could be used to `respond()`: it will cause application engine to</span>
<span class="lineno">  19 </span><span class="error"> * perform HTTP upgrade and start websocket RAW session.</span>
<span class="lineno">  20 </span><span class="error"> *</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/CacheControl.kt:29:5</span><span class="message">The class `NoCache` is using inheritance, consider using composition instead.

Does `NoCache` want to expose the complete interface (`empty public interface`) of `CacheControl` such that `NoCache` can be used where `CacheControl` is expected? Indicates __inheritance__.

Does `NoCache` want only some/part of the behavior exposed by `CacheControl`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  26 </span>        Private(&quot;private&quot;)
<span class="lineno">  27 </span>    }
<span class="lineno">  28 </span>
<span class="lineno">  29 </span>    <span class="error">/**</span>
<span class="lineno">  30 </span><span class="error">     * Represents a no-cache cache control value</span>
<span class="lineno">  31 </span><span class="error">     */</span>
<span class="lineno">  32 </span><span class="error">    class NoCache(visibility: Visibility?) : CacheControl(visibility) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/CacheControl.kt:40:5</span><span class="message">The class `NoStore` is using inheritance, consider using composition instead.

Does `NoStore` want to expose the complete interface (`empty public interface`) of `CacheControl` such that `NoStore` can be used where `CacheControl` is expected? Indicates __inheritance__.

Does `NoStore` want only some/part of the behavior exposed by `CacheControl`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  37 </span>        }
<span class="lineno">  38 </span>    }
<span class="lineno">  39 </span>
<span class="lineno">  40 </span>    <span class="error">/**</span>
<span class="lineno">  41 </span><span class="error">     * Represents a no-store cache control value</span>
<span class="lineno">  42 </span><span class="error">     */</span>
<span class="lineno">  43 </span><span class="error">    class NoStore(visibility: Visibility?) : CacheControl(visibility) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/CacheControl.kt:51:5</span><span class="message">The class `MaxAge` is using inheritance, consider using composition instead.

Does `MaxAge` want to expose the complete interface (`empty public interface`) of `CacheControl` such that `MaxAge` can be used where `CacheControl` is expected? Indicates __inheritance__.

Does `MaxAge` want only some/part of the behavior exposed by `CacheControl`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  48 </span>        }
<span class="lineno">  49 </span>    }
<span class="lineno">  50 </span>
<span class="lineno">  51 </span>    <span class="error">/**</span>
<span class="lineno">  52 </span><span class="error">     * Represents a cache control value with the specified max ages and re-validation strategies</span>
<span class="lineno">  53 </span><span class="error">     * @property maxAgeSeconds max-age in seconds</span>
<span class="lineno">  54 </span><span class="error">     * @property proxyMaxAgeSeconds max-age in seconds for caching proxies</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/ContentDisposition.kt:7:1</span><span class="message">The class `ContentDisposition` is using inheritance, consider using composition instead.

Does `ContentDisposition` want to expose the complete interface (`toString, parameter`) of `HeaderValueWithParameters` such that `ContentDisposition` can be used where `HeaderValueWithParameters` is expected? Indicates __inheritance__.

Does `ContentDisposition` want only some/part of the behavior exposed by `HeaderValueWithParameters`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>
<span class="lineno">   5 </span>package io.ktor.http
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">/**</span>
<span class="lineno">   8 </span><span class="error"> * Represents `Content-Disposition` header value</span>
<span class="lineno">   9 </span><span class="error"> */</span>
<span class="lineno">  10 </span><span class="error">class ContentDisposition(disposition: String, parameters: List&lt;HeaderValueParam&gt; = emptyList()) :</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/ContentTypes.kt:9:1</span><span class="message">The class `ContentType` is using inheritance, consider using composition instead.

Does `ContentType` want to expose the complete interface (`toString, parameter`) of `HeaderValueWithParameters` such that `ContentType` can be used where `HeaderValueWithParameters` is expected? Indicates __inheritance__.

Does `ContentType` want only some/part of the behavior exposed by `HeaderValueWithParameters`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>
<span class="lineno">   7 </span>import io.ktor.utils.io.charsets.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">/**</span>
<span class="lineno">  10 </span><span class="error"> * Represents a value for a `Content-Type` header.</span>
<span class="lineno">  11 </span><span class="error"> * @property contentType represents a type part of the media type.</span>
<span class="lineno">  12 </span><span class="error"> * @property contentSubtype represents a subtype part of the media type.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/Headers.kt:28:1</span><span class="message">The class `HeadersBuilder` is using inheritance, consider using composition instead.

Does `HeadersBuilder` want to expose the complete interface (`build, clear, remove, removeKeysWithNoEntries, remove, appendMissing, appendAll, appendMissing, appendAll, append, get, set, entries, isEmpty, names, contains, contains, getAll`) of `StringValuesBuilder` such that `HeadersBuilder` can be used where `StringValuesBuilder` is expected? Indicates __inheritance__.

Does `HeadersBuilder` want only some/part of the behavior exposed by `StringValuesBuilder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  25 </span>    }
<span class="lineno">  26 </span>}
<span class="lineno">  27 </span>
<span class="lineno">  28 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  29 </span><span class="error">class HeadersBuilder(size: Int = 8) : StringValuesBuilder(true, size) {</span>
<span class="lineno">  30 </span><span class="error">    override fun build(): Headers {</span>
<span class="lineno">  31 </span><span class="error">        require(!built) { &quot;HeadersBuilder can only build a single Headers instance&quot; }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/LinkHeader.kt:7:1</span><span class="message">The class `LinkHeader` is using inheritance, consider using composition instead.

Does `LinkHeader` want to expose the complete interface (`toString, parameter`) of `HeaderValueWithParameters` such that `LinkHeader` can be used where `HeaderValueWithParameters` is expected? Indicates __inheritance__.

Does `LinkHeader` want only some/part of the behavior exposed by `HeaderValueWithParameters`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>
<span class="lineno">   5 </span>package io.ktor.http
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">/**</span>
<span class="lineno">   8 </span><span class="error"> * Represents a `Link` header value as per RFC 5988</span>
<span class="lineno">   9 </span><span class="error"> */</span>
<span class="lineno">  10 </span><span class="error">class LinkHeader(uri: String, params: List&lt;HeaderValueParam&gt;) : HeaderValueWithParameters(&quot;&lt;$uri&gt;&quot;, params) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/Parameters.kt:29:1</span><span class="message">The class `ParametersBuilder` is using inheritance, consider using composition instead.

Does `ParametersBuilder` want to expose the complete interface (`build, clear, remove, removeKeysWithNoEntries, remove, appendMissing, appendAll, appendMissing, appendAll, append, get, set, entries, isEmpty, names, contains, contains, getAll`) of `StringValuesBuilder` such that `ParametersBuilder` can be used where `StringValuesBuilder` is expected? Indicates __inheritance__.

Does `ParametersBuilder` want only some/part of the behavior exposed by `StringValuesBuilder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  26 </span>
<span class="lineno">  27 </span>}
<span class="lineno">  28 </span>
<span class="lineno">  29 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  30 </span><span class="error">class ParametersBuilder(size: Int = 8) : StringValuesBuilder(true, size) {</span>
<span class="lineno">  31 </span><span class="error">    override fun build(): Parameters {</span>
<span class="lineno">  32 </span><span class="error">        require(!built) { &quot;ParametersBuilder can only build a single Parameters instance&quot; }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/Ranges.kt:30:5</span><span class="message">The class `Bounded` is using inheritance, consider using composition instead.

Does `Bounded` want to expose the complete interface (`empty public interface`) of `ContentRange` such that `Bounded` can be used where `ContentRange` is expected? Indicates __inheritance__.

Does `Bounded` want only some/part of the behavior exposed by `ContentRange`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  27 </span> * Represents a `Range` header's particular range
<span class="lineno">  28 </span> */
<span class="lineno">  29 </span>sealed class ContentRange {
<span class="lineno">  30 </span>    <span class="error">/**</span>
<span class="lineno">  31 </span><span class="error">     * Represents a `Content-Range` bounded from both sides</span>
<span class="lineno">  32 </span><span class="error">     * @property from index from which the content should begin</span>
<span class="lineno">  33 </span><span class="error">     * @property to the last index the content should end at (inclusive)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/Ranges.kt:39:5</span><span class="message">The class `TailFrom` is using inheritance, consider using composition instead.

Does `TailFrom` want to expose the complete interface (`empty public interface`) of `ContentRange` such that `TailFrom` can be used where `ContentRange` is expected? Indicates __inheritance__.

Does `TailFrom` want only some/part of the behavior exposed by `ContentRange`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  36 </span>        override fun toString(): String = &quot;$from-$to&quot;
<span class="lineno">  37 </span>    }
<span class="lineno">  38 </span>
<span class="lineno">  39 </span>    <span class="error">/**</span>
<span class="lineno">  40 </span><span class="error">     * Represents a `Content-Range` bounded at the beginning (skip first bytes, show tail)</span>
<span class="lineno">  41 </span><span class="error">     * @property from index from which the content should begin</span>
<span class="lineno">  42 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/Ranges.kt:47:5</span><span class="message">The class `Suffix` is using inheritance, consider using composition instead.

Does `Suffix` want to expose the complete interface (`empty public interface`) of `ContentRange` such that `Suffix` can be used where `ContentRange` is expected? Indicates __inheritance__.

Does `Suffix` want only some/part of the behavior exposed by `ContentRange`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  44 </span>        override fun toString(): String = &quot;$from-&quot;
<span class="lineno">  45 </span>    }
<span class="lineno">  46 </span>
<span class="lineno">  47 </span>    <span class="error">/**</span>
<span class="lineno">  48 </span><span class="error">     * Represents a `Content-Range` bounded by tail size</span>
<span class="lineno">  49 </span><span class="error">     * @property lastCount number of tail bytes</span>
<span class="lineno">  50 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/auth/HttpAuthHeader.kt:60:5</span><span class="message">The class `Single` is using inheritance, consider using composition instead.

Does `Single` want to expose the complete interface (`toString, render, render`) of `HttpAuthHeader` such that `Single` can be used where `HttpAuthHeader` is expected? Indicates __inheritance__.

Does `Single` want only some/part of the behavior exposed by `HttpAuthHeader`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  57 </span>        require(authScheme.matches(token68Pattern)) { &quot;invalid authScheme value: it should be token&quot; }
<span class="lineno">  58 </span>    }
<span class="lineno">  59 </span>
<span class="lineno">  60 </span>    <span class="error">/**</span>
<span class="lineno">  61 </span><span class="error">     * Describes an authentication header that is represented by a single [blob].</span>
<span class="lineno">  62 </span><span class="error">     * @property blob contains single token 68, should consist from digits, letters and one of the following: `-._~+/`</span>
<span class="lineno">  63 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/auth/HttpAuthHeader.kt:83:5</span><span class="message">The class `Parameterized` is using inheritance, consider using composition instead.

Does `Parameterized` want to expose the complete interface (`toString, render, render`) of `HttpAuthHeader` such that `Parameterized` can be used where `HttpAuthHeader` is expected? Indicates __inheritance__.

Does `Parameterized` want only some/part of the behavior exposed by `HttpAuthHeader`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  80 </span>        }
<span class="lineno">  81 </span>    }
<span class="lineno">  82 </span>
<span class="lineno">  83 </span>    <span class="error">/**</span>
<span class="lineno">  84 </span><span class="error">     * Describes a parameterized authentication header that is represented by a set of [parameters] encoded with [encoding].</span>
<span class="lineno">  85 </span><span class="error">     * @property parameters a list of auth parameters</span>
<span class="lineno">  86 </span><span class="error">     * @property encoding parameters encoding method, one of [HeaderValueEncoding]</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/content/ByteArrayContent.kt:9:1</span><span class="message">The class `ByteArrayContent` is using inheritance, consider using composition instead.

Does `ByteArrayContent` want to expose the complete interface (`bytes`) of `ByteArrayContent` such that `ByteArrayContent` can be used where `ByteArrayContent` is expected? Indicates __inheritance__.

Does `ByteArrayContent` want only some/part of the behavior exposed by `ByteArrayContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>
<span class="lineno">   7 </span>import io.ktor.http.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">/**</span>
<span class="lineno">  10 </span><span class="error"> * Implementation of the [OutgoingContent.ByteArrayContent] for sending array of bytes</span>
<span class="lineno">  11 </span><span class="error"> */</span>
<span class="lineno">  12 </span><span class="error">class ByteArrayContent(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/content/Multipart.kt:16:5</span><span class="message">The class `FormItem` is using inheritance, consider using composition instead.

Does `FormItem` want to expose the complete interface (`empty public interface`) of `PartData` such that `FormItem` can be used where `PartData` is expected? Indicates __inheritance__.

Does `FormItem` want only some/part of the behavior exposed by `PartData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span> * @property headers of this part, could be inaccurate on some engines
<span class="lineno">  14 </span> */
<span class="lineno">  15 </span>sealed class PartData(val dispose: () -&gt; Unit, val headers: Headers) {
<span class="lineno">  16 </span>    <span class="error">/**</span>
<span class="lineno">  17 </span><span class="error">     * Represents a multipart form item</span>
<span class="lineno">  18 </span><span class="error">     * @property value of this field</span>
<span class="lineno">  19 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/content/Multipart.kt:22:5</span><span class="message">The class `FileItem` is using inheritance, consider using composition instead.

Does `FileItem` want to expose the complete interface (`empty public interface`) of `PartData` such that `FileItem` can be used where `PartData` is expected? Indicates __inheritance__.

Does `FileItem` want only some/part of the behavior exposed by `PartData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  19 </span>     */
<span class="lineno">  20 </span>    class FormItem(val value: String, dispose: () -&gt; Unit, partHeaders: Headers) : PartData(dispose, partHeaders)
<span class="lineno">  21 </span>
<span class="lineno">  22 </span>    <span class="error">/**</span>
<span class="lineno">  23 </span><span class="error">     * Represents a file item</span>
<span class="lineno">  24 </span><span class="error">     * @property provider of content bytes</span>
<span class="lineno">  25 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/content/Multipart.kt:34:5</span><span class="message">The class `BinaryItem` is using inheritance, consider using composition instead.

Does `BinaryItem` want to expose the complete interface (`empty public interface`) of `PartData` such that `BinaryItem` can be used where `PartData` is expected? Indicates __inheritance__.

Does `BinaryItem` want only some/part of the behavior exposed by `PartData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  31 </span>        val originalFileName: String? = contentDisposition?.parameter(ContentDisposition.Parameters.FileName)
<span class="lineno">  32 </span>    }
<span class="lineno">  33 </span>
<span class="lineno">  34 </span>    <span class="error">/**</span>
<span class="lineno">  35 </span><span class="error">     * Represents a binary item</span>
<span class="lineno">  36 </span><span class="error">     * @property provider of content bytes</span>
<span class="lineno">  37 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/content/OutgoingContent.kt:59:5</span><span class="message">The class `NoContent` is using inheritance, consider using composition instead.

Does `NoContent` want to expose the complete interface (`setProperty, getProperty`) of `OutgoingContent` such that `NoContent` can be used where `OutgoingContent` is expected? Indicates __inheritance__.

Does `NoContent` want only some/part of the behavior exposed by `OutgoingContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  56 </span>        }
<span class="lineno">  57 </span>    }
<span class="lineno">  58 </span>
<span class="lineno">  59 </span>    <span class="error">/**</span>
<span class="lineno">  60 </span><span class="error">     * Variant of a [OutgoingContent] without a payload</span>
<span class="lineno">  61 </span><span class="error">     */</span>
<span class="lineno">  62 </span><span class="error">    abstract class NoContent : OutgoingContent()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/content/OutgoingContent.kt:64:5</span><span class="message">The class `ReadChannelContent` is using inheritance, consider using composition instead.

Does `ReadChannelContent` want to expose the complete interface (`setProperty, getProperty`) of `OutgoingContent` such that `ReadChannelContent` can be used where `OutgoingContent` is expected? Indicates __inheritance__.

Does `ReadChannelContent` want only some/part of the behavior exposed by `OutgoingContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  61 </span>     */
<span class="lineno">  62 </span>    abstract class NoContent : OutgoingContent()
<span class="lineno">  63 </span>
<span class="lineno">  64 </span>    <span class="error">/**</span>
<span class="lineno">  65 </span><span class="error">     * Variant of a [OutgoingContent] with payload read from [ByteReadChannel]</span>
<span class="lineno">  66 </span><span class="error">     *</span>
<span class="lineno">  67 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/content/OutgoingContent.kt:86:5</span><span class="message">The class `WriteChannelContent` is using inheritance, consider using composition instead.

Does `WriteChannelContent` want to expose the complete interface (`setProperty, getProperty`) of `OutgoingContent` such that `WriteChannelContent` can be used where `OutgoingContent` is expected? Indicates __inheritance__.

Does `WriteChannelContent` want only some/part of the behavior exposed by `OutgoingContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  83 </span>            }.channel
<span class="lineno">  84 </span>    }
<span class="lineno">  85 </span>
<span class="lineno">  86 </span>    <span class="error">/**</span>
<span class="lineno">  87 </span><span class="error">     * Variant of a [OutgoingContent] with payload written to [ByteWriteChannel]</span>
<span class="lineno">  88 </span><span class="error">     */</span>
<span class="lineno">  89 </span><span class="error">    abstract class WriteChannelContent : OutgoingContent() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/content/OutgoingContent.kt:96:5</span><span class="message">The class `ByteArrayContent` is using inheritance, consider using composition instead.

Does `ByteArrayContent` want to expose the complete interface (`setProperty, getProperty`) of `OutgoingContent` such that `ByteArrayContent` can be used where `OutgoingContent` is expected? Indicates __inheritance__.

Does `ByteArrayContent` want only some/part of the behavior exposed by `OutgoingContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  93 </span>        abstract suspend fun writeTo(channel: ByteWriteChannel)
<span class="lineno">  94 </span>    }
<span class="lineno">  95 </span>
<span class="lineno">  96 </span>    <span class="error">/**</span>
<span class="lineno">  97 </span><span class="error">     * Variant of a [OutgoingContent] with payload represented as [ByteArray]</span>
<span class="lineno">  98 </span><span class="error">     */</span>
<span class="lineno">  99 </span><span class="error">    abstract class ByteArrayContent : OutgoingContent() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/content/OutgoingContent.kt:106:5</span><span class="message">The class `ProtocolUpgrade` is using inheritance, consider using composition instead.

Does `ProtocolUpgrade` want to expose the complete interface (`setProperty, getProperty`) of `OutgoingContent` such that `ProtocolUpgrade` can be used where `OutgoingContent` is expected? Indicates __inheritance__.

Does `ProtocolUpgrade` want only some/part of the behavior exposed by `OutgoingContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 103 </span>        abstract fun bytes(): ByteArray
<span class="lineno"> 104 </span>    }
<span class="lineno"> 105 </span>
<span class="lineno"> 106 </span>    <span class="error">/**</span>
<span class="lineno"> 107 </span><span class="error">     * Variant of a [OutgoingContent] for upgrading an HTTP connection</span>
<span class="lineno"> 108 </span><span class="error">     */</span>
<span class="lineno"> 109 </span><span class="error">    abstract class ProtocolUpgrade : OutgoingContent() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/content/TextContent.kt:11:1</span><span class="message">The class `TextContent` is using inheritance, consider using composition instead.

Does `TextContent` want to expose the complete interface (`bytes`) of `ByteArrayContent` such that `TextContent` can be used where `ByteArrayContent` is expected? Indicates __inheritance__.

Does `TextContent` want only some/part of the behavior exposed by `ByteArrayContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.utils.io.charsets.*
<span class="lineno">   9 </span>import io.ktor.utils.io.core.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * Represents a text content that could be sent</span>
<span class="lineno">  13 </span><span class="error"> * @property text to be sent</span>
<span class="lineno">  14 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/parsing/ParserDsl.kt:17:1</span><span class="message">The class `StringGrammar` is using inheritance, consider using composition instead.

Does `StringGrammar` want to expose the complete interface (`empty public interface`) of `Grammar` such that `StringGrammar` can be used where `Grammar` is expected? Indicates __inheritance__.

Does `StringGrammar` want only some/part of the behavior exposed by `Grammar`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  14 </span>    val grammar: Grammar
<span class="lineno">  15 </span>}
<span class="lineno">  16 </span>
<span class="lineno">  17 </span><span class="error">internal class StringGrammar(val value: String) : Grammar()</span>
<span class="lineno">  18 </span>internal class AnyOfGrammar(val value: String) : Grammar()
<span class="lineno">  19 </span>internal class RangeGrammar(val from: Char, val to: Char) : Grammar()
<span class="lineno">  20 </span>internal class RawGrammar(val value: String) : Grammar()
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/parsing/ParserDsl.kt:18:1</span><span class="message">The class `AnyOfGrammar` is using inheritance, consider using composition instead.

Does `AnyOfGrammar` want to expose the complete interface (`empty public interface`) of `Grammar` such that `AnyOfGrammar` can be used where `Grammar` is expected? Indicates __inheritance__.

Does `AnyOfGrammar` want only some/part of the behavior exposed by `Grammar`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>}
<span class="lineno">  16 </span>
<span class="lineno">  17 </span>internal class StringGrammar(val value: String) : Grammar()
<span class="lineno">  18 </span><span class="error">internal class AnyOfGrammar(val value: String) : Grammar()</span>
<span class="lineno">  19 </span>internal class RangeGrammar(val from: Char, val to: Char) : Grammar()
<span class="lineno">  20 </span>internal class RawGrammar(val value: String) : Grammar()
<span class="lineno">  21 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/parsing/ParserDsl.kt:19:1</span><span class="message">The class `RangeGrammar` is using inheritance, consider using composition instead.

Does `RangeGrammar` want to expose the complete interface (`empty public interface`) of `Grammar` such that `RangeGrammar` can be used where `Grammar` is expected? Indicates __inheritance__.

Does `RangeGrammar` want only some/part of the behavior exposed by `Grammar`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>
<span class="lineno">  17 </span>internal class StringGrammar(val value: String) : Grammar()
<span class="lineno">  18 </span>internal class AnyOfGrammar(val value: String) : Grammar()
<span class="lineno">  19 </span><span class="error">internal class RangeGrammar(val from: Char, val to: Char) : Grammar()</span>
<span class="lineno">  20 </span>internal class RawGrammar(val value: String) : Grammar()
<span class="lineno">  21 </span>
<span class="lineno">  22 </span>internal class NamedGrammar(val name: String, val grammar: Grammar) : Grammar()
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/parsing/ParserDsl.kt:20:1</span><span class="message">The class `RawGrammar` is using inheritance, consider using composition instead.

Does `RawGrammar` want to expose the complete interface (`empty public interface`) of `Grammar` such that `RawGrammar` can be used where `Grammar` is expected? Indicates __inheritance__.

Does `RawGrammar` want only some/part of the behavior exposed by `Grammar`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  17 </span>internal class StringGrammar(val value: String) : Grammar()
<span class="lineno">  18 </span>internal class AnyOfGrammar(val value: String) : Grammar()
<span class="lineno">  19 </span>internal class RangeGrammar(val from: Char, val to: Char) : Grammar()
<span class="lineno">  20 </span><span class="error">internal class RawGrammar(val value: String) : Grammar()</span>
<span class="lineno">  21 </span>
<span class="lineno">  22 </span>internal class NamedGrammar(val name: String, val grammar: Grammar) : Grammar()
<span class="lineno">  23 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/parsing/ParserDsl.kt:22:1</span><span class="message">The class `NamedGrammar` is using inheritance, consider using composition instead.

Does `NamedGrammar` want to expose the complete interface (`empty public interface`) of `Grammar` such that `NamedGrammar` can be used where `Grammar` is expected? Indicates __inheritance__.

Does `NamedGrammar` want only some/part of the behavior exposed by `Grammar`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  19 </span>internal class RangeGrammar(val from: Char, val to: Char) : Grammar()
<span class="lineno">  20 </span>internal class RawGrammar(val value: String) : Grammar()
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">internal class NamedGrammar(val name: String, val grammar: Grammar) : Grammar()</span>
<span class="lineno">  23 </span>
<span class="lineno">  24 </span>internal class MaybeGrammar(override val grammar: Grammar) : Grammar(), SimpleGrammar
<span class="lineno">  25 </span>internal class ManyGrammar(override val grammar: Grammar) : Grammar(), SimpleGrammar
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/parsing/ParserDsl.kt:24:1</span><span class="message">The class `MaybeGrammar` is using inheritance, consider using composition instead.

Does `MaybeGrammar` want to expose the complete interface (`empty public interface`) of `Grammar` such that `MaybeGrammar` can be used where `Grammar` is expected? Indicates __inheritance__.

Does `MaybeGrammar` want only some/part of the behavior exposed by `Grammar`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  21 </span>
<span class="lineno">  22 </span>internal class NamedGrammar(val name: String, val grammar: Grammar) : Grammar()
<span class="lineno">  23 </span>
<span class="lineno">  24 </span><span class="error">internal class MaybeGrammar(override val grammar: Grammar) : Grammar(), SimpleGrammar</span>
<span class="lineno">  25 </span>internal class ManyGrammar(override val grammar: Grammar) : Grammar(), SimpleGrammar
<span class="lineno">  26 </span>internal class AtLeastOne(override val grammar: Grammar) : Grammar(), SimpleGrammar
<span class="lineno">  27 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/parsing/ParserDsl.kt:25:1</span><span class="message">The class `ManyGrammar` is using inheritance, consider using composition instead.

Does `ManyGrammar` want to expose the complete interface (`empty public interface`) of `Grammar` such that `ManyGrammar` can be used where `Grammar` is expected? Indicates __inheritance__.

Does `ManyGrammar` want only some/part of the behavior exposed by `Grammar`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  22 </span>internal class NamedGrammar(val name: String, val grammar: Grammar) : Grammar()
<span class="lineno">  23 </span>
<span class="lineno">  24 </span>internal class MaybeGrammar(override val grammar: Grammar) : Grammar(), SimpleGrammar
<span class="lineno">  25 </span><span class="error">internal class ManyGrammar(override val grammar: Grammar) : Grammar(), SimpleGrammar</span>
<span class="lineno">  26 </span>internal class AtLeastOne(override val grammar: Grammar) : Grammar(), SimpleGrammar
<span class="lineno">  27 </span>
<span class="lineno">  28 </span>internal class SequenceGrammar(sourceGrammars: List&lt;Grammar&gt;) : Grammar(), ComplexGrammar {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/parsing/ParserDsl.kt:26:1</span><span class="message">The class `AtLeastOne` is using inheritance, consider using composition instead.

Does `AtLeastOne` want to expose the complete interface (`empty public interface`) of `Grammar` such that `AtLeastOne` can be used where `Grammar` is expected? Indicates __inheritance__.

Does `AtLeastOne` want only some/part of the behavior exposed by `Grammar`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  23 </span>
<span class="lineno">  24 </span>internal class MaybeGrammar(override val grammar: Grammar) : Grammar(), SimpleGrammar
<span class="lineno">  25 </span>internal class ManyGrammar(override val grammar: Grammar) : Grammar(), SimpleGrammar
<span class="lineno">  26 </span><span class="error">internal class AtLeastOne(override val grammar: Grammar) : Grammar(), SimpleGrammar</span>
<span class="lineno">  27 </span>
<span class="lineno">  28 </span>internal class SequenceGrammar(sourceGrammars: List&lt;Grammar&gt;) : Grammar(), ComplexGrammar {
<span class="lineno">  29 </span>    override val grammars: List&lt;Grammar&gt; = sourceGrammars.flatten&lt;SequenceGrammar&gt;()
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/parsing/ParserDsl.kt:28:1</span><span class="message">The class `SequenceGrammar` is using inheritance, consider using composition instead.

Does `SequenceGrammar` want to expose the complete interface (`empty public interface`) of `Grammar` such that `SequenceGrammar` can be used where `Grammar` is expected? Indicates __inheritance__.

Does `SequenceGrammar` want only some/part of the behavior exposed by `Grammar`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  25 </span>internal class ManyGrammar(override val grammar: Grammar) : Grammar(), SimpleGrammar
<span class="lineno">  26 </span>internal class AtLeastOne(override val grammar: Grammar) : Grammar(), SimpleGrammar
<span class="lineno">  27 </span>
<span class="lineno">  28 </span><span class="error">internal class SequenceGrammar(sourceGrammars: List&lt;Grammar&gt;) : Grammar(), ComplexGrammar {</span>
<span class="lineno">  29 </span><span class="error">    override val grammars: List&lt;Grammar&gt; = sourceGrammars.flatten&lt;SequenceGrammar&gt;()</span>
<span class="lineno">  30 </span><span class="error">}</span>
<span class="lineno">  31 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/common/src/io/ktor/http/parsing/ParserDsl.kt:32:1</span><span class="message">The class `OrGrammar` is using inheritance, consider using composition instead.

Does `OrGrammar` want to expose the complete interface (`empty public interface`) of `Grammar` such that `OrGrammar` can be used where `Grammar` is expected? Indicates __inheritance__.

Does `OrGrammar` want only some/part of the behavior exposed by `Grammar`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  29 </span>    override val grammars: List&lt;Grammar&gt; = sourceGrammars.flatten&lt;SequenceGrammar&gt;()
<span class="lineno">  30 </span>}
<span class="lineno">  31 </span>
<span class="lineno">  32 </span><span class="error">internal class OrGrammar(sourceGrammars: List&lt;Grammar&gt;) : Grammar(), ComplexGrammar {</span>
<span class="lineno">  33 </span><span class="error">    override val grammars: List&lt;Grammar&gt; = sourceGrammars.flatten&lt;OrGrammar&gt;()</span>
<span class="lineno">  34 </span><span class="error">}</span>
<span class="lineno">  35 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/jvm/src/io/ktor/http/content/ChannelWriterContent.kt:11:1</span><span class="message">The class `ChannelWriterContent` is using inheritance, consider using composition instead.

Does `ChannelWriterContent` want to expose the complete interface (`writeTo`) of `WriteChannelContent` such that `ChannelWriterContent` can be used where `WriteChannelContent` is expected? Indicates __inheritance__.

Does `ChannelWriterContent` want only some/part of the behavior exposed by `WriteChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.util.*
<span class="lineno">   9 </span>import io.ktor.utils.io.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * [OutgoingContent] to respond with [ByteWriteChannel].</span>
<span class="lineno">  13 </span><span class="error"> * The stream would be automatically closed after [body] finish.</span>
<span class="lineno">  14 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/jvm/src/io/ktor/http/content/OutputStreamContent.kt:12:1</span><span class="message">The class `OutputStreamContent` is using inheritance, consider using composition instead.

Does `OutputStreamContent` want to expose the complete interface (`writeTo`) of `WriteChannelContent` such that `OutputStreamContent` can be used where `WriteChannelContent` is expected? Indicates __inheritance__.

Does `OutputStreamContent` want only some/part of the behavior exposed by `WriteChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import io.ktor.utils.io.jvm.javaio.*
<span class="lineno">  10 </span>import java.io.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">/**</span>
<span class="lineno">  13 </span><span class="error"> * [OutgoingContent] to respond with [OutputStream].</span>
<span class="lineno">  14 </span><span class="error"> * The stream would be automatically closed after [body] finish.</span>
<span class="lineno">  15 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/jvm/src/io/ktor/http/content/URIFileContent.kt:13:1</span><span class="message">The class `URIFileContent` is using inheritance, consider using composition instead.

Does `URIFileContent` want to expose the complete interface (`readFrom, readFrom`) of `ReadChannelContent` such that `URIFileContent` can be used where `ReadChannelContent` is expected? Indicates __inheritance__.

Does `URIFileContent` want only some/part of the behavior exposed by `ReadChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import io.ktor.utils.io.jvm.javaio.*
<span class="lineno">  11 </span>import java.net.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">/**</span>
<span class="lineno">  14 </span><span class="error"> * Represents a content that is served from the specified [uri]</span>
<span class="lineno">  15 </span><span class="error"> * @property uri that is used as a source</span>
<span class="lineno">  16 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/jvm/src/io/ktor/http/content/WriterContent.kt:12:1</span><span class="message">The class `WriterContent` is using inheritance, consider using composition instead.

Does `WriterContent` want to expose the complete interface (`writeTo`) of `WriteChannelContent` such that `WriterContent` can be used where `WriteChannelContent` is expected? Indicates __inheritance__.

Does `WriterContent` want only some/part of the behavior exposed by `WriteChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import io.ktor.utils.io.*
<span class="lineno">  10 </span>import java.io.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">/**</span>
<span class="lineno">  13 </span><span class="error"> * Represents a content that is produced by [body] function</span>
<span class="lineno">  14 </span><span class="error"> */</span>
<span class="lineno">  15 </span><span class="error">class WriterContent(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/RequestResponse.kt:35:1</span><span class="message">The class `Request` is using inheritance, consider using composition instead.

Does `Request` want to expose the complete interface (`close, release`) of `HttpMessage` such that `Request` can be used where `HttpMessage` is expected? Indicates __inheritance__.

Does `Request` want only some/part of the behavior exposed by `HttpMessage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  32 </span>    }
<span class="lineno">  33 </span>}
<span class="lineno">  34 </span>
<span class="lineno">  35 </span><span class="error">/**</span>
<span class="lineno">  36 </span><span class="error"> * Represents an HTTP request</span>
<span class="lineno">  37 </span><span class="error"> * @property method</span>
<span class="lineno">  38 </span><span class="error"> * @property uri</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/RequestResponse.kt:49:1</span><span class="message">The class `Response` is using inheritance, consider using composition instead.

Does `Response` want to expose the complete interface (`close, release`) of `HttpMessage` such that `Response` can be used where `HttpMessage` is expected? Indicates __inheritance__.

Does `Response` want only some/part of the behavior exposed by `HttpMessage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  46 </span>    builder: CharArrayBuilder
<span class="lineno">  47 </span>) : HttpMessage(headers, builder)
<span class="lineno">  48 </span>
<span class="lineno">  49 </span><span class="error">/**</span>
<span class="lineno">  50 </span><span class="error"> * Represents an HTTP response</span>
<span class="lineno">  51 </span><span class="error"> * @property version</span>
<span class="lineno">  52 </span><span class="error"> * @property status</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/js/src/io/ktor/http/cio/websocket/FrameJs.kt:23:5</span><span class="message">The class `Binary` is using inheritance, consider using composition instead.

Does `Binary` want to expose the complete interface (`copy, toString`) of `Frame` such that `Binary` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Binary` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  20 </span>    actual val data: ByteArray,
<span class="lineno">  21 </span>    actual val disposableHandle: DisposableHandle
<span class="lineno">  22 </span>) {
<span class="lineno">  23 </span>    <span class="error">/**</span>
<span class="lineno">  24 </span><span class="error">     * Represents an application level binary frame.</span>
<span class="lineno">  25 </span><span class="error">     * In a RAW web socket session a big text frame could be fragmented</span>
<span class="lineno">  26 </span><span class="error">     * (separated into several text frames so they have [fin] = false except the last one).</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/js/src/io/ktor/http/cio/websocket/FrameJs.kt:33:5</span><span class="message">The class `Text` is using inheritance, consider using composition instead.

Does `Text` want to expose the complete interface (`copy, toString`) of `Frame` such that `Text` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Text` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  30 </span>        actual constructor(fin: Boolean, packet: ByteReadPacket) : this(fin, packet.readBytes())
<span class="lineno">  31 </span>    }
<span class="lineno">  32 </span>
<span class="lineno">  33 </span>    <span class="error">/**</span>
<span class="lineno">  34 </span><span class="error">     * Represents an application level text frame.</span>
<span class="lineno">  35 </span><span class="error">     * In a RAW web socket session a big text frame could be fragmented</span>
<span class="lineno">  36 </span><span class="error">     * (separated into several text frames so they have [fin] = false except the last one).</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/js/src/io/ktor/http/cio/websocket/FrameJs.kt:46:5</span><span class="message">The class `Close` is using inheritance, consider using composition instead.

Does `Close` want to expose the complete interface (`copy, toString`) of `Frame` such that `Close` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Close` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  43 </span>        actual constructor(fin: Boolean, packet: ByteReadPacket) : this(fin, packet.readBytes())
<span class="lineno">  44 </span>    }
<span class="lineno">  45 </span>
<span class="lineno">  46 </span>    <span class="error">/**</span>
<span class="lineno">  47 </span><span class="error">     * Represents a low-level level close frame. It could be sent to indicate web socket session end.</span>
<span class="lineno">  48 </span><span class="error">     * Usually there is no need to send/handle it unless you have a RAW web socket session.</span>
<span class="lineno">  49 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/js/src/io/ktor/http/cio/websocket/FrameJs.kt:60:5</span><span class="message">The class `Ping` is using inheritance, consider using composition instead.

Does `Ping` want to expose the complete interface (`copy, toString`) of `Frame` such that `Ping` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Ping` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  57 </span>        actual constructor() : this(Empty)
<span class="lineno">  58 </span>    }
<span class="lineno">  59 </span>
<span class="lineno">  60 </span>    <span class="error">/**</span>
<span class="lineno">  61 </span><span class="error">     * Represents a low-level ping frame. Could be sent to test connection (peer should reply with [Pong]).</span>
<span class="lineno">  62 </span><span class="error">     * Usually there is no need to send/handle it unless you have a RAW web socket session.</span>
<span class="lineno">  63 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/js/src/io/ktor/http/cio/websocket/FrameJs.kt:68:5</span><span class="message">The class `Pong` is using inheritance, consider using composition instead.

Does `Pong` want to expose the complete interface (`copy, toString`) of `Frame` such that `Pong` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Pong` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  65 </span>        actual constructor(packet: ByteReadPacket) : this(packet.readBytes())
<span class="lineno">  66 </span>    }
<span class="lineno">  67 </span>
<span class="lineno">  68 </span>    <span class="error">/**</span>
<span class="lineno">  69 </span><span class="error">     * Represents a low-level pong frame. Should be sent in reply to a [Ping] frame.</span>
<span class="lineno">  70 </span><span class="error">     * Usually there is no need to send/handle it unless you have a RAW web socket session.</span>
<span class="lineno">  71 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/Multipart.kt:29:5</span><span class="message">The class `Preamble` is using inheritance, consider using composition instead.

Does `Preamble` want to expose the complete interface (`release`) of `MultipartEvent` such that `Preamble` can be used where `MultipartEvent` is expected? Indicates __inheritance__.

Does `Preamble` want only some/part of the behavior exposed by `MultipartEvent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  26 </span>     */
<span class="lineno">  27 </span>    abstract fun release()
<span class="lineno">  28 </span>
<span class="lineno">  29 </span>    <span class="error">/**</span>
<span class="lineno">  30 </span><span class="error">     * Represents a multipart content preamble. A multipart stream could have at most one preamble.</span>
<span class="lineno">  31 </span><span class="error">     * @property body contains preamble's content</span>
<span class="lineno">  32 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/Multipart.kt:39:5</span><span class="message">The class `MultipartPart` is using inheritance, consider using composition instead.

Does `MultipartPart` want to expose the complete interface (`release`) of `MultipartEvent` such that `MultipartPart` can be used where `MultipartEvent` is expected? Indicates __inheritance__.

Does `MultipartPart` want only some/part of the behavior exposed by `MultipartEvent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  36 </span>        }
<span class="lineno">  37 </span>    }
<span class="lineno">  38 </span>
<span class="lineno">  39 </span>    <span class="error">/**</span>
<span class="lineno">  40 </span><span class="error">     * Represents a multipart part. There could be any number of parts in a multipart stream. Please note that</span>
<span class="lineno">  41 </span><span class="error">     * it is important to consume [body] otherwise multipart parser could get stuck (suspend)</span>
<span class="lineno">  42 </span><span class="error">     * so you will not receive more events.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/Multipart.kt:61:5</span><span class="message">The class `Epilogue` is using inheritance, consider using composition instead.

Does `Epilogue` want to expose the complete interface (`release`) of `MultipartEvent` such that `Epilogue` can be used where `MultipartEvent` is expected? Indicates __inheritance__.

Does `Epilogue` want only some/part of the behavior exposed by `MultipartEvent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  58 </span>        }
<span class="lineno">  59 </span>    }
<span class="lineno">  60 </span>
<span class="lineno">  61 </span>    <span class="error">/**</span>
<span class="lineno">  62 </span><span class="error">     * Represents a multipart content epilogue. A multipart stream could have at most one epilogue.</span>
<span class="lineno">  63 </span><span class="error">     * @property body contains epilogue's content</span>
<span class="lineno">  64 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/internals/WeakTimeoutQueue.kt:124:5</span><span class="message">The class `Cancellable` is using inheritance, consider using composition instead.

Does `Cancellable` want to expose the complete interface (`toString, removeFirstIfIsInstanceOfOrPeekIf, removeFirstIfIsInstanceOf, describeRemoveFirst, removeFirstOrNull, describeRemove, helpRemove, remove, addLastIfPrevAndIf, addLastIfPrev, addLastIf, describeAddLast, addLast, addOneIfEmpty`) of `LockFreeLinkedListNode` such that `Cancellable` can be used where `LockFreeLinkedListNode` is expected? Indicates __inheritance__.

Does `Cancellable` want only some/part of the behavior exposed by `LockFreeLinkedListNode`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 121 </span>        }
<span class="lineno"> 122 </span>    }
<span class="lineno"> 123 </span>
<span class="lineno"> 124 </span>    <span class="error">private abstract class Cancellable(</span>
<span class="lineno"> 125 </span><span class="error">        val deadline: Long</span>
<span class="lineno"> 126 </span><span class="error">    ) : LockFreeLinkedListNode(), Registration {</span>
<span class="lineno"> 127 </span><span class="error">        open val isActive: Boolean</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/internals/WeakTimeoutQueue.kt:137:5</span><span class="message">The class `JobTask` is using inheritance, consider using composition instead.

Does `JobTask` want to expose the complete interface (`dispose, cancel`) of `Cancellable` such that `JobTask` can be used where `Cancellable` is expected? Indicates __inheritance__.

Does `JobTask` want only some/part of the behavior exposed by `Cancellable`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 134 </span>        }
<span class="lineno"> 135 </span>    }
<span class="lineno"> 136 </span>
<span class="lineno"> 137 </span>    <span class="error">private class JobTask(deadline: Long, private val job: Job) : Cancellable(deadline) {</span>
<span class="lineno"> 138 </span><span class="error">        override val isActive: Boolean</span>
<span class="lineno"> 139 </span><span class="error">            get() = super.isActive &amp;&amp; job.isActive</span>
<span class="lineno"> 140 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/websocket/Frame.kt:30:5</span><span class="message">The class `Binary` is using inheritance, consider using composition instead.

Does `Binary` want to expose the complete interface (`copy, toString`) of `Frame` such that `Binary` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Binary` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  27 </span>     */
<span class="lineno">  28 </span>    val buffer: ByteBuffer = ByteBuffer.wrap(data)
<span class="lineno">  29 </span>
<span class="lineno">  30 </span>    <span class="error">/**</span>
<span class="lineno">  31 </span><span class="error">     * Represents an application level binary frame.</span>
<span class="lineno">  32 </span><span class="error">     * In a RAW web socket session a big text frame could be fragmented</span>
<span class="lineno">  33 </span><span class="error">     * (separated into several text frames so they have [fin] = false except the last one).</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/websocket/Frame.kt:42:5</span><span class="message">The class `Text` is using inheritance, consider using composition instead.

Does `Text` want to expose the complete interface (`copy, toString`) of `Frame` such that `Text` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Text` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  39 </span>        actual constructor(fin: Boolean, packet: ByteReadPacket) : this(fin, packet.readBytes())
<span class="lineno">  40 </span>    }
<span class="lineno">  41 </span>
<span class="lineno">  42 </span>    <span class="error">/**</span>
<span class="lineno">  43 </span><span class="error">     * Represents an application level text frame.</span>
<span class="lineno">  44 </span><span class="error">     * In a RAW web socket session a big text frame could be fragmented</span>
<span class="lineno">  45 </span><span class="error">     * (separated into several text frames so they have [fin] = false except the last one).</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/websocket/Frame.kt:56:5</span><span class="message">The class `Close` is using inheritance, consider using composition instead.

Does `Close` want to expose the complete interface (`copy, toString`) of `Frame` such that `Close` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Close` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  53 </span>        constructor(fin: Boolean, buffer: ByteBuffer) : this(fin, buffer.moveToByteArray())
<span class="lineno">  54 </span>    }
<span class="lineno">  55 </span>
<span class="lineno">  56 </span>    <span class="error">/**</span>
<span class="lineno">  57 </span><span class="error">     * Represents a low-level level close frame. It could be sent to indicate web socket session end.</span>
<span class="lineno">  58 </span><span class="error">     * Usually there is no need to send/handle it unless you have a RAW web socket session.</span>
<span class="lineno">  59 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/websocket/Frame.kt:75:5</span><span class="message">The class `Ping` is using inheritance, consider using composition instead.

Does `Ping` want to expose the complete interface (`copy, toString`) of `Frame` such that `Ping` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Ping` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  72 </span>        constructor(buffer: ByteBuffer) : this(buffer.moveToByteArray())
<span class="lineno">  73 </span>    }
<span class="lineno">  74 </span>
<span class="lineno">  75 </span>    <span class="error">/**</span>
<span class="lineno">  76 </span><span class="error">     * Represents a low-level ping frame. Could be sent to test connection (peer should reply with [Pong]).</span>
<span class="lineno">  77 </span><span class="error">     * Usually there is no need to send/handle it unless you have a RAW web socket session.</span>
<span class="lineno">  78 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/jvm/src/io/ktor/http/cio/websocket/Frame.kt:84:5</span><span class="message">The class `Pong` is using inheritance, consider using composition instead.

Does `Pong` want to expose the complete interface (`copy, toString`) of `Frame` such that `Pong` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Pong` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  81 </span>        constructor(buffer: ByteBuffer) : this(buffer.moveToByteArray())
<span class="lineno">  82 </span>    }
<span class="lineno">  83 </span>
<span class="lineno">  84 </span>    <span class="error">/**</span>
<span class="lineno">  85 </span><span class="error">     * Represents a low-level pong frame. Should be sent in reply to a [Ping] frame.</span>
<span class="lineno">  86 </span><span class="error">     * Usually there is no need to send/handle it unless you have a RAW web socket session.</span>
<span class="lineno">  87 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/posix/src/io/ktor/http/cio/websocket/FrameNative.kt:23:5</span><span class="message">The class `Binary` is using inheritance, consider using composition instead.

Does `Binary` want to expose the complete interface (`copy, toString`) of `Frame` such that `Binary` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Binary` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  20 </span>    actual val data: ByteArray,
<span class="lineno">  21 </span>    actual val disposableHandle: DisposableHandle
<span class="lineno">  22 </span>) {
<span class="lineno">  23 </span>    <span class="error">/**</span>
<span class="lineno">  24 </span><span class="error">     * Represents an application level binary frame.</span>
<span class="lineno">  25 </span><span class="error">     * In a RAW web socket session a big text frame could be fragmented</span>
<span class="lineno">  26 </span><span class="error">     * (separated into several text frames so they have [fin] = false except the last one).</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/posix/src/io/ktor/http/cio/websocket/FrameNative.kt:33:5</span><span class="message">The class `Text` is using inheritance, consider using composition instead.

Does `Text` want to expose the complete interface (`copy, toString`) of `Frame` such that `Text` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Text` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  30 </span>        actual constructor(fin: Boolean, packet: ByteReadPacket) : this(fin, packet.readBytes())
<span class="lineno">  31 </span>    }
<span class="lineno">  32 </span>
<span class="lineno">  33 </span>    <span class="error">/**</span>
<span class="lineno">  34 </span><span class="error">     * Represents an application level text frame.</span>
<span class="lineno">  35 </span><span class="error">     * In a RAW web socket session a big text frame could be fragmented</span>
<span class="lineno">  36 </span><span class="error">     * (separated into several text frames so they have [fin] = false except the last one).</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/posix/src/io/ktor/http/cio/websocket/FrameNative.kt:46:5</span><span class="message">The class `Close` is using inheritance, consider using composition instead.

Does `Close` want to expose the complete interface (`copy, toString`) of `Frame` such that `Close` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Close` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  43 </span>        actual constructor(fin: Boolean, packet: ByteReadPacket) : this(fin, packet.readBytes())
<span class="lineno">  44 </span>    }
<span class="lineno">  45 </span>
<span class="lineno">  46 </span>    <span class="error">/**</span>
<span class="lineno">  47 </span><span class="error">     * Represents a low-level level close frame. It could be sent to indicate web socket session end.</span>
<span class="lineno">  48 </span><span class="error">     * Usually there is no need to send/handle it unless you have a RAW web socket session.</span>
<span class="lineno">  49 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/posix/src/io/ktor/http/cio/websocket/FrameNative.kt:60:5</span><span class="message">The class `Ping` is using inheritance, consider using composition instead.

Does `Ping` want to expose the complete interface (`copy, toString`) of `Frame` such that `Ping` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Ping` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  57 </span>        actual constructor() : this(Empty)
<span class="lineno">  58 </span>    }
<span class="lineno">  59 </span>
<span class="lineno">  60 </span>    <span class="error">/**</span>
<span class="lineno">  61 </span><span class="error">     * Represents a low-level ping frame. Could be sent to test connection (peer should reply with [Pong]).</span>
<span class="lineno">  62 </span><span class="error">     * Usually there is no need to send/handle it unless you have a RAW web socket session.</span>
<span class="lineno">  63 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-http/ktor-http-cio/posix/src/io/ktor/http/cio/websocket/FrameNative.kt:68:5</span><span class="message">The class `Pong` is using inheritance, consider using composition instead.

Does `Pong` want to expose the complete interface (`copy, toString`) of `Frame` such that `Pong` can be used where `Frame` is expected? Indicates __inheritance__.

Does `Pong` want only some/part of the behavior exposed by `Frame`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  65 </span>        actual constructor(packet: ByteReadPacket) : this(packet.readBytes())
<span class="lineno">  66 </span>    }
<span class="lineno">  67 </span>
<span class="lineno">  68 </span>    <span class="error">/**</span>
<span class="lineno">  69 </span><span class="error">     * Represents a low-level pong frame. Should be sent in reply to a [Ping] frame.</span>
<span class="lineno">  70 </span><span class="error">     * Usually there is no need to send/handle it unless you have a RAW web socket session.</span>
<span class="lineno">  71 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/BufferFactory.kt:57:1</span><span class="message">The class `DefaultBufferPool` is using inheritance, consider using composition instead.

Does `DefaultBufferPool` want to expose the complete interface (`dispose, recycle, borrow`) of `DefaultPool` such that `DefaultBufferPool` can be used where `DefaultPool` is expected? Indicates __inheritance__.

Does `DefaultBufferPool` want only some/part of the behavior exposed by `DefaultPool`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  54 </span>@Suppress(&quot;DEPRECATION&quot;)
<span class="lineno">  55 </span>internal val DefaultChunkedBufferPool: ObjectPool&lt;IoBuffer&gt; = DefaultBufferPool()
<span class="lineno">  56 </span>
<span class="lineno">  57 </span><span class="error">@Suppress(&quot;DEPRECATION&quot;)</span>
<span class="lineno">  58 </span><span class="error">internal class DefaultBufferPool(</span>
<span class="lineno">  59 </span><span class="error">    private val bufferSize: Int = DEFAULT_BUFFER_SIZE,</span>
<span class="lineno">  60 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/Builder.kt:37:1</span><span class="message">The class `BytePacketBuilderPlatformBase` is using inheritance, consider using composition instead.

Does `BytePacketBuilderPlatformBase` want to expose the complete interface (`empty public interface`) of `BytePacketBuilderBase` such that `BytePacketBuilderPlatformBase` can be used where `BytePacketBuilderBase` is expected? Indicates __inheritance__.

Does `BytePacketBuilderPlatformBase` want only some/part of the behavior exposed by `BytePacketBuilderBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  34 </span>    release()
<span class="lineno">  35 </span>}
<span class="lineno">  36 </span>
<span class="lineno">  37 </span><span class="error">@DangerousInternalIoApi</span>
<span class="lineno">  38 </span><span class="error">@Deprecated(&quot;Will be removed in future releases.&quot;, level = DeprecationLevel.ERROR)</span>
<span class="lineno">  39 </span><span class="error">@Suppress(&quot;DEPRECATION_ERROR&quot;)</span>
<span class="lineno">  40 </span><span class="error">abstract class BytePacketBuilderPlatformBase</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/Builder.kt:43:1</span><span class="message">The class `BytePacketBuilderBase` is using inheritance, consider using composition instead.

Does `BytePacketBuilderBase` want to expose the complete interface (`reset, appendNewBuffer, afterHeadWrite, prepareWriteHead, release, writeStringUtf8, writeStringUtf8, append, writePacket, writePacket, writePacket, append, append, append, close, writeByte, flush`) of `AbstractOutput` such that `BytePacketBuilderBase` can be used where `AbstractOutput` is expected? Indicates __inheritance__.

Does `BytePacketBuilderBase` want only some/part of the behavior exposed by `AbstractOutput`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  40 </span>abstract class BytePacketBuilderPlatformBase
<span class="lineno">  41 </span>internal constructor(pool: ObjectPool&lt;ChunkBuffer&gt;) : BytePacketBuilderBase(pool)
<span class="lineno">  42 </span>
<span class="lineno">  43 </span><span class="error">@DangerousInternalIoApi</span>
<span class="lineno">  44 </span><span class="error">@Deprecated(&quot;Will be removed in future releases&quot;, level = DeprecationLevel.ERROR)</span>
<span class="lineno">  45 </span><span class="error">@Suppress(&quot;DEPRECATION_ERROR&quot;)</span>
<span class="lineno">  46 </span><span class="error">abstract class BytePacketBuilderBase</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/BytePacketBuilder.kt:20:1</span><span class="message">The class `BytePacketBuilder` is using inheritance, consider using composition instead.

Does `BytePacketBuilder` want to expose the complete interface (`empty public interface`) of `BytePacketBuilderPlatformBase` such that `BytePacketBuilder` can be used where `BytePacketBuilderPlatformBase` is expected? Indicates __inheritance__.

Does `BytePacketBuilder` want only some/part of the behavior exposed by `BytePacketBuilderPlatformBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  17 </span>import kotlin.check
<span class="lineno">  18 </span>import kotlin.jvm.JvmName
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">/**</span>
<span class="lineno">  21 </span><span class="error"> * A builder that provides ability to build byte packets with no knowledge of it's size.</span>
<span class="lineno">  22 </span><span class="error"> * Unlike Java's ByteArrayOutputStream it doesn't copy the whole content every time it's internal buffer overflows</span>
<span class="lineno">  23 </span><span class="error"> * but chunks buffers instead. Packet building via [build] function is O(1) operation and only does instantiate</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/ByteReadPacket.kt:9:1</span><span class="message">The class `ByteReadPacket` is using inheritance, consider using composition instead.

Does `ByteReadPacket` want to expose the complete interface (`empty public interface`) of `ByteReadPacketPlatformBase` such that `ByteReadPacket` can be used where `ByteReadPacketPlatformBase` is expected? Indicates __inheritance__.

Does `ByteReadPacket` want only some/part of the behavior exposed by `ByteReadPacketPlatformBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>import io.ktor.utils.io.core.internal.*
<span class="lineno">   7 </span>import io.ktor.utils.io.pool.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">/**</span>
<span class="lineno">  10 </span><span class="error"> * Read-only immutable byte packet. Could be consumed only once however it does support [copy] that doesn't copy every byte</span>
<span class="lineno">  11 </span><span class="error"> * but creates a new view instead. Once packet created it should be either completely read (consumed) or released</span>
<span class="lineno">  12 </span><span class="error"> * via [release].</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/ByteReadPacket.kt:54:1</span><span class="message">The class `ByteReadPacketPlatformBase` is using inheritance, consider using composition instead.

Does `ByteReadPacketPlatformBase` want to expose the complete interface (`empty public interface`) of `ByteReadPacketBase` such that `ByteReadPacketPlatformBase` can be used where `ByteReadPacketBase` is expected? Indicates __inheritance__.

Does `ByteReadPacketPlatformBase` want only some/part of the behavior exposed by `ByteReadPacketBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  51 </span>    }
<span class="lineno">  52 </span>}
<span class="lineno">  53 </span>
<span class="lineno">  54 </span><span class="error">@Suppress(&quot;DEPRECATION&quot;)</span>
<span class="lineno">  55 </span><span class="error">@DangerousInternalIoApi</span>
<span class="lineno">  56 </span><span class="error">@Deprecated(</span>
<span class="lineno">  57 </span><span class="error">    &quot;Will be removed in future releases.&quot;,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/Packet.kt:9:1</span><span class="message">The class `ByteReadPacketBase` is using inheritance, consider using composition instead.

Does `ByteReadPacketBase` want to expose the complete interface (`fixGapAfterRead, ensureNextHead, prepareReadHead, updateHeadRemaining, readTextExact, readText, readTextExact, readText, discard, peekTo, tryPeek, discardExact, discard, readFully, readLong, readInt, readDouble, readFloat, readShort, readByte, close, release, hasBytes, canRead, peekTo`) of `AbstractInput` such that `ByteReadPacketBase` can be used where `AbstractInput` is expected? Indicates __inheritance__.

Does `ByteReadPacketBase` want only some/part of the behavior exposed by `AbstractInput`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>import io.ktor.utils.io.errors.*
<span class="lineno">   7 </span>import io.ktor.utils.io.pool.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">@DangerousInternalIoApi</span>
<span class="lineno">  10 </span><span class="error">@Deprecated(</span>
<span class="lineno">  11 </span><span class="error">    &quot;Will be removed in the future releases. Use Input or AbstractInput instead.&quot;,</span>
<span class="lineno">  12 </span><span class="error">    ReplaceWith(&quot;AbstractInput&quot;, &quot;io.ktor.utils.io.core.AbstractInput&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/common/src/io/ktor/utils/io/core/internal/ChunkBuffer.kt:12:1</span><span class="message">The class `ChunkBuffer` is using inheritance, consider using composition instead.

Does `ChunkBuffer` want to expose the complete interface (`toString, reset, writeByte, readByte, tryReadByte, tryPeekByte, duplicate, resetForWrite, resetForWrite, resetForRead, reserveEndGap, reserveStartGap, rewind, commitWritten, discard, discard, discardExact`) of `Buffer` such that `ChunkBuffer` can be used where `Buffer` is expected? Indicates __inheritance__.

Does `ChunkBuffer` want only some/part of the behavior exposed by `Buffer`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import io.ktor.utils.io.core.*
<span class="lineno">  10 </span>import io.ktor.utils.io.pool.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">@DangerousInternalIoApi</span>
<span class="lineno">  13 </span><span class="error">open class ChunkBuffer internal constructor(memory: Memory, origin: ChunkBuffer?) : Buffer(memory) {</span>
<span class="lineno">  14 </span><span class="error">    init {</span>
<span class="lineno">  15 </span><span class="error">        require(origin !== this) { &quot;A chunk couldn't be a view of itself.&quot; }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/js/src/io/ktor/utils/io/ByteChannelJS.kt:77:1</span><span class="message">The class `ByteChannelJS` is using inheritance, consider using composition instead.

Does `ByteChannelJS` want to expose the complete interface (`peekTo, close, cancel, readUTF8Line, readUTF8LineTo, readSuspendableSession, endReadSession, startReadSession, readSession, discard, request, discard, await, readBoolean, readFully, readAvailable, readFully, readAvailable, readPacket, readRemaining, readDouble, readFloat, readLong, readInt, readShort, readByte, endWriteSession, beginWriteSession, writeSuspendSession, writeAvailable, writeAvailable, writeFully, writeFully, writePacket, writeDouble, writeFloat, writeLong, writeInt, writeShort, writeByte, flush`) of `ByteChannelSequentialBase` such that `ByteChannelJS` can be used where `ByteChannelSequentialBase` is expected? Indicates __inheritance__.

Does `ByteChannelJS` want only some/part of the behavior exposed by `ByteChannelSequentialBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  74 </span>    return (this as ByteChannelSequentialBase).copyToSequentialImpl((dst as ByteChannelSequentialBase), limit)
<span class="lineno">  75 </span>}
<span class="lineno">  76 </span>
<span class="lineno">  77 </span><span class="error">internal class ByteChannelJS(initial: IoBuffer, autoFlush: Boolean) : ByteChannelSequentialBase(initial, autoFlush) {</span>
<span class="lineno">  78 </span><span class="error">    private var attachedJob: Job? = null</span>
<span class="lineno">  79 </span><span class="error"></span>
<span class="lineno">  80 </span><span class="error">    @OptIn(InternalCoroutinesApi::class)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/js/src/io/ktor/utils/io/charsets/CharsetJS.kt:31:1</span><span class="message">The class `CharsetEncoderImpl` is using inheritance, consider using composition instead.

Does `CharsetEncoderImpl` want to expose the complete interface (`empty public interface`) of `CharsetEncoder` such that `CharsetEncoderImpl` can be used where `CharsetEncoder` is expected? Indicates __inheritance__.

Does `CharsetEncoderImpl` want only some/part of the behavior exposed by `CharsetEncoder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  28 </span>// -----------------------
<span class="lineno">  29 </span>
<span class="lineno">  30 </span>actual abstract class CharsetEncoder(internal val _charset: Charset)
<span class="lineno">  31 </span><span class="error">private data class CharsetEncoderImpl(private val charset: Charset) : CharsetEncoder(charset)</span>
<span class="lineno">  32 </span>actual val CharsetEncoder.charset: Charset get() = _charset
<span class="lineno">  33 </span>
<span class="lineno">  34 </span>actual fun CharsetEncoder.encodeToByteArray(input: CharSequence, fromIndex: Int, toIndex: Int): ByteArray =
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/js/src/io/ktor/utils/io/charsets/CharsetJS.kt:82:1</span><span class="message">The class `CharsetDecoderImpl` is using inheritance, consider using composition instead.

Does `CharsetDecoderImpl` want to expose the complete interface (`empty public interface`) of `CharsetDecoder` such that `CharsetDecoderImpl` can be used where `CharsetDecoder` is expected? Indicates __inheritance__.

Does `CharsetDecoderImpl` want only some/part of the behavior exposed by `CharsetDecoder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  79 </span>
<span class="lineno">  80 </span>actual abstract class CharsetDecoder(internal val _charset: Charset)
<span class="lineno">  81 </span>
<span class="lineno">  82 </span><span class="error">private data class CharsetDecoderImpl(private val charset: Charset) : CharsetDecoder(charset)</span>
<span class="lineno">  83 </span>
<span class="lineno">  84 </span>actual val CharsetDecoder.charset: Charset get() = _charset
<span class="lineno">  85 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/js/src/io/ktor/utils/io/charsets/CharsetJS.kt:201:1</span><span class="message">The class `CharsetImpl` is using inheritance, consider using composition instead.

Does `CharsetImpl` want to expose the complete interface (`newDecoder, newEncoder`) of `Charset` such that `CharsetImpl` can be used where `Charset` is expected? Indicates __inheritance__.

Does `CharsetImpl` want only some/part of the behavior exposed by `Charset`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 198 </span>    actual val ISO_8859_1: Charset = CharsetImpl(&quot;ISO-8859-1&quot;)
<span class="lineno"> 199 </span>}
<span class="lineno"> 200 </span>
<span class="lineno"> 201 </span><span class="error">private data class CharsetImpl(val name: String) : Charset(name) {</span>
<span class="lineno"> 202 </span><span class="error">    override fun newEncoder(): CharsetEncoder = CharsetEncoderImpl(this)</span>
<span class="lineno"> 203 </span><span class="error">    override fun newDecoder(): CharsetDecoder = CharsetDecoderImpl(this)</span>
<span class="lineno"> 204 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/js/src/io/ktor/utils/io/errors/IOException.kt:7:1</span><span class="message">The class `EOFException` is using inheritance, consider using composition instead.

Does `EOFException` want to expose the complete interface (`empty public interface`) of `IOException` such that `EOFException` can be used where `IOException` is expected? Indicates __inheritance__.

Does `EOFException` want only some/part of the behavior exposed by `IOException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>    actual constructor(message: String) : this(message, null)
<span class="lineno">   5 </span>}
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">actual open class EOFException actual constructor(message: String) : IOException(message)</span>
<span class="lineno">   8 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/ByteChannelSequentialJVM.kt:8:1</span><span class="message">The class `ByteChannelSequentialJVM` is using inheritance, consider using composition instead.

Does `ByteChannelSequentialJVM` want to expose the complete interface (`peekTo, close, cancel, readUTF8Line, readUTF8LineTo, readSuspendableSession, endReadSession, startReadSession, readSession, discard, request, discard, await, readBoolean, readFully, readAvailable, readFully, readAvailable, readPacket, readRemaining, readDouble, readFloat, readLong, readInt, readShort, readByte, endWriteSession, beginWriteSession, writeSuspendSession, writeAvailable, writeAvailable, writeFully, writeFully, writePacket, writeDouble, writeFloat, writeLong, writeInt, writeShort, writeByte, flush`) of `ByteChannelSequentialBase` such that `ByteChannelSequentialJVM` can be used where `ByteChannelSequentialBase` is expected? Indicates __inheritance__.

Does `ByteChannelSequentialJVM` want only some/part of the behavior exposed by `ByteChannelSequentialBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   5 </span>import io.ktor.utils.io.core.*
<span class="lineno">   6 </span>import java.nio.ByteBuffer
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">@Suppress(&quot;EXPERIMENTAL_FEATURE_WARNING&quot;)</span>
<span class="lineno">   9 </span><span class="error">@ExperimentalIoApi</span>
<span class="lineno">  10 </span><span class="error">class ByteChannelSequentialJVM(initial: IoBuffer, autoFlush: Boolean)</span>
<span class="lineno">  11 </span><span class="error">    : ByteChannelSequentialBase(initial, autoFlush) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/core/ByteReadPacketExtensions.kt:23:1</span><span class="message">The class `SingleByteBufferPool` is using inheritance, consider using composition instead.

Does `SingleByteBufferPool` want to expose the complete interface (`dispose, recycle, borrow`) of `SingleInstancePool` such that `SingleByteBufferPool` can be used where `SingleInstancePool` is expected? Indicates __inheritance__.

Does `SingleByteBufferPool` want only some/part of the behavior exposed by `SingleInstancePool`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  20 </span>    return SingleByteBufferPool(bb, release)
<span class="lineno">  21 </span>}
<span class="lineno">  22 </span>
<span class="lineno">  23 </span><span class="error">private class SingleByteBufferPool(val instance: ByteBuffer, val release: (ByteBuffer) -&gt; Unit) :</span>
<span class="lineno">  24 </span><span class="error">    SingleInstancePool&lt;ChunkBuffer&gt;() {</span>
<span class="lineno">  25 </span><span class="error">    override fun produceInstance(): ChunkBuffer {</span>
<span class="lineno">  26 </span><span class="error">        @Suppress(&quot;DEPRECATION&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/internal/ReadWriteBufferState.kt:29:5</span><span class="message">The class `Initial` is using inheritance, consider using composition instead.

Does `Initial` want to expose the complete interface (`empty public interface`) of `ReadWriteBufferState` such that `Initial` can be used where `ReadWriteBufferState` is expected? Indicates __inheritance__.

Does `Initial` want only some/part of the behavior exposed by `ReadWriteBufferState`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  26 </span>        override fun toString() = &quot;IDLE(empty)&quot;
<span class="lineno">  27 </span>    }
<span class="lineno">  28 </span>
<span class="lineno">  29 </span>    <span class="error">class Initial(</span>
<span class="lineno">  30 </span><span class="error">        backingBuffer: ByteBuffer,</span>
<span class="lineno">  31 </span><span class="error">        reservedSize: Int = RESERVED_SIZE</span>
<span class="lineno">  32 </span><span class="error">    ) : ReadWriteBufferState(backingBuffer, RingBufferCapacity(backingBuffer.capacity() - reservedSize)) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/internal/ReadWriteBufferState.kt:51:5</span><span class="message">The class `IdleNonEmpty` is using inheritance, consider using composition instead.

Does `IdleNonEmpty` want to expose the complete interface (`empty public interface`) of `ReadWriteBufferState` such that `IdleNonEmpty` can be used where `ReadWriteBufferState` is expected? Indicates __inheritance__.

Does `IdleNonEmpty` want only some/part of the behavior exposed by `ReadWriteBufferState`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  48 </span>        override fun toString() = &quot;Initial&quot;
<span class="lineno">  49 </span>    }
<span class="lineno">  50 </span>
<span class="lineno">  51 </span>    <span class="error">class IdleNonEmpty internal constructor(</span>
<span class="lineno">  52 </span><span class="error">        val initial: Initial // public here, so can release initial state when idle</span>
<span class="lineno">  53 </span><span class="error">    ) : ReadWriteBufferState(initial.backingBuffer, initial.capacity) {</span>
<span class="lineno">  54 </span><span class="error">        override fun startReading() = initial.readingState</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/internal/ReadWriteBufferState.kt:60:5</span><span class="message">The class `Reading` is using inheritance, consider using composition instead.

Does `Reading` want to expose the complete interface (`empty public interface`) of `ReadWriteBufferState` such that `Reading` can be used where `ReadWriteBufferState` is expected? Indicates __inheritance__.

Does `Reading` want only some/part of the behavior exposed by `ReadWriteBufferState`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  57 </span>        override fun toString() = &quot;IDLE(with buffer)&quot;
<span class="lineno">  58 </span>    }
<span class="lineno">  59 </span>
<span class="lineno">  60 </span>    <span class="error">class Reading internal constructor(</span>
<span class="lineno">  61 </span><span class="error">        private val initial: Initial</span>
<span class="lineno">  62 </span><span class="error">    ) : ReadWriteBufferState(initial.backingBuffer, initial.capacity) {</span>
<span class="lineno">  63 </span><span class="error">        override val readBuffer: ByteBuffer get() = initial.readBuffer</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/internal/ReadWriteBufferState.kt:69:5</span><span class="message">The class `Writing` is using inheritance, consider using composition instead.

Does `Writing` want to expose the complete interface (`empty public interface`) of `ReadWriteBufferState` such that `Writing` can be used where `ReadWriteBufferState` is expected? Indicates __inheritance__.

Does `Writing` want only some/part of the behavior exposed by `ReadWriteBufferState`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  66 </span>        override fun toString() = &quot;Reading&quot;
<span class="lineno">  67 </span>    }
<span class="lineno">  68 </span>
<span class="lineno">  69 </span>    <span class="error">class Writing internal constructor(</span>
<span class="lineno">  70 </span><span class="error">        private val initial: Initial</span>
<span class="lineno">  71 </span><span class="error">    ) : ReadWriteBufferState(initial.backingBuffer, initial.capacity) {</span>
<span class="lineno">  72 </span><span class="error">        override val writeBuffer: ByteBuffer get() = initial.writeBuffer</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/internal/ReadWriteBufferState.kt:78:5</span><span class="message">The class `ReadingWriting` is using inheritance, consider using composition instead.

Does `ReadingWriting` want to expose the complete interface (`empty public interface`) of `ReadWriteBufferState` such that `ReadingWriting` can be used where `ReadWriteBufferState` is expected? Indicates __inheritance__.

Does `ReadingWriting` want only some/part of the behavior exposed by `ReadWriteBufferState`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  75 </span>        override fun toString() = &quot;Writing&quot;
<span class="lineno">  76 </span>    }
<span class="lineno">  77 </span>
<span class="lineno">  78 </span>    <span class="error">class ReadingWriting internal constructor(</span>
<span class="lineno">  79 </span><span class="error">        private val initial: Initial</span>
<span class="lineno">  80 </span><span class="error">    ) : ReadWriteBufferState(initial.backingBuffer, initial.capacity) {</span>
<span class="lineno">  81 </span><span class="error">        override val readBuffer: ByteBuffer get() = initial.readBuffer</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/nio/Input.kt:11:1</span><span class="message">The class `ChannelAsInput` is using inheritance, consider using composition instead.

Does `ChannelAsInput` want to expose the complete interface (`fixGapAfterRead, ensureNextHead, prepareReadHead, updateHeadRemaining, readTextExact, readText, readTextExact, readText, discard, peekTo, tryPeek, discardExact, discard, readFully, readLong, readInt, readDouble, readFloat, readShort, readByte, close, release, hasBytes, canRead, peekTo`) of `AbstractInput` such that `ChannelAsInput` can be used where `AbstractInput` is expected? Indicates __inheritance__.

Does `ChannelAsInput` want only some/part of the behavior exposed by `AbstractInput`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import java.nio.channels.*
<span class="lineno">   9 </span>import kotlin.require
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">private class ChannelAsInput(private val channel: ReadableByteChannel, pool: ObjectPool&lt;ChunkBuffer&gt;) :</span>
<span class="lineno">  12 </span><span class="error">    AbstractInput(pool = pool), Input {</span>
<span class="lineno">  13 </span><span class="error">    init {</span>
<span class="lineno">  14 </span><span class="error">        require(channel !is SelectableChannel || !channel.isBlocking) { &quot;Non-blocking channels are not supported&quot; }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/nio/Output.kt:10:1</span><span class="message">The class `ChannelAsOutput` is using inheritance, consider using composition instead.

Does `ChannelAsOutput` want to expose the complete interface (`reset, appendNewBuffer, afterHeadWrite, prepareWriteHead, release, writeStringUtf8, writeStringUtf8, append, writePacket, writePacket, writePacket, append, append, append, close, writeByte, flush`) of `AbstractOutput` such that `ChannelAsOutput` can be used where `AbstractOutput` is expected? Indicates __inheritance__.

Does `ChannelAsOutput` want only some/part of the behavior exposed by `AbstractOutput`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import io.ktor.utils.io.pool.*
<span class="lineno">   8 </span>import java.nio.channels.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">private class ChannelAsOutput(</span>
<span class="lineno">  11 </span><span class="error">    pool: ObjectPool&lt;ChunkBuffer&gt;,</span>
<span class="lineno">  12 </span><span class="error">    val channel: WritableByteChannel</span>
<span class="lineno">  13 </span><span class="error">) : AbstractOutput(pool) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/streams/Input.kt:10:1</span><span class="message">The class `InputStreamAsInput` is using inheritance, consider using composition instead.

Does `InputStreamAsInput` want to expose the complete interface (`fixGapAfterRead, ensureNextHead, prepareReadHead, updateHeadRemaining, readTextExact, readText, readTextExact, readText, discard, peekTo, tryPeek, discardExact, discard, readFully, readLong, readInt, readDouble, readFloat, readShort, readByte, close, release, hasBytes, canRead, peekTo`) of `AbstractInput` such that `InputStreamAsInput` can be used where `AbstractInput` is expected? Indicates __inheritance__.

Does `InputStreamAsInput` want only some/part of the behavior exposed by `AbstractInput`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import io.ktor.utils.io.pool.*
<span class="lineno">   8 </span>import java.io.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">internal class InputStreamAsInput(</span>
<span class="lineno">  11 </span><span class="error">    private val stream: InputStream,</span>
<span class="lineno">  12 </span><span class="error">    pool: ObjectPool&lt;ChunkBuffer&gt;</span>
<span class="lineno">  13 </span><span class="error">) : AbstractInput(pool = pool) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/jvm/src/io/ktor/utils/io/streams/Output.kt:10:1</span><span class="message">The class `OutputStreamAdapter` is using inheritance, consider using composition instead.

Does `OutputStreamAdapter` want to expose the complete interface (`reset, appendNewBuffer, afterHeadWrite, prepareWriteHead, release, writeStringUtf8, writeStringUtf8, append, writePacket, writePacket, writePacket, append, append, append, close, writeByte, flush`) of `AbstractOutput` such that `OutputStreamAdapter` can be used where `AbstractOutput` is expected? Indicates __inheritance__.

Does `OutputStreamAdapter` want only some/part of the behavior exposed by `AbstractOutput`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import io.ktor.utils.io.pool.*
<span class="lineno">   8 </span>import java.io.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">private class OutputStreamAdapter(pool: ObjectPool&lt;ChunkBuffer&gt;, private val stream: OutputStream) :</span>
<span class="lineno">  11 </span><span class="error">    AbstractOutput(pool) {</span>
<span class="lineno">  12 </span><span class="error">    override fun flush(source: Memory, offset: Int, length: Int) {</span>
<span class="lineno">  13 </span><span class="error">        val nioBuffer = source.buffer</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/ByteChannelNative.kt:57:1</span><span class="message">The class `ByteChannelNative` is using inheritance, consider using composition instead.

Does `ByteChannelNative` want to expose the complete interface (`peekTo, close, cancel, readUTF8Line, readUTF8LineTo, readSuspendableSession, endReadSession, startReadSession, readSession, discard, request, discard, await, readBoolean, readFully, readAvailable, readFully, readAvailable, readPacket, readRemaining, readDouble, readFloat, readLong, readInt, readShort, readByte, endWriteSession, beginWriteSession, writeSuspendSession, writeAvailable, writeAvailable, writeFully, writeFully, writePacket, writeDouble, writeFloat, writeLong, writeInt, writeShort, writeByte, flush`) of `ByteChannelSequentialBase` such that `ByteChannelNative` can be used where `ByteChannelSequentialBase` is expected? Indicates __inheritance__.

Does `ByteChannelNative` want only some/part of the behavior exposed by `ByteChannelSequentialBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  54 </span>    return (this as ByteChannelSequentialBase).copyToSequentialImpl((dst as ByteChannelSequentialBase), limit)
<span class="lineno">  55 </span>}
<span class="lineno">  56 </span>
<span class="lineno">  57 </span><span class="error">internal class ByteChannelNative(</span>
<span class="lineno">  58 </span><span class="error">    initial: IoBuffer,</span>
<span class="lineno">  59 </span><span class="error">    autoFlush: Boolean,</span>
<span class="lineno">  60 </span><span class="error">    pool: ObjectPool&lt;ChunkBuffer&gt; = ChunkBuffer.Pool</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/charsets/CharsetNative.kt:24:1</span><span class="message">The class `CharsetImpl` is using inheritance, consider using composition instead.

Does `CharsetImpl` want to expose the complete interface (`newDecoder, newEncoder`) of `Charset` such that `CharsetImpl` can be used where `Charset` is expected? Indicates __inheritance__.

Does `CharsetImpl` want only some/part of the behavior exposed by `Charset`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  21 </span>    }
<span class="lineno">  22 </span>}
<span class="lineno">  23 </span>
<span class="lineno">  24 </span><span class="error">private class CharsetImpl(name: String) : Charset(name) {</span>
<span class="lineno">  25 </span><span class="error">    init {</span>
<span class="lineno">  26 </span><span class="error">        val v = iconv_open(name, &quot;UTF-8&quot;)</span>
<span class="lineno">  27 </span><span class="error">        checkErrors(v, name)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/charsets/CharsetNative.kt:40:1</span><span class="message">The class `CharsetEncoderImpl` is using inheritance, consider using composition instead.

Does `CharsetEncoderImpl` want to expose the complete interface (`empty public interface`) of `CharsetEncoder` such that `CharsetEncoderImpl` can be used where `CharsetEncoder` is expected? Indicates __inheritance__.

Does `CharsetEncoderImpl` want only some/part of the behavior exposed by `CharsetEncoder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  37 </span>// -----------------------
<span class="lineno">  38 </span>
<span class="lineno">  39 </span>actual abstract class CharsetEncoder(internal val _charset: Charset)
<span class="lineno">  40 </span><span class="error">private data class CharsetEncoderImpl(private val charset: Charset) : CharsetEncoder(charset)</span>
<span class="lineno">  41 </span>
<span class="lineno">  42 </span>actual val CharsetEncoder.charset: Charset get() = _charset
<span class="lineno">  43 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/charsets/CharsetNative.kt:189:1</span><span class="message">The class `CharsetDecoderImpl` is using inheritance, consider using composition instead.

Does `CharsetDecoderImpl` want to expose the complete interface (`empty public interface`) of `CharsetDecoder` such that `CharsetDecoderImpl` can be used where `CharsetDecoder` is expected? Indicates __inheritance__.

Does `CharsetDecoderImpl` want only some/part of the behavior exposed by `CharsetDecoder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 186 </span>// ----------------------------------------------------------------------
<span class="lineno"> 187 </span>
<span class="lineno"> 188 </span>actual abstract class CharsetDecoder(internal val _charset: Charset)
<span class="lineno"> 189 </span><span class="error">private data class CharsetDecoderImpl(private val charset: Charset) : CharsetDecoder(charset)</span>
<span class="lineno"> 190 </span>
<span class="lineno"> 191 </span>actual val CharsetDecoder.charset: Charset get() = _charset
<span class="lineno"> 192 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/IOException.kt:7:1</span><span class="message">The class `EOFException` is using inheritance, consider using composition instead.

Does `EOFException` want to expose the complete interface (`empty public interface`) of `IOException` such that `EOFException` can be used where `IOException` is expected? Indicates __inheritance__.

Does `EOFException` want only some/part of the behavior exposed by `IOException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>    actual constructor(message: String) : this(message, null)
<span class="lineno">   5 </span>}
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">actual open class EOFException actual constructor(message: String) : IOException(message)</span>
<span class="lineno">   8 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:41:5</span><span class="message">The class `BadFileDescriptorException` is using inheritance, consider using composition instead.

Does `BadFileDescriptorException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `BadFileDescriptorException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `BadFileDescriptorException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  38 </span> */
<span class="lineno">  39 </span>@ExperimentalIoApi
<span class="lineno">  40 </span>sealed class PosixException(val errno: Int, message: String) : Exception(message) {
<span class="lineno">  41 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  42 </span><span class="error">    class BadFileDescriptorException(message: String) : PosixException(EBADF, message)</span>
<span class="lineno">  43 </span>
<span class="lineno">  44 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:44:5</span><span class="message">The class `TryAgainException` is using inheritance, consider using composition instead.

Does `TryAgainException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `TryAgainException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `TryAgainException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  41 </span>    @ExperimentalIoApi
<span class="lineno">  42 </span>    class BadFileDescriptorException(message: String) : PosixException(EBADF, message)
<span class="lineno">  43 </span>
<span class="lineno">  44 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  45 </span><span class="error">    class TryAgainException(errno: Int = EAGAIN, message: String) : PosixException(errno, message)</span>
<span class="lineno">  46 </span>
<span class="lineno">  47 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:47:5</span><span class="message">The class `BadMessageException` is using inheritance, consider using composition instead.

Does `BadMessageException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `BadMessageException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `BadMessageException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  44 </span>    @ExperimentalIoApi
<span class="lineno">  45 </span>    class TryAgainException(errno: Int = EAGAIN, message: String) : PosixException(errno, message)
<span class="lineno">  46 </span>
<span class="lineno">  47 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  48 </span><span class="error">    class BadMessageException(message: String) : PosixException(EBADMSG, message)</span>
<span class="lineno">  49 </span>
<span class="lineno">  50 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:50:5</span><span class="message">The class `InterruptedException` is using inheritance, consider using composition instead.

Does `InterruptedException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `InterruptedException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `InterruptedException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  47 </span>    @ExperimentalIoApi
<span class="lineno">  48 </span>    class BadMessageException(message: String) : PosixException(EBADMSG, message)
<span class="lineno">  49 </span>
<span class="lineno">  50 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  51 </span><span class="error">    class InterruptedException(message: String) : PosixException(EINTR, message)</span>
<span class="lineno">  52 </span>
<span class="lineno">  53 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:53:5</span><span class="message">The class `InvalidArgumentException` is using inheritance, consider using composition instead.

Does `InvalidArgumentException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `InvalidArgumentException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `InvalidArgumentException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  50 </span>    @ExperimentalIoApi
<span class="lineno">  51 </span>    class InterruptedException(message: String) : PosixException(EINTR, message)
<span class="lineno">  52 </span>
<span class="lineno">  53 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  54 </span><span class="error">    class InvalidArgumentException(message: String) : PosixException(EINVAL, message)</span>
<span class="lineno">  55 </span>
<span class="lineno">  56 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:56:5</span><span class="message">The class `ConnectionResetException` is using inheritance, consider using composition instead.

Does `ConnectionResetException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `ConnectionResetException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `ConnectionResetException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  53 </span>    @ExperimentalIoApi
<span class="lineno">  54 </span>    class InvalidArgumentException(message: String) : PosixException(EINVAL, message)
<span class="lineno">  55 </span>
<span class="lineno">  56 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  57 </span><span class="error">    class ConnectionResetException(message: String) : PosixException(ECONNRESET, message)</span>
<span class="lineno">  58 </span>
<span class="lineno">  59 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:59:5</span><span class="message">The class `ConnectionRefusedException` is using inheritance, consider using composition instead.

Does `ConnectionRefusedException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `ConnectionRefusedException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `ConnectionRefusedException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  56 </span>    @ExperimentalIoApi
<span class="lineno">  57 </span>    class ConnectionResetException(message: String) : PosixException(ECONNRESET, message)
<span class="lineno">  58 </span>
<span class="lineno">  59 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  60 </span><span class="error">    class ConnectionRefusedException(message: String) : PosixException(ECONNREFUSED, message)</span>
<span class="lineno">  61 </span>
<span class="lineno">  62 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:62:5</span><span class="message">The class `ConnectionAbortedException` is using inheritance, consider using composition instead.

Does `ConnectionAbortedException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `ConnectionAbortedException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `ConnectionAbortedException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  59 </span>    @ExperimentalIoApi
<span class="lineno">  60 </span>    class ConnectionRefusedException(message: String) : PosixException(ECONNREFUSED, message)
<span class="lineno">  61 </span>
<span class="lineno">  62 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  63 </span><span class="error">    class ConnectionAbortedException(message: String) : PosixException(ECONNABORTED, message)</span>
<span class="lineno">  64 </span>
<span class="lineno">  65 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:65:5</span><span class="message">The class `NotConnectedException` is using inheritance, consider using composition instead.

Does `NotConnectedException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `NotConnectedException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `NotConnectedException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  62 </span>    @ExperimentalIoApi
<span class="lineno">  63 </span>    class ConnectionAbortedException(message: String) : PosixException(ECONNABORTED, message)
<span class="lineno">  64 </span>
<span class="lineno">  65 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  66 </span><span class="error">    class NotConnectedException(message: String) : PosixException(ENOTCONN, message)</span>
<span class="lineno">  67 </span>
<span class="lineno">  68 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:68:5</span><span class="message">The class `TimeoutIOException` is using inheritance, consider using composition instead.

Does `TimeoutIOException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `TimeoutIOException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `TimeoutIOException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  65 </span>    @ExperimentalIoApi
<span class="lineno">  66 </span>    class NotConnectedException(message: String) : PosixException(ENOTCONN, message)
<span class="lineno">  67 </span>
<span class="lineno">  68 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  69 </span><span class="error">    class TimeoutIOException(message: String) : PosixException(ETIMEDOUT, message)</span>
<span class="lineno">  70 </span>
<span class="lineno">  71 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:71:5</span><span class="message">The class `NotSocketException` is using inheritance, consider using composition instead.

Does `NotSocketException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `NotSocketException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `NotSocketException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  68 </span>    @ExperimentalIoApi
<span class="lineno">  69 </span>    class TimeoutIOException(message: String) : PosixException(ETIMEDOUT, message)
<span class="lineno">  70 </span>
<span class="lineno">  71 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  72 </span><span class="error">    class NotSocketException(message: String) : PosixException(ENOTSOCK, message)</span>
<span class="lineno">  73 </span>
<span class="lineno">  74 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:74:5</span><span class="message">The class `AddressAlreadyInUseException` is using inheritance, consider using composition instead.

Does `AddressAlreadyInUseException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `AddressAlreadyInUseException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `AddressAlreadyInUseException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  71 </span>    @ExperimentalIoApi
<span class="lineno">  72 </span>    class NotSocketException(message: String) : PosixException(ENOTSOCK, message)
<span class="lineno">  73 </span>
<span class="lineno">  74 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  75 </span><span class="error">    class AddressAlreadyInUseException(message: String) : PosixException(EADDRINUSE, message)</span>
<span class="lineno">  76 </span>
<span class="lineno">  77 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:77:5</span><span class="message">The class `NoSuchFileException` is using inheritance, consider using composition instead.

Does `NoSuchFileException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `NoSuchFileException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `NoSuchFileException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  74 </span>    @ExperimentalIoApi
<span class="lineno">  75 </span>    class AddressAlreadyInUseException(message: String) : PosixException(EADDRINUSE, message)
<span class="lineno">  76 </span>
<span class="lineno">  77 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  78 </span><span class="error">    class NoSuchFileException(message: String) : PosixException(ENOENT, message)</span>
<span class="lineno">  79 </span>
<span class="lineno">  80 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:80:5</span><span class="message">The class `OverflowException` is using inheritance, consider using composition instead.

Does `OverflowException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `OverflowException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `OverflowException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  77 </span>    @ExperimentalIoApi
<span class="lineno">  78 </span>    class NoSuchFileException(message: String) : PosixException(ENOENT, message)
<span class="lineno">  79 </span>
<span class="lineno">  80 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  81 </span><span class="error">    class OverflowException(message: String) : PosixException(EOVERFLOW, message)</span>
<span class="lineno">  82 </span>
<span class="lineno">  83 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:83:5</span><span class="message">The class `NoMemoryException` is using inheritance, consider using composition instead.

Does `NoMemoryException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `NoMemoryException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `NoMemoryException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  80 </span>    @ExperimentalIoApi
<span class="lineno">  81 </span>    class OverflowException(message: String) : PosixException(EOVERFLOW, message)
<span class="lineno">  82 </span>
<span class="lineno">  83 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  84 </span><span class="error">    class NoMemoryException(message: String) : PosixException(ENOMEM, message)</span>
<span class="lineno">  85 </span>
<span class="lineno">  86 </span>    @ExperimentalIoApi
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/errors/PosixErrors.kt:86:5</span><span class="message">The class `PosixErrnoException` is using inheritance, consider using composition instead.

Does `PosixErrnoException` want to expose the complete interface (`empty public interface`) of `PosixException` such that `PosixErrnoException` can be used where `PosixException` is expected? Indicates __inheritance__.

Does `PosixErrnoException` want only some/part of the behavior exposed by `PosixException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  83 </span>    @ExperimentalIoApi
<span class="lineno">  84 </span>    class NoMemoryException(message: String) : PosixException(ENOMEM, message)
<span class="lineno">  85 </span>
<span class="lineno">  86 </span>    <span class="error">@ExperimentalIoApi</span>
<span class="lineno">  87 </span><span class="error">    class PosixErrnoException(errno: Int, message: String) : PosixException(errno, &quot;$message ($errno)&quot;)</span>
<span class="lineno">  88 </span>
<span class="lineno">  89 </span>    companion object {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/streams/PosixInput.kt:24:1</span><span class="message">The class `PosixInputForFileDescriptor` is using inheritance, consider using composition instead.

Does `PosixInputForFileDescriptor` want to expose the complete interface (`fixGapAfterRead, ensureNextHead, prepareReadHead, updateHeadRemaining, readTextExact, readText, readTextExact, readText, discard, peekTo, tryPeek, discardExact, discard, readFully, readLong, readInt, readDouble, readFloat, readShort, readByte, close, release, hasBytes, canRead, peekTo`) of `AbstractInput` such that `PosixInputForFileDescriptor` can be used where `AbstractInput` is expected? Indicates __inheritance__.

Does `PosixInputForFileDescriptor` want only some/part of the behavior exposed by `AbstractInput`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  21 </span>@ExperimentalIoApi
<span class="lineno">  22 </span>fun Input(file: CPointer&lt;FILE&gt;): Input = PosixInputForFile(file)
<span class="lineno">  23 </span>
<span class="lineno">  24 </span><span class="error">private class PosixInputForFileDescriptor(val fileDescriptor: Int) : AbstractInput() {</span>
<span class="lineno">  25 </span><span class="error">    private var closed = false</span>
<span class="lineno">  26 </span><span class="error">    init {</span>
<span class="lineno">  27 </span><span class="error">        check(fileDescriptor &gt;= 0) { &quot;Illegal fileDescriptor: $fileDescriptor&quot; }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/streams/PosixInput.kt:53:1</span><span class="message">The class `PosixInputForFile` is using inheritance, consider using composition instead.

Does `PosixInputForFile` want to expose the complete interface (`fixGapAfterRead, ensureNextHead, prepareReadHead, updateHeadRemaining, readTextExact, readText, readTextExact, readText, discard, peekTo, tryPeek, discardExact, discard, readFully, readLong, readInt, readDouble, readFloat, readShort, readByte, close, release, hasBytes, canRead, peekTo`) of `AbstractInput` such that `PosixInputForFile` can be used where `AbstractInput` is expected? Indicates __inheritance__.

Does `PosixInputForFile` want only some/part of the behavior exposed by `AbstractInput`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  50 </span>    }
<span class="lineno">  51 </span>}
<span class="lineno">  52 </span>
<span class="lineno">  53 </span><span class="error">private class PosixInputForFile(val file: CPointer&lt;FILE&gt;) : AbstractInput() {</span>
<span class="lineno">  54 </span><span class="error">    private var closed = false</span>
<span class="lineno">  55 </span><span class="error"></span>
<span class="lineno">  56 </span><span class="error">    override fun fill(destination: Memory, offset: Int, length: Int): Int {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/streams/PosixOutput.kt:24:1</span><span class="message">The class `PosixFileDescriptorOutput` is using inheritance, consider using composition instead.

Does `PosixFileDescriptorOutput` want to expose the complete interface (`reset, appendNewBuffer, afterHeadWrite, prepareWriteHead, release, writeStringUtf8, writeStringUtf8, append, writePacket, writePacket, writePacket, append, append, append, close, writeByte, flush`) of `AbstractOutput` such that `PosixFileDescriptorOutput` can be used where `AbstractOutput` is expected? Indicates __inheritance__.

Does `PosixFileDescriptorOutput` want only some/part of the behavior exposed by `AbstractOutput`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  21 </span>@ExperimentalIoApi
<span class="lineno">  22 </span>fun Output(file: CPointer&lt;FILE&gt;): Output = PosixFileInstanceOutput(file)
<span class="lineno">  23 </span>
<span class="lineno">  24 </span><span class="error">private class PosixFileDescriptorOutput(val fileDescriptor: Int) : AbstractOutput() {</span>
<span class="lineno">  25 </span><span class="error">    private var closed = false</span>
<span class="lineno">  26 </span><span class="error"></span>
<span class="lineno">  27 </span><span class="error">    init {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-io/posix/src/io/ktor/utils/io/streams/PosixOutput.kt:59:1</span><span class="message">The class `PosixFileInstanceOutput` is using inheritance, consider using composition instead.

Does `PosixFileInstanceOutput` want to expose the complete interface (`reset, appendNewBuffer, afterHeadWrite, prepareWriteHead, release, writeStringUtf8, writeStringUtf8, append, writePacket, writePacket, writePacket, append, append, append, close, writeByte, flush`) of `AbstractOutput` such that `PosixFileInstanceOutput` can be used where `AbstractOutput` is expected? Indicates __inheritance__.

Does `PosixFileInstanceOutput` want only some/part of the behavior exposed by `AbstractOutput`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  56 </span>    }
<span class="lineno">  57 </span>}
<span class="lineno">  58 </span>
<span class="lineno">  59 </span><span class="error">private class PosixFileInstanceOutput(val file: CPointer&lt;FILE&gt;) : AbstractOutput() {</span>
<span class="lineno">  60 </span><span class="error">    private var closed = false</span>
<span class="lineno">  61 </span><span class="error"></span>
<span class="lineno">  62 </span><span class="error">    override fun flush(source: Memory, offset: Int, length: Int) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/selector/ActorSelectorManager.kt:16:1</span><span class="message">The class `ActorSelectorManager` is using inheritance, consider using composition instead.

Does `ActorSelectorManager` want to expose the complete interface (`select`) of `SelectorManagerSupport` such that `ActorSelectorManager` can be used where `SelectorManagerSupport` is expected? Indicates __inheritance__.

Does `ActorSelectorManager` want only some/part of the behavior exposed by `SelectorManagerSupport`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import kotlin.coroutines.*
<span class="lineno">  14 </span>import kotlin.coroutines.intrinsics.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">/**</span>
<span class="lineno">  17 </span><span class="error"> * Default CIO selector manager implementation</span>
<span class="lineno">  18 </span><span class="error"> */</span>
<span class="lineno">  19 </span><span class="error">@Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/sockets/SocketImpl.kt:11:1</span><span class="message">The class `SocketImpl` is using inheritance, consider using composition instead.

Does `SocketImpl` want to expose the complete interface (`close, dispose, attachForWriting, attachForReading`) of `NIOSocketImpl` such that `SocketImpl` can be used where `NIOSocketImpl` is expected? Indicates __inheritance__.

Does `SocketImpl` want only some/part of the behavior exposed by `NIOSocketImpl`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import java.net.*
<span class="lineno">   9 </span>import java.nio.channels.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class SocketImpl&lt;out S : SocketChannel&gt;(</span>
<span class="lineno">  12 </span><span class="error">    override val channel: S,</span>
<span class="lineno">  13 </span><span class="error">    private val socket: java.net.Socket,</span>
<span class="lineno">  14 </span><span class="error">    selector: SelectorManager,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/sockets/SocketOptions.kt:40:5</span><span class="message">The class `GeneralSocketOptions` is using inheritance, consider using composition instead.

Does `GeneralSocketOptions` want to expose the complete interface (`empty public interface`) of `SocketOptions` such that `GeneralSocketOptions` can be used where `SocketOptions` is expected? Indicates __inheritance__.

Does `GeneralSocketOptions` want only some/part of the behavior exposed by `SocketOptions`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  37 </span>        }
<span class="lineno">  38 </span>    }
<span class="lineno">  39 </span>
<span class="lineno">  40 </span>    <span class="error">private class GeneralSocketOptions constructor(customOptions: MutableMap&lt;Any, Any?&gt;) :</span>
<span class="lineno">  41 </span><span class="error">        SocketOptions(customOptions) {</span>
<span class="lineno">  42 </span><span class="error">        override fun copy(): GeneralSocketOptions = GeneralSocketOptions(HashMap(customOptions)).apply {</span>
<span class="lineno">  43 </span><span class="error">            copyCommon(this@GeneralSocketOptions)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/sockets/SocketOptions.kt:62:5</span><span class="message">The class `AcceptorOptions` is using inheritance, consider using composition instead.

Does `AcceptorOptions` want to expose the complete interface (`empty public interface`) of `SocketOptions` such that `AcceptorOptions` can be used where `SocketOptions` is expected? Indicates __inheritance__.

Does `AcceptorOptions` want only some/part of the behavior exposed by `SocketOptions`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  59 </span>     */
<span class="lineno">  60 </span>    var reusePort: Boolean = false
<span class="lineno">  61 </span>
<span class="lineno">  62 </span>    <span class="error">/**</span>
<span class="lineno">  63 </span><span class="error">     * TCP server socket options</span>
<span class="lineno">  64 </span><span class="error">     */</span>
<span class="lineno">  65 </span><span class="error">    class AcceptorOptions internal constructor(customOptions: MutableMap&lt;Any, Any?&gt;) : SocketOptions(customOptions) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/sockets/SocketOptions.kt:73:5</span><span class="message">The class `PeerSocketOptions` is using inheritance, consider using composition instead.

Does `PeerSocketOptions` want to expose the complete interface (`empty public interface`) of `SocketOptions` such that `PeerSocketOptions` can be used where `SocketOptions` is expected? Indicates __inheritance__.

Does `PeerSocketOptions` want only some/part of the behavior exposed by `SocketOptions`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  70 </span>        }
<span class="lineno">  71 </span>    }
<span class="lineno">  72 </span>
<span class="lineno">  73 </span>    <span class="error">/**</span>
<span class="lineno">  74 </span><span class="error">     * Represents TCP client or UDP socket options</span>
<span class="lineno">  75 </span><span class="error">     */</span>
<span class="lineno">  76 </span><span class="error">    open class PeerSocketOptions internal constructor(customOptions: MutableMap&lt;Any, Any?&gt;) :</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/sockets/SocketOptions.kt:117:5</span><span class="message">The class `UDPSocketOptions` is using inheritance, consider using composition instead.

Does `UDPSocketOptions` want to expose the complete interface (`copy, copyCommon`) of `PeerSocketOptions` such that `UDPSocketOptions` can be used where `PeerSocketOptions` is expected? Indicates __inheritance__.

Does `UDPSocketOptions` want only some/part of the behavior exposed by `PeerSocketOptions`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 114 </span>        }
<span class="lineno"> 115 </span>    }
<span class="lineno"> 116 </span>
<span class="lineno"> 117 </span>    <span class="error">/**</span>
<span class="lineno"> 118 </span><span class="error">     * Represents UDP socket options</span>
<span class="lineno"> 119 </span><span class="error">     */</span>
<span class="lineno"> 120 </span><span class="error">    class UDPSocketOptions internal constructor(customOptions: MutableMap&lt;Any, Any?&gt;) :</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/sockets/SocketOptions.kt:129:5</span><span class="message">The class `TCPClientSocketOptions` is using inheritance, consider using composition instead.

Does `TCPClientSocketOptions` want to expose the complete interface (`copy, copyCommon`) of `PeerSocketOptions` such that `TCPClientSocketOptions` can be used where `PeerSocketOptions` is expected? Indicates __inheritance__.

Does `TCPClientSocketOptions` want only some/part of the behavior exposed by `PeerSocketOptions`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 126 </span>        }
<span class="lineno"> 127 </span>    }
<span class="lineno"> 128 </span>
<span class="lineno"> 129 </span>    <span class="error">/**</span>
<span class="lineno"> 130 </span><span class="error">     * Represents TCP client socket options</span>
<span class="lineno"> 131 </span><span class="error">     */</span>
<span class="lineno"> 132 </span><span class="error">    class TCPClientSocketOptions internal constructor(customOptions: MutableMap&lt;Any, Any?&gt;) :</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/util/IOCoroutineDispatcher.kt:154:5</span><span class="message">The class `Poison` is using inheritance, consider using composition instead.

Does `Poison` want to expose the complete interface (`toString, removeFirstIfIsInstanceOfOrPeekIf, removeFirstIfIsInstanceOf, describeRemoveFirst, removeFirstOrNull, describeRemove, helpRemove, remove, addLastIfPrevAndIf, addLastIfPrev, addLastIf, describeAddLast, addLast, addOneIfEmpty`) of `LockFreeLinkedListNode` such that `Poison` can be used where `LockFreeLinkedListNode` is expected? Indicates __inheritance__.

Does `Poison` want only some/part of the behavior exposed by `LockFreeLinkedListNode`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 151 </span>        }
<span class="lineno"> 152 </span>    }
<span class="lineno"> 153 </span>
<span class="lineno"> 154 </span>    <span class="error">private class Poison : LockFreeLinkedListNode()</span>
<span class="lineno"> 155 </span>    private class IODispatchedTask(val r: Runnable) : LockFreeLinkedListNode(), Runnable by r
<span class="lineno"> 156 </span>}
<span class="lineno"> 157 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/util/IOCoroutineDispatcher.kt:155:5</span><span class="message">The class `IODispatchedTask` is using inheritance, consider using composition instead.

Does `IODispatchedTask` want to expose the complete interface (`toString, removeFirstIfIsInstanceOfOrPeekIf, removeFirstIfIsInstanceOf, describeRemoveFirst, removeFirstOrNull, describeRemove, helpRemove, remove, addLastIfPrevAndIf, addLastIfPrev, addLastIf, describeAddLast, addLast, addOneIfEmpty`) of `LockFreeLinkedListNode` such that `IODispatchedTask` can be used where `LockFreeLinkedListNode` is expected? Indicates __inheritance__.

Does `IODispatchedTask` want only some/part of the behavior exposed by `LockFreeLinkedListNode`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 152 </span>    }
<span class="lineno"> 153 </span>
<span class="lineno"> 154 </span>    private class Poison : LockFreeLinkedListNode()
<span class="lineno"> 155 </span>    <span class="error">private class IODispatchedTask(val r: Runnable) : LockFreeLinkedListNode(), Runnable by r</span>
<span class="lineno"> 156 </span>}
<span class="lineno"> 157 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-network/jvm/src/io/ktor/network/util/Pools.kt:50:1</span><span class="message">The class `DirectByteBufferPool` is using inheritance, consider using composition instead.

Does `DirectByteBufferPool` want to expose the complete interface (`dispose, recycle, borrow`) of `DefaultPool` such that `DirectByteBufferPool` can be used where `DefaultPool` is expected? Indicates __inheritance__.

Does `DirectByteBufferPool` want only some/part of the behavior exposed by `DefaultPool`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  47 </span>@InternalAPI
<span class="lineno">  48 </span>val DefaultDatagramByteBufferPool: ObjectPool&lt;ByteBuffer&gt; = DirectByteBufferPool(MAX_DATAGRAM_SIZE, 2048)
<span class="lineno">  49 </span>
<span class="lineno">  50 </span><span class="error">internal class DirectByteBufferPool(private val bufferSize: Int, size: Int) : DefaultPool&lt;ByteBuffer&gt;(size) {</span>
<span class="lineno">  51 </span><span class="error">    override fun produceInstance(): ByteBuffer = java.nio.ByteBuffer.allocateDirect(bufferSize)</span>
<span class="lineno">  52 </span><span class="error"></span>
<span class="lineno">  53 </span><span class="error">    override fun clearInstance(instance: ByteBuffer): ByteBuffer {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/PipelineBenchmark.kt:80:1</span><span class="message">The class `PipelineFork` is using inheritance, consider using composition instead.

Does `PipelineFork` want to expose the complete interface (`execute, configure, createPipeline, executeBlocking, intercept, pipeline`) of `PipelineBenchmark` such that `PipelineFork` can be used where `PipelineBenchmark` is expected? Indicates __inheritance__.

Does `PipelineFork` want only some/part of the behavior exposed by `PipelineBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  77 </span>    }
<span class="lineno">  78 </span>}
<span class="lineno">  79 </span>
<span class="lineno">  80 </span><span class="error">open class PipelineFork : PipelineBenchmark() {</span>
<span class="lineno">  81 </span><span class="error">    override fun Pipeline&lt;String, ApplicationCall&gt;.configure() {</span>
<span class="lineno">  82 </span><span class="error">        val another = pipeline()</span>
<span class="lineno">  83 </span><span class="error">        another.intercept { proceed() }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/PipelineBenchmark.kt:91:1</span><span class="message">The class `PipelineFork2` is using inheritance, consider using composition instead.

Does `PipelineFork2` want to expose the complete interface (`execute, configure, createPipeline, executeBlocking, intercept, pipeline`) of `PipelineBenchmark` such that `PipelineFork2` can be used where `PipelineBenchmark` is expected? Indicates __inheritance__.

Does `PipelineFork2` want only some/part of the behavior exposed by `PipelineBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  88 </span>    }
<span class="lineno">  89 </span>}
<span class="lineno">  90 </span>
<span class="lineno">  91 </span><span class="error">open class PipelineFork2 : PipelineBenchmark() {</span>
<span class="lineno">  92 </span><span class="error">    override fun Pipeline&lt;String, ApplicationCall&gt;.configure() {</span>
<span class="lineno">  93 </span><span class="error">        val another = pipeline()</span>
<span class="lineno">  94 </span><span class="error">        val double = pipeline()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/PipelineBenchmark.kt:107:1</span><span class="message">The class `PipelineFork2Implicit` is using inheritance, consider using composition instead.

Does `PipelineFork2Implicit` want to expose the complete interface (`execute, configure, createPipeline, executeBlocking, intercept, pipeline`) of `PipelineBenchmark` such that `PipelineFork2Implicit` can be used where `PipelineBenchmark` is expected? Indicates __inheritance__.

Does `PipelineFork2Implicit` want only some/part of the behavior exposed by `PipelineBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 104 </span>    }
<span class="lineno"> 105 </span>}
<span class="lineno"> 106 </span>
<span class="lineno"> 107 </span><span class="error">open class PipelineFork2Implicit : PipelineBenchmark() {</span>
<span class="lineno"> 108 </span><span class="error">    override fun Pipeline&lt;String, ApplicationCall&gt;.configure() {</span>
<span class="lineno"> 109 </span><span class="error">        val another = pipeline()</span>
<span class="lineno"> 110 </span><span class="error">        val double = pipeline()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/PipelineBenchmark.kt:117:1</span><span class="message">The class `PipelineAction` is using inheritance, consider using composition instead.

Does `PipelineAction` want to expose the complete interface (`execute, configure, createPipeline, executeBlocking, intercept, pipeline`) of `PipelineBenchmark` such that `PipelineAction` can be used where `PipelineBenchmark` is expected? Indicates __inheritance__.

Does `PipelineAction` want only some/part of the behavior exposed by `PipelineBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 114 </span>    }
<span class="lineno"> 115 </span>}
<span class="lineno"> 116 </span>
<span class="lineno"> 117 </span><span class="error">open class PipelineAction : PipelineBenchmark() {</span>
<span class="lineno"> 118 </span><span class="error">    override fun Pipeline&lt;String, ApplicationCall&gt;.configure() {</span>
<span class="lineno"> 119 </span><span class="error">        pipeline.intercept { proceed() }</span>
<span class="lineno"> 120 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/PipelineBenchmark.kt:123:1</span><span class="message">The class `PipelineAction2` is using inheritance, consider using composition instead.

Does `PipelineAction2` want to expose the complete interface (`execute, configure, createPipeline, executeBlocking, intercept, pipeline`) of `PipelineBenchmark` such that `PipelineAction2` can be used where `PipelineBenchmark` is expected? Indicates __inheritance__.

Does `PipelineAction2` want only some/part of the behavior exposed by `PipelineBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 120 </span>    }
<span class="lineno"> 121 </span>}
<span class="lineno"> 122 </span>
<span class="lineno"> 123 </span><span class="error">open class PipelineAction2 : PipelineBenchmark() {</span>
<span class="lineno"> 124 </span><span class="error">    override fun Pipeline&lt;String, ApplicationCall&gt;.configure() {</span>
<span class="lineno"> 125 </span><span class="error">        pipeline.intercept { proceed() }</span>
<span class="lineno"> 126 </span><span class="error">        pipeline.intercept { proceed() }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/PipelineBenchmark.kt:130:1</span><span class="message">The class `PipelineAction3` is using inheritance, consider using composition instead.

Does `PipelineAction3` want to expose the complete interface (`execute, configure, createPipeline, executeBlocking, intercept, pipeline`) of `PipelineBenchmark` such that `PipelineAction3` can be used where `PipelineBenchmark` is expected? Indicates __inheritance__.

Does `PipelineAction3` want only some/part of the behavior exposed by `PipelineBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 127 </span>    }
<span class="lineno"> 128 </span>}
<span class="lineno"> 129 </span>
<span class="lineno"> 130 </span><span class="error">open class PipelineAction3 : PipelineBenchmark() {</span>
<span class="lineno"> 131 </span><span class="error">    override fun Pipeline&lt;String, ApplicationCall&gt;.configure() {</span>
<span class="lineno"> 132 </span><span class="error">        pipeline.intercept { proceed() }</span>
<span class="lineno"> 133 </span><span class="error">        pipeline.intercept { proceed() }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/PipelineBenchmark.kt:138:1</span><span class="message">The class `PipelineAction3Implicit` is using inheritance, consider using composition instead.

Does `PipelineAction3Implicit` want to expose the complete interface (`execute, configure, createPipeline, executeBlocking, intercept, pipeline`) of `PipelineBenchmark` such that `PipelineAction3Implicit` can be used where `PipelineBenchmark` is expected? Indicates __inheritance__.

Does `PipelineAction3Implicit` want only some/part of the behavior exposed by `PipelineBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 135 </span>    }
<span class="lineno"> 136 </span>}
<span class="lineno"> 137 </span>
<span class="lineno"> 138 </span><span class="error">open class PipelineAction3Implicit : PipelineBenchmark() {</span>
<span class="lineno"> 139 </span><span class="error">    override fun Pipeline&lt;String, ApplicationCall&gt;.configure() {</span>
<span class="lineno"> 140 </span><span class="error">        pipeline.intercept { }</span>
<span class="lineno"> 141 </span><span class="error">        pipeline.intercept { }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/cio/CIOIntegrationBenchmark.kt:13:1</span><span class="message">The class `CIOIntegrationBenchmark` is using inheritance, consider using composition instead.

Does `CIOIntegrationBenchmark` want to expose the complete interface (`largeFileSync, largeFile, smallFileSync, smallFile, regularClasspathFile, jarfile, thinkOK, query, longPath, sayOK, random, shutdownClient, configureClient, shutdownServer, configureServer, createServer`) of `IntegrationBenchmark` such that `CIOIntegrationBenchmark` can be used where `IntegrationBenchmark` is expected? Indicates __inheritance__.

Does `CIOIntegrationBenchmark` want only some/part of the behavior exposed by `IntegrationBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import io.ktor.server.cio.backend.*
<span class="lineno">  11 </span>import io.ktor.server.engine.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class CIOIntegrationBenchmark : IntegrationBenchmark&lt;CIOApplicationEngine&gt;() {</span>
<span class="lineno">  14 </span><span class="error">    override fun createServer(port: Int, main: Application.() -&gt; Unit): CIOApplicationEngine {</span>
<span class="lineno">  15 </span><span class="error">        return embeddedServer(CIO, port, module = main)</span>
<span class="lineno">  16 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/cio/CIOIntegrationBenchmark.kt:19:1</span><span class="message">The class `CIOAsyncIntegrationBenchmark` is using inheritance, consider using composition instead.

Does `CIOAsyncIntegrationBenchmark` want to expose the complete interface (`largeFileSync, largeFile, smallFile, regularClasspathFile, jarfile, thinkOk, query, longPath, sayOK, largeFileSyncLoad, largeFileLoad, smallFileSyncLoad, smallFileLoad, regularClasspathFileLoad, jarfileLoad, thinkOKLoad, queryLoad, longPathLoad, sayOKLoad, shutdownServer, join, load, configureServer, createServer`) of `AsyncIntegrationBenchmark` such that `CIOAsyncIntegrationBenchmark` can be used where `AsyncIntegrationBenchmark` is expected? Indicates __inheritance__.

Does `CIOAsyncIntegrationBenchmark` want only some/part of the behavior exposed by `AsyncIntegrationBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>    }
<span class="lineno">  17 </span>}
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">class CIOAsyncIntegrationBenchmark : AsyncIntegrationBenchmark&lt;CIOApplicationEngine&gt;() {</span>
<span class="lineno">  20 </span><span class="error">    override fun createServer(port: Int, main: Application.() -&gt; Unit): CIOApplicationEngine {</span>
<span class="lineno">  21 </span><span class="error">        return embeddedServer(CIO, port, module = main)</span>
<span class="lineno">  22 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/cio/CIOPlatformBenchmark.kt:16:1</span><span class="message">The class `CIOPlatformBenchmark` is using inheritance, consider using composition instead.

Does `CIOPlatformBenchmark` want to expose the complete interface (`sayOK, shutdownClient, configureClient, shutdownServer, setupServer, stopServer, runServer`) of `PlatformBenchmark` such that `CIOPlatformBenchmark` can be used where `PlatformBenchmark` is expected? Indicates __inheritance__.

Does `CIOPlatformBenchmark` want only some/part of the behavior exposed by `PlatformBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import kotlinx.coroutines.*
<span class="lineno">  14 </span>import io.ktor.utils.io.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">class CIOPlatformBenchmark : PlatformBenchmark() {</span>
<span class="lineno">  17 </span><span class="error">    private var server: HttpServer? = null</span>
<span class="lineno">  18 </span><span class="error"></span>
<span class="lineno">  19 </span><span class="error">    private var sayOK = RequestResponseBuilder().apply {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/jetty/JettyIntegrationBenchmark.kt:12:1</span><span class="message">The class `JettyIntegrationBenchmark` is using inheritance, consider using composition instead.

Does `JettyIntegrationBenchmark` want to expose the complete interface (`largeFileSync, largeFile, smallFileSync, smallFile, regularClasspathFile, jarfile, thinkOK, query, longPath, sayOK, random, shutdownClient, configureClient, shutdownServer, configureServer, createServer`) of `IntegrationBenchmark` such that `JettyIntegrationBenchmark` can be used where `IntegrationBenchmark` is expected? Indicates __inheritance__.

Does `JettyIntegrationBenchmark` want only some/part of the behavior exposed by `IntegrationBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import io.ktor.server.engine.*
<span class="lineno">  10 </span>import io.ktor.server.jetty.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class JettyIntegrationBenchmark : IntegrationBenchmark&lt;JettyApplicationEngine&gt;() {</span>
<span class="lineno">  13 </span><span class="error">    override fun createServer(port: Int, main: Application.() -&gt; Unit): JettyApplicationEngine {</span>
<span class="lineno">  14 </span><span class="error">        return embeddedServer(Jetty, port, module = main)</span>
<span class="lineno">  15 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/jetty/JettyIntegrationBenchmark.kt:18:1</span><span class="message">The class `JettyAsyncIntegrationBenchmark` is using inheritance, consider using composition instead.

Does `JettyAsyncIntegrationBenchmark` want to expose the complete interface (`largeFileSync, largeFile, smallFile, regularClasspathFile, jarfile, thinkOk, query, longPath, sayOK, largeFileSyncLoad, largeFileLoad, smallFileSyncLoad, smallFileLoad, regularClasspathFileLoad, jarfileLoad, thinkOKLoad, queryLoad, longPathLoad, sayOKLoad, shutdownServer, join, load, configureServer, createServer`) of `AsyncIntegrationBenchmark` such that `JettyAsyncIntegrationBenchmark` can be used where `AsyncIntegrationBenchmark` is expected? Indicates __inheritance__.

Does `JettyAsyncIntegrationBenchmark` want only some/part of the behavior exposed by `AsyncIntegrationBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>    }
<span class="lineno">  16 </span>}
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">class JettyAsyncIntegrationBenchmark : AsyncIntegrationBenchmark&lt;JettyApplicationEngine&gt;() {</span>
<span class="lineno">  19 </span><span class="error">    override fun createServer(port: Int, main: Application.() -&gt; Unit): JettyApplicationEngine {</span>
<span class="lineno">  20 </span><span class="error">        return embeddedServer(Jetty, port, module = main)</span>
<span class="lineno">  21 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/jetty/JettyPlatformBenchmark.kt:16:1</span><span class="message">The class `JettyPlatformBenchmark` is using inheritance, consider using composition instead.

Does `JettyPlatformBenchmark` want to expose the complete interface (`sayOK, shutdownClient, configureClient, shutdownServer, setupServer, stopServer, runServer`) of `PlatformBenchmark` such that `JettyPlatformBenchmark` can be used where `PlatformBenchmark` is expected? Indicates __inheritance__.

Does `JettyPlatformBenchmark` want only some/part of the behavior exposed by `PlatformBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import javax.servlet.*
<span class="lineno">  14 </span>import javax.servlet.http.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">class JettyPlatformBenchmark : PlatformBenchmark() {</span>
<span class="lineno">  17 </span><span class="error">    lateinit var server: Server</span>
<span class="lineno">  18 </span><span class="error"></span>
<span class="lineno">  19 </span><span class="error">    override fun runServer(port: Int) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/netty/NettyIntegrationBenchmark.kt:12:1</span><span class="message">The class `NettyIntegrationBenchmark` is using inheritance, consider using composition instead.

Does `NettyIntegrationBenchmark` want to expose the complete interface (`largeFileSync, largeFile, smallFileSync, smallFile, regularClasspathFile, jarfile, thinkOK, query, longPath, sayOK, random, shutdownClient, configureClient, shutdownServer, configureServer, createServer`) of `IntegrationBenchmark` such that `NettyIntegrationBenchmark` can be used where `IntegrationBenchmark` is expected? Indicates __inheritance__.

Does `NettyIntegrationBenchmark` want only some/part of the behavior exposed by `IntegrationBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import io.ktor.server.engine.*
<span class="lineno">  10 </span>import io.ktor.server.netty.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class NettyIntegrationBenchmark : IntegrationBenchmark&lt;NettyApplicationEngine&gt;() {</span>
<span class="lineno">  13 </span><span class="error">    override fun createServer(port: Int, main: Application.() -&gt; Unit): NettyApplicationEngine {</span>
<span class="lineno">  14 </span><span class="error">        return embeddedServer(Netty, port, module = main)</span>
<span class="lineno">  15 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/netty/NettyIntegrationBenchmark.kt:18:1</span><span class="message">The class `NettyAsyncIntegrationBenchmark` is using inheritance, consider using composition instead.

Does `NettyAsyncIntegrationBenchmark` want to expose the complete interface (`largeFileSync, largeFile, smallFile, regularClasspathFile, jarfile, thinkOk, query, longPath, sayOK, largeFileSyncLoad, largeFileLoad, smallFileSyncLoad, smallFileLoad, regularClasspathFileLoad, jarfileLoad, thinkOKLoad, queryLoad, longPathLoad, sayOKLoad, shutdownServer, join, load, configureServer, createServer`) of `AsyncIntegrationBenchmark` such that `NettyAsyncIntegrationBenchmark` can be used where `AsyncIntegrationBenchmark` is expected? Indicates __inheritance__.

Does `NettyAsyncIntegrationBenchmark` want only some/part of the behavior exposed by `AsyncIntegrationBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>    }
<span class="lineno">  16 </span>}
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">class NettyAsyncIntegrationBenchmark : AsyncIntegrationBenchmark&lt;NettyApplicationEngine&gt;() {</span>
<span class="lineno">  19 </span><span class="error">    override fun createServer(port: Int, main: Application.() -&gt; Unit): NettyApplicationEngine {</span>
<span class="lineno">  20 </span><span class="error">        return embeddedServer(Netty, port, module = main)</span>
<span class="lineno">  21 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/netty/NettyPlatformBenchmark.kt:19:1</span><span class="message">The class `NettyPlatformBenchmark` is using inheritance, consider using composition instead.

Does `NettyPlatformBenchmark` want to expose the complete interface (`sayOK, shutdownClient, configureClient, shutdownServer, setupServer, stopServer, runServer`) of `PlatformBenchmark` such that `NettyPlatformBenchmark` can be used where `PlatformBenchmark` is expected? Indicates __inheritance__.

Does `NettyPlatformBenchmark` want only some/part of the behavior exposed by `PlatformBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>import java.net.*
<span class="lineno">  17 </span>import java.util.concurrent.*
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">class NettyPlatformBenchmark : PlatformBenchmark() {</span>
<span class="lineno">  20 </span><span class="error">    private lateinit var channel: Channel</span>
<span class="lineno">  21 </span><span class="error">    val eventLoopGroup = NioEventLoopGroup()</span>
<span class="lineno">  22 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-benchmarks/src/jmh/kotlin/io/ktor/server/benchmarks/test/TestIntegrationBenchmark.kt:13:1</span><span class="message">The class `TestIntegrationBenchmark` is using inheritance, consider using composition instead.

Does `TestIntegrationBenchmark` want to expose the complete interface (`largeFileSync, largeFile, smallFileSync, smallFile, regularClasspathFile, jarfile, thinkOK, query, longPath, sayOK, random, shutdownClient, configureClient, shutdownServer, configureServer, createServer`) of `IntegrationBenchmark` such that `TestIntegrationBenchmark` can be used where `IntegrationBenchmark` is expected? Indicates __inheritance__.

Does `TestIntegrationBenchmark` want only some/part of the behavior exposed by `IntegrationBenchmark`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import io.ktor.server.engine.*
<span class="lineno">  11 </span>import io.ktor.server.testing.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class TestIntegrationBenchmark : IntegrationBenchmark&lt;TestApplicationEngine&gt;() {</span>
<span class="lineno">  14 </span><span class="error"></span>
<span class="lineno">  15 </span><span class="error">    override val localhost: String = &quot;&quot;</span>
<span class="lineno">  16 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-cio/jvm/src/io/ktor/server/cio/CIOApplicationCall.kt:15:1</span><span class="message">The class `CIOApplicationCall` is using inheritance, consider using composition instead.

Does `CIOApplicationCall` want to expose the complete interface (`empty public interface`) of `BaseApplicationCall` such that `CIOApplicationCall` can be used where `BaseApplicationCall` is expected? Indicates __inheritance__.

Does `CIOApplicationCall` want only some/part of the behavior exposed by `BaseApplicationCall`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>import java.net.*
<span class="lineno">  13 </span>import kotlin.coroutines.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">internal class CIOApplicationCall(</span>
<span class="lineno">  16 </span><span class="error">    application: Application,</span>
<span class="lineno">  17 </span><span class="error">    _request: Request,</span>
<span class="lineno">  18 </span><span class="error">    input: ByteReadChannel,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-cio/jvm/src/io/ktor/server/cio/CIOApplicationEngine.kt:16:1</span><span class="message">The class `CIOApplicationEngine` is using inheritance, consider using composition instead.

Does `CIOApplicationEngine` want to expose the complete interface (`empty public interface`) of `BaseApplicationEngine` such that `CIOApplicationEngine` can be used where `BaseApplicationEngine` is expected? Indicates __inheritance__.

Does `CIOApplicationEngine` want only some/part of the behavior exposed by `BaseApplicationEngine`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import kotlinx.coroutines.scheduling.*
<span class="lineno">  14 </span>import java.net.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">/**</span>
<span class="lineno">  17 </span><span class="error"> * Engine that based on CIO backend</span>
<span class="lineno">  18 </span><span class="error"> */</span>
<span class="lineno">  19 </span><span class="error">class CIOApplicationEngine(environment: ApplicationEngineEnvironment, configure: Configuration.() -&gt; Unit) :</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-cio/jvm/src/io/ktor/server/cio/CIOApplicationEngine.kt:22:5</span><span class="message">The class `Configuration` is using inheritance, consider using composition instead.

Does `Configuration` want to expose the complete interface (`empty public interface`) of `Configuration` such that `Configuration` can be used where `Configuration` is expected? Indicates __inheritance__.

Does `Configuration` want only some/part of the behavior exposed by `Configuration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  19 </span>class CIOApplicationEngine(environment: ApplicationEngineEnvironment, configure: Configuration.() -&gt; Unit) :
<span class="lineno">  20 </span>    BaseApplicationEngine(environment) {
<span class="lineno">  21 </span>
<span class="lineno">  22 </span>    <span class="error">/**</span>
<span class="lineno">  23 </span><span class="error">     * CIO-based server configuration</span>
<span class="lineno">  24 </span><span class="error">     */</span>
<span class="lineno">  25 </span><span class="error">    class Configuration : BaseApplicationEngine.Configuration() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-cio/jvm/src/io/ktor/server/cio/CIOApplicationRequest.kt:15:1</span><span class="message">The class `CIOApplicationRequest` is using inheritance, consider using composition instead.

Does `CIOApplicationRequest` want to expose the complete interface (`empty public interface`) of `BaseApplicationRequest` such that `CIOApplicationRequest` can be used where `BaseApplicationRequest` is expected? Indicates __inheritance__.

Does `CIOApplicationRequest` want only some/part of the behavior exposed by `BaseApplicationRequest`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>import io.ktor.utils.io.*
<span class="lineno">  13 </span>import java.net.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">internal class CIOApplicationRequest(</span>
<span class="lineno">  16 </span><span class="error">    call: ApplicationCall,</span>
<span class="lineno">  17 </span><span class="error">    private val remoteAddress: InetSocketAddress?,</span>
<span class="lineno">  18 </span><span class="error">    private val localAddress: InetSocketAddress?,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-cio/jvm/src/io/ktor/server/cio/CIOApplicationResponse.kt:16:1</span><span class="message">The class `CIOApplicationResponse` is using inheritance, consider using composition instead.

Does `CIOApplicationResponse` want to expose the complete interface (`push, status, status`) of `BaseApplicationResponse` such that `CIOApplicationResponse` can be used where `BaseApplicationResponse` is expected? Indicates __inheritance__.

Does `CIOApplicationResponse` want only some/part of the behavior exposed by `BaseApplicationResponse`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import io.ktor.utils.io.*
<span class="lineno">  14 </span>import kotlin.coroutines.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">internal class CIOApplicationResponse(call: CIOApplicationCall,</span>
<span class="lineno">  17 </span><span class="error">                             private val output: ByteWriteChannel,</span>
<span class="lineno">  18 </span><span class="error">                             private val input: ByteReadChannel,</span>
<span class="lineno">  19 </span><span class="error">                             private val engineDispatcher: CoroutineContext,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/application/Application.kt:9:1</span><span class="message">The class `Application` is using inheritance, consider using composition instead.

Does `Application` want to expose the complete interface (`empty public interface`) of `ApplicationCallPipeline` such that `Application` can be used where `ApplicationCallPipeline` is expected? Indicates __inheritance__.

Does `Application` want only some/part of the behavior exposed by `ApplicationCallPipeline`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>
<span class="lineno">   7 </span>import kotlinx.coroutines.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">/**</span>
<span class="lineno">  10 </span><span class="error"> * Represents configured and running web application, capable of handling requests.</span>
<span class="lineno">  11 </span><span class="error"> * It is also the application coroutine scope that is cancelled immediately at application stop so useful</span>
<span class="lineno">  12 </span><span class="error"> * for launching background coroutines.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/application/ApplicationCallPipeline.kt:11:1</span><span class="message">The class `ApplicationCallPipeline` is using inheritance, consider using composition instead.

Does `ApplicationCallPipeline` want to expose the complete interface (`merge, afterIntercepted, intercept, insertPhaseBefore, insertPhaseAfter, addPhase, execute`) of `Pipeline` such that `ApplicationCallPipeline` can be used where `Pipeline` is expected? Indicates __inheritance__.

Does `ApplicationCallPipeline` want only some/part of the behavior exposed by `Pipeline`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.request.*
<span class="lineno">   9 </span>import io.ktor.response.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * Pipeline configuration for executing [ApplicationCall] instances</span>
<span class="lineno">  13 </span><span class="error"> */</span>
<span class="lineno">  14 </span><span class="error">@Suppress(&quot;PublicApiImplicitType&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/application/ApplicationEvents.kt:54:5</span><span class="message">The class `HandlerRegistration` is using inheritance, consider using composition instead.

Does `HandlerRegistration` want to expose the complete interface (`toString, removeFirstIfIsInstanceOfOrPeekIf, removeFirstIfIsInstanceOf, describeRemoveFirst, removeFirstOrNull, describeRemove, helpRemove, remove, addLastIfPrevAndIf, addLastIfPrev, addLastIf, describeAddLast, addLast, addOneIfEmpty`) of `LockFreeLinkedListNode` such that `HandlerRegistration` can be used where `LockFreeLinkedListNode` is expected? Indicates __inheritance__.

Does `HandlerRegistration` want only some/part of the behavior exposed by `LockFreeLinkedListNode`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  51 </span>        exception?.let { throw it }
<span class="lineno">  52 </span>    }
<span class="lineno">  53 </span>
<span class="lineno">  54 </span>    <span class="error">private class HandlerRegistration(val handler: EventHandler&lt;*&gt;) : LockFreeLinkedListNode(), DisposableHandle {</span>
<span class="lineno">  55 </span><span class="error">        override fun dispose() {</span>
<span class="lineno">  56 </span><span class="error">            remove()</span>
<span class="lineno">  57 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/AutoHeadResponse.kt:41:5</span><span class="message">The class `HeadResponse` is using inheritance, consider using composition instead.

Does `HeadResponse` want to expose the complete interface (`empty public interface`) of `NoContent` such that `HeadResponse` can be used where `NoContent` is expected? Indicates __inheritance__.

Does `HeadResponse` want only some/part of the behavior exposed by `NoContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  38 </span>        }
<span class="lineno">  39 </span>    }
<span class="lineno">  40 </span>
<span class="lineno">  41 </span>    <span class="error">private class HeadResponse(val original: OutgoingContent) : OutgoingContent.NoContent() {</span>
<span class="lineno">  42 </span><span class="error">        override val status: HttpStatusCode? get() = original.status</span>
<span class="lineno">  43 </span><span class="error">        override val contentType: ContentType? get() = original.contentType</span>
<span class="lineno">  44 </span><span class="error">        override val contentLength: Long? get() = original.contentLength</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/Compression.kt:116:5</span><span class="message">The class `CompressedResponse` is using inheritance, consider using composition instead.

Does `CompressedResponse` want to expose the complete interface (`readFrom, readFrom`) of `ReadChannelContent` such that `CompressedResponse` can be used where `ReadChannelContent` is expected? Indicates __inheritance__.

Does `CompressedResponse` want only some/part of the behavior exposed by `ReadChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 113 </span>        }
<span class="lineno"> 114 </span>    }
<span class="lineno"> 115 </span>
<span class="lineno"> 116 </span>    <span class="error">private class CompressedResponse(</span>
<span class="lineno"> 117 </span><span class="error">        val original: OutgoingContent,</span>
<span class="lineno"> 118 </span><span class="error">        val delegateChannel: () -&gt; ByteReadChannel,</span>
<span class="lineno"> 119 </span><span class="error">        val encoding: String,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/Compression.kt:139:5</span><span class="message">The class `CompressedWriteResponse` is using inheritance, consider using composition instead.

Does `CompressedWriteResponse` want to expose the complete interface (`writeTo`) of `WriteChannelContent` such that `CompressedWriteResponse` can be used where `WriteChannelContent` is expected? Indicates __inheritance__.

Does `CompressedWriteResponse` want only some/part of the behavior exposed by `WriteChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 136 </span>        override fun &lt;T : Any&gt; setProperty(key: AttributeKey&lt;T&gt;, value: T?) = original.setProperty(key, value)
<span class="lineno"> 137 </span>    }
<span class="lineno"> 138 </span>
<span class="lineno"> 139 </span>    <span class="error">private class CompressedWriteResponse(</span>
<span class="lineno"> 140 </span><span class="error">        val original: WriteChannelContent,</span>
<span class="lineno"> 141 </span><span class="error">        val encoding: String,</span>
<span class="lineno"> 142 </span><span class="error">        val encoder: CompressionEncoder</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/DoubleReceive.kt:117:5</span><span class="message">The class `Success` is using inheritance, consider using composition instead.

Does `Success` want to expose the complete interface (`empty public interface`) of `CachedTransformationResult` such that `Success` can be used where `CachedTransformationResult` is expected? Indicates __inheritance__.

Does `Success` want only some/part of the behavior exposed by `CachedTransformationResult`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 114 </span> */
<span class="lineno"> 115 </span>@KtorExperimentalAPI
<span class="lineno"> 116 </span>sealed class CachedTransformationResult&lt;T : Any&gt;(val type: KType) {
<span class="lineno"> 117 </span>    <span class="error">/**</span>
<span class="lineno"> 118 </span><span class="error">     * Holds a transformation result [value] after a successful transformation.</span>
<span class="lineno"> 119 </span><span class="error">     * @property value</span>
<span class="lineno"> 120 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/DoubleReceive.kt:123:5</span><span class="message">The class `Failure` is using inheritance, consider using composition instead.

Does `Failure` want to expose the complete interface (`empty public interface`) of `CachedTransformationResult` such that `Failure` can be used where `CachedTransformationResult` is expected? Indicates __inheritance__.

Does `Failure` want only some/part of the behavior exposed by `CachedTransformationResult`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 120 </span>     */
<span class="lineno"> 121 </span>    class Success&lt;T : Any&gt;(type: KType, val value: T) : CachedTransformationResult&lt;T&gt;(type)
<span class="lineno"> 122 </span>
<span class="lineno"> 123 </span>    <span class="error">/**</span>
<span class="lineno"> 124 </span><span class="error">     * Holds a transformation failure [cause]</span>
<span class="lineno"> 125 </span><span class="error">     * @property cause describes transformation failure</span>
<span class="lineno"> 126 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/Errors.kt:28:1</span><span class="message">The class `MissingRequestParameterException` is using inheritance, consider using composition instead.

Does `MissingRequestParameterException` want to expose the complete interface (`empty public interface`) of `BadRequestException` such that `MissingRequestParameterException` can be used where `BadRequestException` is expected? Indicates __inheritance__.

Does `MissingRequestParameterException` want only some/part of the behavior exposed by `BadRequestException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  25 </span> */
<span class="lineno">  26 </span>class NotFoundException(message: String? = &quot;Resource not found&quot;) : Exception(message)
<span class="lineno">  27 </span>
<span class="lineno">  28 </span><span class="error">/**</span>
<span class="lineno">  29 </span><span class="error"> * This exception is thrown when a required parameter with name [parameterName] is missing</span>
<span class="lineno">  30 </span><span class="error"> * @property parameterName of missing request parameter</span>
<span class="lineno">  31 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/Errors.kt:43:1</span><span class="message">The class `ParameterConversionException` is using inheritance, consider using composition instead.

Does `ParameterConversionException` want to expose the complete interface (`empty public interface`) of `BadRequestException` such that `ParameterConversionException` can be used where `BadRequestException` is expected? Indicates __inheritance__.

Does `ParameterConversionException` want only some/part of the behavior exposed by `BadRequestException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  40 </span>    }
<span class="lineno">  41 </span>}
<span class="lineno">  42 </span>
<span class="lineno">  43 </span><span class="error">/**</span>
<span class="lineno">  44 </span><span class="error"> * This exception is thrown when a required parameter with name [parameterName] couldn't be converted to the [type]</span>
<span class="lineno">  45 </span><span class="error"> * @property parameterName of missing request parameter</span>
<span class="lineno">  46 </span><span class="error"> * @property type this parameter is unable to convert to</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/Errors.kt:66:1</span><span class="message">The class `CannotTransformContentToTypeException` is using inheritance, consider using composition instead.

Does `CannotTransformContentToTypeException` want to expose the complete interface (`empty public interface`) of `ContentTransformationException` such that `CannotTransformContentToTypeException` can be used where `ContentTransformationException` is expected? Indicates __inheritance__.

Does `CannotTransformContentToTypeException` want only some/part of the behavior exposed by `ContentTransformationException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  63 </span> */
<span class="lineno">  64 </span>abstract class ContentTransformationException(message: String) : Exception(message)
<span class="lineno">  65 </span>
<span class="lineno">  66 </span><span class="error">internal class CannotTransformContentToTypeException(</span>
<span class="lineno">  67 </span><span class="error">    private val type: KType</span>
<span class="lineno">  68 </span><span class="error">) : ContentTransformationException(&quot;Cannot transform this request's content to $type&quot;),</span>
<span class="lineno">  69 </span><span class="error">    CopyableThrowable&lt;CannotTransformContentToTypeException&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/Errors.kt:80:1</span><span class="message">The class `UnsupportedMediaTypeException` is using inheritance, consider using composition instead.

Does `UnsupportedMediaTypeException` want to expose the complete interface (`empty public interface`) of `ContentTransformationException` such that `UnsupportedMediaTypeException` can be used where `ContentTransformationException` is expected? Indicates __inheritance__.

Does `UnsupportedMediaTypeException` want only some/part of the behavior exposed by `ContentTransformationException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  77 </span>        }
<span class="lineno">  78 </span>}
<span class="lineno">  79 </span>
<span class="lineno">  80 </span><span class="error">/**</span>
<span class="lineno">  81 </span><span class="error"> * Thrown when there is no conversion for a content type configured.</span>
<span class="lineno">  82 </span><span class="error"> * HTTP status 415 Unsupported Media Type will be replied when this exception is thrown and not caught.</span>
<span class="lineno">  83 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/PartialContent.kt:201:5</span><span class="message">The class `PartialOutgoingContent` is using inheritance, consider using composition instead.

Does `PartialOutgoingContent` want to expose the complete interface (`readFrom, readFrom`) of `ReadChannelContent` such that `PartialOutgoingContent` can be used where `ReadChannelContent` is expected? Indicates __inheritance__.

Does `PartialOutgoingContent` want only some/part of the behavior exposed by `ReadChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 198 </span>        proceedWith(PartialOutgoingContent.Multiple(coroutineContext, call.isGet(), content, ranges, length, boundary))
<span class="lineno"> 199 </span>    }
<span class="lineno"> 200 </span>
<span class="lineno"> 201 </span>    <span class="error">private sealed class PartialOutgoingContent(val original: ReadChannelContent) :</span>
<span class="lineno"> 202 </span><span class="error">        OutgoingContent.ReadChannelContent() {</span>
<span class="lineno"> 203 </span><span class="error">        override val status: HttpStatusCode? get() = original.status</span>
<span class="lineno"> 204 </span><span class="error">        override val contentType: ContentType? get() = original.contentType</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/PartialContent.kt:208:9</span><span class="message">The class `Bypass` is using inheritance, consider using composition instead.

Does `Bypass` want to expose the complete interface (`setProperty, getProperty`) of `PartialOutgoingContent` such that `Bypass` can be used where `PartialOutgoingContent` is expected? Indicates __inheritance__.

Does `Bypass` want only some/part of the behavior exposed by `PartialOutgoingContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 205 </span>        override fun &lt;T : Any&gt; getProperty(key: AttributeKey&lt;T&gt;) = original.getProperty(key)
<span class="lineno"> 206 </span>        override fun &lt;T : Any&gt; setProperty(key: AttributeKey&lt;T&gt;, value: T?) = original.setProperty(key, value)
<span class="lineno"> 207 </span>
<span class="lineno"> 208 </span>        <span class="error">class Bypass(original: ReadChannelContent) : PartialOutgoingContent(original) {</span>
<span class="lineno"> 209 </span><span class="error"></span>
<span class="lineno"> 210 </span><span class="error">            override val contentLength: Long?</span>
<span class="lineno"> 211 </span><span class="error">                get() = original.contentLength</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/PartialContent.kt:223:9</span><span class="message">The class `Single` is using inheritance, consider using composition instead.

Does `Single` want to expose the complete interface (`setProperty, getProperty`) of `PartialOutgoingContent` such that `Single` can be used where `PartialOutgoingContent` is expected? Indicates __inheritance__.

Does `Single` want only some/part of the behavior exposed by `PartialOutgoingContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 220 </span>            }
<span class="lineno"> 221 </span>        }
<span class="lineno"> 222 </span>
<span class="lineno"> 223 </span>        <span class="error">class Single(</span>
<span class="lineno"> 224 </span><span class="error">            val get: Boolean,</span>
<span class="lineno"> 225 </span><span class="error">            original: ReadChannelContent,</span>
<span class="lineno"> 226 </span><span class="error">            val range: LongRange,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/features/PartialContent.kt:244:9</span><span class="message">The class `Multiple` is using inheritance, consider using composition instead.

Does `Multiple` want to expose the complete interface (`setProperty, getProperty`) of `PartialOutgoingContent` such that `Multiple` can be used where `PartialOutgoingContent` is expected? Indicates __inheritance__.

Does `Multiple` want only some/part of the behavior exposed by `PartialOutgoingContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 241 </span>            }
<span class="lineno"> 242 </span>        }
<span class="lineno"> 243 </span>
<span class="lineno"> 244 </span>        <span class="error">class Multiple(</span>
<span class="lineno"> 245 </span><span class="error">            override val coroutineContext: CoroutineContext,</span>
<span class="lineno"> 246 </span><span class="error">            val get: Boolean,</span>
<span class="lineno"> 247 </span><span class="error">            original: ReadChannelContent,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/http/content/HttpStatusCodeContent.kt:9:1</span><span class="message">The class `HttpStatusCodeContent` is using inheritance, consider using composition instead.

Does `HttpStatusCodeContent` want to expose the complete interface (`empty public interface`) of `NoContent` such that `HttpStatusCodeContent` can be used where `NoContent` is expected? Indicates __inheritance__.

Does `HttpStatusCodeContent` want only some/part of the behavior exposed by `NoContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>
<span class="lineno">   7 </span>import io.ktor.http.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">/**</span>
<span class="lineno">  10 </span><span class="error"> * Represents a simple status code response with no content</span>
<span class="lineno">  11 </span><span class="error"> * @param value - status code to be sent</span>
<span class="lineno">  12 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/http/content/JarFileContent.kt:14:1</span><span class="message">The class `JarFileContent` is using inheritance, consider using composition instead.

Does `JarFileContent` want to expose the complete interface (`readFrom, readFrom`) of `ReadChannelContent` such that `JarFileContent` can be used where `ReadChannelContent` is expected? Indicates __inheritance__.

Does `JarFileContent` want only some/part of the behavior exposed by `ReadChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import java.nio.file.*
<span class="lineno">  12 </span>import java.util.jar.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">/**</span>
<span class="lineno">  15 </span><span class="error"> * Represents an [OutgoingContent] for a resource inside a Jar file</span>
<span class="lineno">  16 </span><span class="error"> *</span>
<span class="lineno">  17 </span><span class="error"> * @param jarFile is an instance of [File] representing a Jar</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/http/content/LocalFileContent.kt:14:1</span><span class="message">The class `LocalFileContent` is using inheritance, consider using composition instead.

Does `LocalFileContent` want to expose the complete interface (`readFrom, readFrom`) of `ReadChannelContent` such that `LocalFileContent` can be used where `ReadChannelContent` is expected? Indicates __inheritance__.

Does `LocalFileContent` want only some/part of the behavior exposed by `ReadChannelContent`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import java.io.*
<span class="lineno">  12 </span>import java.nio.file.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">/**</span>
<span class="lineno">  15 </span><span class="error"> * OutgoingContent representing a local [file] with a specified [contentType], [expires] date and [caching]</span>
<span class="lineno">  16 </span><span class="error"> *</span>
<span class="lineno">  17 </span><span class="error"> * @param file specifies the File to be served to a client</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/request/ApplicationReceiveFunctions.kt:40:1</span><span class="message">The class `ApplicationReceivePipeline` is using inheritance, consider using composition instead.

Does `ApplicationReceivePipeline` want to expose the complete interface (`merge, afterIntercepted, intercept, insertPhaseBefore, insertPhaseAfter, addPhase, execute`) of `Pipeline` such that `ApplicationReceivePipeline` can be used where `Pipeline` is expected? Indicates __inheritance__.

Does `ApplicationReceivePipeline` want only some/part of the behavior exposed by `Pipeline`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  37 </span>        get() = typeInfo.jvmErasure
<span class="lineno">  38 </span>}
<span class="lineno">  39 </span>
<span class="lineno">  40 </span><span class="error">/**</span>
<span class="lineno">  41 </span><span class="error"> * Pipeline for processing incoming content</span>
<span class="lineno">  42 </span><span class="error"> *</span>
<span class="lineno">  43 </span><span class="error"> * When executed, this pipeline starts with an instance of [ByteReadChannel] and should finish with the requested type.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/response/ApplicationSendPipeline.kt:11:1</span><span class="message">The class `ApplicationSendPipeline` is using inheritance, consider using composition instead.

Does `ApplicationSendPipeline` want to expose the complete interface (`merge, afterIntercepted, intercept, insertPhaseBefore, insertPhaseAfter, addPhase, execute`) of `Pipeline` such that `ApplicationSendPipeline` can be used where `Pipeline` is expected? Indicates __inheritance__.

Does `ApplicationSendPipeline` want only some/part of the behavior exposed by `Pipeline`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.util.*
<span class="lineno">   9 </span>import io.ktor.util.pipeline.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * Server response send pipeline</span>
<span class="lineno">  13 </span><span class="error"> */</span>
<span class="lineno">  14 </span><span class="error">open class ApplicationSendPipeline : Pipeline&lt;Any, ApplicationCall&gt;(Before, Transform, Render, ContentEncoding, TransferEncoding, After, Engine) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/HostsRoutingBuilder.kt:90:1</span><span class="message">The class `HostRouteSelector` is using inheritance, consider using composition instead.

Does `HostRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `HostRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `HostRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  87 </span>    return createChild(selector).apply(build)
<span class="lineno">  88 </span>}
<span class="lineno">  89 </span>
<span class="lineno">  90 </span><span class="error">/**</span>
<span class="lineno">  91 </span><span class="error"> * Evaluates a route against a request's host and port</span>
<span class="lineno">  92 </span><span class="error"> * @param hostList contains exact host names</span>
<span class="lineno">  93 </span><span class="error"> * @param hostPatterns contains host patterns to match</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/LocalPortRoutingBuilder.kt:32:1</span><span class="message">The class `LocalPortRouteSelector` is using inheritance, consider using composition instead.

Does `LocalPortRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `LocalPortRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `LocalPortRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  29 </span>    return createChild(selector).apply(build)
<span class="lineno">  30 </span>}
<span class="lineno">  31 </span>
<span class="lineno">  32 </span><span class="error">/**</span>
<span class="lineno">  33 </span><span class="error"> * Evaluate a route against the port on which the call was received.</span>
<span class="lineno">  34 </span><span class="error"> *</span>
<span class="lineno">  35 </span><span class="error"> * @param port the port to match against</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/Route.kt:10:1</span><span class="message">The class `Route` is using inheritance, consider using composition instead.

Does `Route` want to expose the complete interface (`empty public interface`) of `ApplicationCallPipeline` such that `Route` can be used where `ApplicationCallPipeline` is expected? Indicates __inheritance__.

Does `Route` want only some/part of the behavior exposed by `ApplicationCallPipeline`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import io.ktor.application.*
<span class="lineno">   8 </span>import io.ktor.util.pipeline.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">/**</span>
<span class="lineno">  11 </span><span class="error"> * Describes a node in a routing tree</span>
<span class="lineno">  12 </span><span class="error"> *</span>
<span class="lineno">  13 </span><span class="error"> * @param parent is a parent node in the tree, or null for root node</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RouteSelector.kt:90:1</span><span class="message">The class `RootRouteSelector` is using inheritance, consider using composition instead.

Does `RootRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `RootRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `RootRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  87 </span>    abstract fun evaluate(context: RoutingResolveContext, segmentIndex: Int): RouteSelectorEvaluation
<span class="lineno">  88 </span>}
<span class="lineno">  89 </span>
<span class="lineno">  90 </span><span class="error">/**</span>
<span class="lineno">  91 </span><span class="error"> * The selector for routing root.</span>
<span class="lineno">  92 </span><span class="error"> */</span>
<span class="lineno">  93 </span><span class="error">@InternalAPI</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RouteSelector.kt:130:1</span><span class="message">The class `ConstantParameterRouteSelector` is using inheritance, consider using composition instead.

Does `ConstantParameterRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `ConstantParameterRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `ConstantParameterRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 127 </span>    override fun toString(): String = parts.joinToString(&quot;/&quot;)
<span class="lineno"> 128 </span>}
<span class="lineno"> 129 </span>
<span class="lineno"> 130 </span><span class="error">/**</span>
<span class="lineno"> 131 </span><span class="error"> * Evaluates a route against a constant query parameter value</span>
<span class="lineno"> 132 </span><span class="error"> * @param name is a name of the query parameter</span>
<span class="lineno"> 133 </span><span class="error"> * @param value is a value of the query parameter</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RouteSelector.kt:145:1</span><span class="message">The class `ParameterRouteSelector` is using inheritance, consider using composition instead.

Does `ParameterRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `ParameterRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `ParameterRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 142 </span>    override fun toString(): String = &quot;[$name = $value]&quot;
<span class="lineno"> 143 </span>}
<span class="lineno"> 144 </span>
<span class="lineno"> 145 </span><span class="error">/**</span>
<span class="lineno"> 146 </span><span class="error"> * Evaluates a route against a query parameter value and captures its value</span>
<span class="lineno"> 147 </span><span class="error"> * @param name is a name of the query parameter</span>
<span class="lineno"> 148 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RouteSelector.kt:160:1</span><span class="message">The class `OptionalParameterRouteSelector` is using inheritance, consider using composition instead.

Does `OptionalParameterRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `OptionalParameterRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `OptionalParameterRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 157 </span>    override fun toString(): String = &quot;[$name]&quot;
<span class="lineno"> 158 </span>}
<span class="lineno"> 159 </span>
<span class="lineno"> 160 </span><span class="error">/**</span>
<span class="lineno"> 161 </span><span class="error"> * Evaluates a route against an optional query parameter value and captures its value, if found</span>
<span class="lineno"> 162 </span><span class="error"> * @param name is a name of the query parameter</span>
<span class="lineno"> 163 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RouteSelector.kt:175:1</span><span class="message">The class `PathSegmentConstantRouteSelector` is using inheritance, consider using composition instead.

Does `PathSegmentConstantRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `PathSegmentConstantRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `PathSegmentConstantRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 172 </span>    override fun toString(): String = &quot;[$name?]&quot;
<span class="lineno"> 173 </span>}
<span class="lineno"> 174 </span>
<span class="lineno"> 175 </span><span class="error">/**</span>
<span class="lineno"> 176 </span><span class="error"> * Evaluates a route against a constant path segment</span>
<span class="lineno"> 177 </span><span class="error"> * @param value is a value of the path segment</span>
<span class="lineno"> 178 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RouteSelector.kt:189:1</span><span class="message">The class `PathSegmentParameterRouteSelector` is using inheritance, consider using composition instead.

Does `PathSegmentParameterRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `PathSegmentParameterRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `PathSegmentParameterRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 186 </span>    override fun toString(): String = value
<span class="lineno"> 187 </span>}
<span class="lineno"> 188 </span>
<span class="lineno"> 189 </span><span class="error">/**</span>
<span class="lineno"> 190 </span><span class="error"> * Evaluates a route against a parameter path segment and captures its value</span>
<span class="lineno"> 191 </span><span class="error"> * @param name is the name of the parameter to capture values to</span>
<span class="lineno"> 192 </span><span class="error"> * @param prefix is an optional suffix</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RouteSelector.kt:224:1</span><span class="message">The class `PathSegmentOptionalParameterRouteSelector` is using inheritance, consider using composition instead.

Does `PathSegmentOptionalParameterRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `PathSegmentOptionalParameterRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `PathSegmentOptionalParameterRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 221 </span>    override fun toString(): String = &quot;${prefix ?: &quot;&quot;}{$name}${suffix ?: &quot;&quot;}&quot;
<span class="lineno"> 222 </span>}
<span class="lineno"> 223 </span>
<span class="lineno"> 224 </span><span class="error">/**</span>
<span class="lineno"> 225 </span><span class="error"> * Evaluates a route against an optional parameter path segment and captures its value, if any</span>
<span class="lineno"> 226 </span><span class="error"> * @param name is the name of the parameter to capture values to</span>
<span class="lineno"> 227 </span><span class="error"> * @param prefix is an optional suffix</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RouteSelector.kt:272:1</span><span class="message">The class `PathSegmentTailcardRouteSelector` is using inheritance, consider using composition instead.

Does `PathSegmentTailcardRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `PathSegmentTailcardRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `PathSegmentTailcardRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 269 </span>    override fun toString(): String = &quot;*&quot;
<span class="lineno"> 270 </span>}
<span class="lineno"> 271 </span>
<span class="lineno"> 272 </span><span class="error">/**</span>
<span class="lineno"> 273 </span><span class="error"> * Evaluates a route against any number of trailing path segments, and captures their values</span>
<span class="lineno"> 274 </span><span class="error"> * @param name is the name of the parameter to capture values to</span>
<span class="lineno"> 275 </span><span class="error"> * @property prefix before the tailcard (static text)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RouteSelector.kt:309:1</span><span class="message">The class `OrRouteSelector` is using inheritance, consider using composition instead.

Does `OrRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `OrRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `OrRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 306 </span>    override fun toString(): String = &quot;{...}&quot;
<span class="lineno"> 307 </span>}
<span class="lineno"> 308 </span>
<span class="lineno"> 309 </span><span class="error">/**</span>
<span class="lineno"> 310 </span><span class="error"> * Evaluates a route as a result of the OR operation using two other selectors</span>
<span class="lineno"> 311 </span><span class="error"> * @param first is a first selector</span>
<span class="lineno"> 312 </span><span class="error"> * @param second is a second selector</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RouteSelector.kt:326:1</span><span class="message">The class `AndRouteSelector` is using inheritance, consider using composition instead.

Does `AndRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `AndRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `AndRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 323 </span>    override fun toString(): String = &quot;{$first | $second}&quot;
<span class="lineno"> 324 </span>}
<span class="lineno"> 325 </span>
<span class="lineno"> 326 </span><span class="error">/**</span>
<span class="lineno"> 327 </span><span class="error"> * Evaluates a route as a result of the AND operation using two other selectors</span>
<span class="lineno"> 328 </span><span class="error"> * @param first is a first selector</span>
<span class="lineno"> 329 </span><span class="error"> * @param second is a second selector</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RouteSelector.kt:346:1</span><span class="message">The class `HttpMethodRouteSelector` is using inheritance, consider using composition instead.

Does `HttpMethodRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `HttpMethodRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `HttpMethodRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 343 </span>    override fun toString(): String = &quot;{$first &amp; $second}&quot;
<span class="lineno"> 344 </span>}
<span class="lineno"> 345 </span>
<span class="lineno"> 346 </span><span class="error">/**</span>
<span class="lineno"> 347 </span><span class="error"> * Evaluates a route against an [HttpMethod]</span>
<span class="lineno"> 348 </span><span class="error"> * @param method is an instance of [HttpMethod]</span>
<span class="lineno"> 349 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RouteSelector.kt:360:1</span><span class="message">The class `HttpHeaderRouteSelector` is using inheritance, consider using composition instead.

Does `HttpHeaderRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `HttpHeaderRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `HttpHeaderRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 357 </span>    override fun toString(): String = &quot;(method:${method.value})&quot;
<span class="lineno"> 358 </span>}
<span class="lineno"> 359 </span>
<span class="lineno"> 360 </span><span class="error">/**</span>
<span class="lineno"> 361 </span><span class="error"> * Evaluates a route against a header in the request</span>
<span class="lineno"> 362 </span><span class="error"> * @param name is a name of the header</span>
<span class="lineno"> 363 </span><span class="error"> * @param value is a value of the header</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RouteSelector.kt:378:1</span><span class="message">The class `HttpAcceptRouteSelector` is using inheritance, consider using composition instead.

Does `HttpAcceptRouteSelector` want to expose the complete interface (`evaluate`) of `RouteSelector` such that `HttpAcceptRouteSelector` can be used where `RouteSelector` is expected? Indicates __inheritance__.

Does `HttpAcceptRouteSelector` want only some/part of the behavior exposed by `RouteSelector`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 375 </span>    override fun toString(): String = &quot;(header:$name = $value)&quot;
<span class="lineno"> 376 </span>}
<span class="lineno"> 377 </span>
<span class="lineno"> 378 </span><span class="error">/**</span>
<span class="lineno"> 379 </span><span class="error"> * Evaluates a route against a content-type in the [HttpHeaders.Accept] header in the request</span>
<span class="lineno"> 380 </span><span class="error"> * @param contentType is an instance of [ContentType]</span>
<span class="lineno"> 381 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/Routing.kt:14:1</span><span class="message">The class `Routing` is using inheritance, consider using composition instead.

Does `Routing` want to expose the complete interface (`toString, afterIntercepted, handle, invoke, createChild`) of `Route` such that `Routing` can be used where `Route` is expected? Indicates __inheritance__.

Does `Routing` want only some/part of the behavior exposed by `Route`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import io.ktor.response.*
<span class="lineno">  12 </span>import io.ktor.util.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">/**</span>
<span class="lineno">  15 </span><span class="error"> * Root routing node for an [Application]</span>
<span class="lineno">  16 </span><span class="error"> * @param application is an instance of [Application] for this routing</span>
<span class="lineno">  17 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RoutingResolve.kt:22:5</span><span class="message">The class `Success` is using inheritance, consider using composition instead.

Does `Success` want to expose the complete interface (`empty public interface`) of `RoutingResolveResult` such that `Success` can be used where `RoutingResolveResult` is expected? Indicates __inheritance__.

Does `Success` want only some/part of the behavior exposed by `RoutingResolveResult`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  19 </span>     */
<span class="lineno">  20 </span>    abstract val parameters: Parameters
<span class="lineno">  21 </span>
<span class="lineno">  22 </span>    <span class="error">/**</span>
<span class="lineno">  23 </span><span class="error">     * Represents a successful result</span>
<span class="lineno">  24 </span><span class="error">     */</span>
<span class="lineno">  25 </span><span class="error">    class Success(route: Route, override val parameters: Parameters) : RoutingResolveResult(route) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/routing/RoutingResolve.kt:29:5</span><span class="message">The class `Failure` is using inheritance, consider using composition instead.

Does `Failure` want to expose the complete interface (`empty public interface`) of `RoutingResolveResult` such that `Failure` can be used where `RoutingResolveResult` is expected? Indicates __inheritance__.

Does `Failure` want only some/part of the behavior exposed by `RoutingResolveResult`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  26 </span>        override fun toString(): String = &quot;SUCCESS${if (parameters.isEmpty()) &quot;&quot; else &quot;; $parameters&quot;} @ $route)&quot;
<span class="lineno">  27 </span>    }
<span class="lineno">  28 </span>
<span class="lineno">  29 </span>    <span class="error">/**</span>
<span class="lineno">  30 </span><span class="error">     * Represents a failed result</span>
<span class="lineno">  31 </span><span class="error">     * @param reason provides information on reason of a failure</span>
<span class="lineno">  32 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/sessions/SessionsBuilder.kt:256:1</span><span class="message">The class `CookieIdSessionBuilder` is using inheritance, consider using composition instead.

Does `CookieIdSessionBuilder` want to expose the complete interface (`transform`) of `CookieSessionBuilder` such that `CookieIdSessionBuilder` can be used where `CookieSessionBuilder` is expected? Indicates __inheritance__.

Does `CookieIdSessionBuilder` want only some/part of the behavior exposed by `CookieSessionBuilder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 253 </span>    register(provider)
<span class="lineno"> 254 </span>}
<span class="lineno"> 255 </span>
<span class="lineno"> 256 </span><span class="error">/**</span>
<span class="lineno"> 257 </span><span class="error"> * Cookie session configuration builder</span>
<span class="lineno"> 258 </span><span class="error"> */</span>
<span class="lineno"> 259 </span><span class="error">@Suppress(&quot;DEPRECATION&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-core/jvm/src/io/ktor/sessions/SessionsBuilder.kt:330:1</span><span class="message">The class `HeaderIdSessionBuilder` is using inheritance, consider using composition instead.

Does `HeaderIdSessionBuilder` want to expose the complete interface (`transform`) of `HeaderSessionBuilder` such that `HeaderIdSessionBuilder` can be used where `HeaderSessionBuilder` is expected? Indicates __inheritance__.

Does `HeaderIdSessionBuilder` want only some/part of the behavior exposed by `HeaderSessionBuilder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 327 </span>    }
<span class="lineno"> 328 </span>}
<span class="lineno"> 329 </span>
<span class="lineno"> 330 </span><span class="error">/**</span>
<span class="lineno"> 331 </span><span class="error"> * Header session configuration builder</span>
<span class="lineno"> 332 </span><span class="error"> */</span>
<span class="lineno"> 333 </span><span class="error">@Suppress(&quot;DEPRECATION&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-host-common/jvm/src/io/ktor/server/engine/BaseApplicationEngine.kt:24:5</span><span class="message">The class `Configuration` is using inheritance, consider using composition instead.

Does `Configuration` want to expose the complete interface (`empty public interface`) of `Configuration` such that `Configuration` can be used where `Configuration` is expected? Indicates __inheritance__.

Does `Configuration` want only some/part of the behavior exposed by `Configuration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  21 </span>    val pipeline: EnginePipeline = defaultEnginePipeline(environment)
<span class="lineno">  22 </span>) : ApplicationEngine {
<span class="lineno">  23 </span>
<span class="lineno">  24 </span>    <span class="error">/**</span>
<span class="lineno">  25 </span><span class="error">     * Configuration for the [BaseApplicationEngine]</span>
<span class="lineno">  26 </span><span class="error">     */</span>
<span class="lineno">  27 </span><span class="error">    open class Configuration : ApplicationEngine.Configuration()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-host-common/jvm/src/io/ktor/server/engine/EngineConnectorConfig.kt:113:1</span><span class="message">The class `EngineSSLConnectorBuilder` is using inheritance, consider using composition instead.

Does `EngineSSLConnectorBuilder` want to expose the complete interface (`toString`) of `EngineConnectorBuilder` such that `EngineSSLConnectorBuilder` can be used where `EngineConnectorBuilder` is expected? Indicates __inheritance__.

Does `EngineSSLConnectorBuilder` want only some/part of the behavior exposed by `EngineConnectorBuilder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 110 </span>    }
<span class="lineno"> 111 </span>}
<span class="lineno"> 112 </span>
<span class="lineno"> 113 </span><span class="error">/**</span>
<span class="lineno"> 114 </span><span class="error"> * Mutable implementation of EngineSSLConnectorConfig for building connectors programmatically</span>
<span class="lineno"> 115 </span><span class="error"> */</span>
<span class="lineno"> 116 </span><span class="error">class EngineSSLConnectorBuilder(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-host-common/jvm/src/io/ktor/server/engine/EnginePipeline.kt:12:1</span><span class="message">The class `EnginePipeline` is using inheritance, consider using composition instead.

Does `EnginePipeline` want to expose the complete interface (`merge, afterIntercepted, intercept, insertPhaseBefore, insertPhaseAfter, addPhase, execute`) of `Pipeline` such that `EnginePipeline` can be used where `Pipeline` is expected? Indicates __inheritance__.

Does `EnginePipeline` want only some/part of the behavior exposed by `Pipeline`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import io.ktor.response.*
<span class="lineno">  10 </span>import io.ktor.util.pipeline.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">/**</span>
<span class="lineno">  13 </span><span class="error"> * Application engine pipeline. One usually don't need to install interceptors here unless your are writing</span>
<span class="lineno">  14 </span><span class="error"> * your own engine implementation</span>
<span class="lineno">  15 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-jetty/jvm/src/io/ktor/server/jetty/JettyApplicationCall.kt:15:1</span><span class="message">The class `JettyApplicationCall` is using inheritance, consider using composition instead.

Does `JettyApplicationCall` want to expose the complete interface (`empty public interface`) of `AsyncServletApplicationCall` such that `JettyApplicationCall` can be used where `AsyncServletApplicationCall` is expected? Indicates __inheritance__.

Does `JettyApplicationCall` want only some/part of the behavior exposed by `AsyncServletApplicationCall`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>import javax.servlet.http.*
<span class="lineno">  13 </span>import kotlin.coroutines.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  16 </span><span class="error">@InternalAPI</span>
<span class="lineno">  17 </span><span class="error">class JettyApplicationCall(</span>
<span class="lineno">  18 </span><span class="error">    application: Application,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-jetty/jvm/src/io/ktor/server/jetty/JettyApplicationEngine.kt:11:1</span><span class="message">The class `JettyApplicationEngine` is using inheritance, consider using composition instead.

Does `JettyApplicationEngine` want to expose the complete interface (`toString, stop, start`) of `JettyApplicationEngineBase` such that `JettyApplicationEngine` can be used where `JettyApplicationEngineBase` is expected? Indicates __inheritance__.

Does `JettyApplicationEngine` want only some/part of the behavior exposed by `JettyApplicationEngineBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.util.*
<span class="lineno">   9 </span>import kotlinx.coroutines.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">/**</span>
<span class="lineno">  12 </span><span class="error"> * [ApplicationEngine] implementation for running in a standalone Jetty</span>
<span class="lineno">  13 </span><span class="error"> */</span>
<span class="lineno">  14 </span><span class="error">class JettyApplicationEngine(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-jetty/jvm/src/io/ktor/server/jetty/JettyApplicationEngineBase.kt:13:1</span><span class="message">The class `JettyApplicationEngineBase` is using inheritance, consider using composition instead.

Does `JettyApplicationEngineBase` want to expose the complete interface (`empty public interface`) of `BaseApplicationEngine` such that `JettyApplicationEngineBase` can be used where `BaseApplicationEngine` is expected? Indicates __inheritance__.

Does `JettyApplicationEngineBase` want only some/part of the behavior exposed by `BaseApplicationEngine`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import org.eclipse.jetty.server.*
<span class="lineno">  11 </span>import java.util.concurrent.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">/**</span>
<span class="lineno">  14 </span><span class="error"> * [ApplicationEngine] base type for running in a standalone Jetty</span>
<span class="lineno">  15 </span><span class="error"> */</span>
<span class="lineno">  16 </span><span class="error">open class JettyApplicationEngineBase @EngineAPI constructor(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-jetty/jvm/src/io/ktor/server/jetty/JettyApplicationEngineBase.kt:21:5</span><span class="message">The class `Configuration` is using inheritance, consider using composition instead.

Does `Configuration` want to expose the complete interface (`empty public interface`) of `Configuration` such that `Configuration` can be used where `Configuration` is expected? Indicates __inheritance__.

Does `Configuration` want only some/part of the behavior exposed by `Configuration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  18 </span>    configure: Configuration.() -&gt; Unit
<span class="lineno">  19 </span>) : BaseApplicationEngine(environment) {
<span class="lineno">  20 </span>
<span class="lineno">  21 </span>    <span class="error">/**</span>
<span class="lineno">  22 </span><span class="error">     * Jetty-specific engine configuration</span>
<span class="lineno">  23 </span><span class="error">     */</span>
<span class="lineno">  24 </span><span class="error">    class Configuration : BaseApplicationEngine.Configuration() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-jetty/jvm/src/io/ktor/server/jetty/JettyApplicationResponse.kt:15:1</span><span class="message">The class `JettyApplicationResponse` is using inheritance, consider using composition instead.

Does `JettyApplicationResponse` want to expose the complete interface (`push, respondUpgrade, createResponseJob`) of `AsyncServletApplicationResponse` such that `JettyApplicationResponse` can be used where `AsyncServletApplicationResponse` is expected? Indicates __inheritance__.

Does `JettyApplicationResponse` want only some/part of the behavior exposed by `AsyncServletApplicationResponse`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>import javax.servlet.http.*
<span class="lineno">  13 </span>import kotlin.coroutines.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  16 </span><span class="error">@InternalAPI</span>
<span class="lineno">  17 </span><span class="error">class JettyApplicationResponse(</span>
<span class="lineno">  18 </span><span class="error">    call: AsyncServletApplicationCall,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationCall.kt:13:1</span><span class="message">The class `NettyApplicationCall` is using inheritance, consider using composition instead.

Does `NettyApplicationCall` want to expose the complete interface (`empty public interface`) of `BaseApplicationCall` such that `NettyApplicationCall` can be used where `BaseApplicationCall` is expected? Indicates __inheritance__.

Does `NettyApplicationCall` want only some/part of the behavior exposed by `BaseApplicationCall`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import io.netty.util.*
<span class="lineno">  11 </span>import kotlinx.coroutines.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  14 </span><span class="error">@EngineAPI</span>
<span class="lineno">  15 </span><span class="error">abstract class NettyApplicationCall(application: Application,</span>
<span class="lineno">  16 </span><span class="error">                                    val context: ChannelHandlerContext,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationEngine.kt:23:1</span><span class="message">The class `NettyApplicationEngine` is using inheritance, consider using composition instead.

Does `NettyApplicationEngine` want to expose the complete interface (`empty public interface`) of `BaseApplicationEngine` such that `NettyApplicationEngine` can be used where `BaseApplicationEngine` is expected? Indicates __inheritance__.

Does `NettyApplicationEngine` want only some/part of the behavior exposed by `BaseApplicationEngine`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  20 </span>import java.util.concurrent.*
<span class="lineno">  21 </span>import kotlin.reflect.KClass
<span class="lineno">  22 </span>
<span class="lineno">  23 </span><span class="error">/**</span>
<span class="lineno">  24 </span><span class="error"> * [ApplicationEngine] implementation for running in a standalone Netty</span>
<span class="lineno">  25 </span><span class="error"> */</span>
<span class="lineno">  26 </span><span class="error">class NettyApplicationEngine(environment: ApplicationEngineEnvironment, configure: Configuration.() -&gt; Unit = {}) :</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationEngine.kt:29:5</span><span class="message">The class `Configuration` is using inheritance, consider using composition instead.

Does `Configuration` want to expose the complete interface (`empty public interface`) of `Configuration` such that `Configuration` can be used where `Configuration` is expected? Indicates __inheritance__.

Does `Configuration` want only some/part of the behavior exposed by `Configuration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  26 </span>class NettyApplicationEngine(environment: ApplicationEngineEnvironment, configure: Configuration.() -&gt; Unit = {}) :
<span class="lineno">  27 </span>    BaseApplicationEngine(environment) {
<span class="lineno">  28 </span>
<span class="lineno">  29 </span>    <span class="error">/**</span>
<span class="lineno">  30 </span><span class="error">     * Configuration for the [NettyApplicationEngine]</span>
<span class="lineno">  31 </span><span class="error">     */</span>
<span class="lineno">  32 </span><span class="error">    class Configuration : BaseApplicationEngine.Configuration() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationRequest.kt:20:1</span><span class="message">The class `NettyApplicationRequest` is using inheritance, consider using composition instead.

Does `NettyApplicationRequest` want to expose the complete interface (`empty public interface`) of `BaseApplicationRequest` such that `NettyApplicationRequest` can be used where `BaseApplicationRequest` is expected? Indicates __inheritance__.

Does `NettyApplicationRequest` want only some/part of the behavior exposed by `BaseApplicationRequest`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  17 </span>import java.io.*
<span class="lineno">  18 </span>import kotlin.coroutines.*
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  21 </span><span class="error">@InternalAPI</span>
<span class="lineno">  22 </span><span class="error">abstract class NettyApplicationRequest(</span>
<span class="lineno">  23 </span><span class="error">    call: ApplicationCall,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationRequestCookies.kt:11:1</span><span class="message">The class `NettyApplicationRequestCookies` is using inheritance, consider using composition instead.

Does `NettyApplicationRequestCookies` want to expose the complete interface (`get`) of `RequestCookies` such that `NettyApplicationRequestCookies` can be used where `RequestCookies` is expected? Indicates __inheritance__.

Does `NettyApplicationRequestCookies` want only some/part of the behavior exposed by `RequestCookies`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import io.netty.handler.codec.http.cookie.*
<span class="lineno">   9 </span>import java.util.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class NettyApplicationRequestCookies(request: ApplicationRequest) : RequestCookies(request) {</span>
<span class="lineno">  12 </span><span class="error">    override fun fetchCookies(): Map&lt;String, String&gt; {</span>
<span class="lineno">  13 </span><span class="error">        val cookieHeaders = request.headers.getAll(&quot;Cookie&quot;) ?: return emptyMap()</span>
<span class="lineno">  14 </span><span class="error">        val map = HashMap&lt;String, String&gt;(cookieHeaders.size)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationResponse.kt:18:1</span><span class="message">The class `NettyApplicationResponse` is using inheritance, consider using composition instead.

Does `NettyApplicationResponse` want to expose the complete interface (`push, status, status`) of `BaseApplicationResponse` such that `NettyApplicationResponse` can be used where `BaseApplicationResponse` is expected? Indicates __inheritance__.

Does `NettyApplicationResponse` want only some/part of the behavior exposed by `BaseApplicationResponse`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>import io.ktor.utils.io.*
<span class="lineno">  16 </span>import kotlin.coroutines.*
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  19 </span><span class="error">@InternalAPI</span>
<span class="lineno">  20 </span><span class="error">abstract class NettyApplicationResponse(call: NettyApplicationCall,</span>
<span class="lineno">  21 </span><span class="error">                                                 protected val context: ChannelHandlerContext,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/cio/NettyRequestQueue.kt:47:5</span><span class="message">The class `CallElement` is using inheritance, consider using composition instead.

Does `CallElement` want to expose the complete interface (`toString, removeFirstIfIsInstanceOfOrPeekIf, removeFirstIfIsInstanceOf, describeRemoveFirst, removeFirstOrNull, describeRemove, helpRemove, remove, addLastIfPrevAndIf, addLastIfPrev, addLastIf, describeAddLast, addLast, addOneIfEmpty`) of `LockFreeLinkedListNode` such that `CallElement` can be used where `LockFreeLinkedListNode` is expected? Indicates __inheritance__.

Does `CallElement` want only some/part of the behavior exposed by `LockFreeLinkedListNode`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  44 </span>    @OptIn(ExperimentalCoroutinesApi::class)
<span class="lineno">  45 </span>    fun canRequestMoreEvents(): Boolean = incomingQueue.isEmpty
<span class="lineno">  46 </span>
<span class="lineno">  47 </span>    <span class="error">internal class CallElement(val call: NettyApplicationCall) : LockFreeLinkedListNode() {</span>
<span class="lineno">  48 </span><span class="error">        private val scheduled = atomic(0)</span>
<span class="lineno">  49 </span><span class="error"></span>
<span class="lineno">  50 </span><span class="error">        private val message: Job = call.response.responseMessage</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/http1/NettyHttp1ApplicationCall.kt:14:1</span><span class="message">The class `NettyHttp1ApplicationCall` is using inheritance, consider using composition instead.

Does `NettyHttp1ApplicationCall` want to expose the complete interface (`empty public interface`) of `NettyApplicationCall` such that `NettyHttp1ApplicationCall` can be used where `NettyApplicationCall` is expected? Indicates __inheritance__.

Does `NettyHttp1ApplicationCall` want only some/part of the behavior exposed by `NettyApplicationCall`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import io.ktor.utils.io.*
<span class="lineno">  12 </span>import kotlin.coroutines.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">internal class NettyHttp1ApplicationCall(</span>
<span class="lineno">  15 </span><span class="error">    application: Application,</span>
<span class="lineno">  16 </span><span class="error">    context: ChannelHandlerContext,</span>
<span class="lineno">  17 </span><span class="error">    httpRequest: HttpRequest,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/http1/NettyHttp1ApplicationRequest.kt:16:1</span><span class="message">The class `NettyHttp1ApplicationRequest` is using inheritance, consider using composition instead.

Does `NettyHttp1ApplicationRequest` want to expose the complete interface (`close, receiveChannel`) of `NettyApplicationRequest` such that `NettyHttp1ApplicationRequest` can be used where `NettyApplicationRequest` is expected? Indicates __inheritance__.

Does `NettyHttp1ApplicationRequest` want only some/part of the behavior exposed by `NettyApplicationRequest`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import io.ktor.utils.io.*
<span class="lineno">  14 </span>import kotlin.coroutines.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">internal class NettyHttp1ApplicationRequest(</span>
<span class="lineno">  17 </span><span class="error">    call: ApplicationCall,</span>
<span class="lineno">  18 </span><span class="error">    coroutineContext: CoroutineContext,</span>
<span class="lineno">  19 </span><span class="error">    context: ChannelHandlerContext,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/http1/NettyHttp1ApplicationResponse.kt:19:1</span><span class="message">The class `NettyHttp1ApplicationResponse` is using inheritance, consider using composition instead.

Does `NettyHttp1ApplicationResponse` want to expose the complete interface (`cancel, respondNoContent, responseChannel, respondFromBytes, respondOutgoingContent`) of `NettyApplicationResponse` such that `NettyHttp1ApplicationResponse` can be used where `NettyApplicationResponse` is expected? Indicates __inheritance__.

Does `NettyHttp1ApplicationResponse` want only some/part of the behavior exposed by `NettyApplicationResponse`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>import io.ktor.utils.io.*
<span class="lineno">  17 </span>import kotlin.coroutines.*
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">internal class NettyHttp1ApplicationResponse(call: NettyApplicationCall,</span>
<span class="lineno">  20 </span><span class="error">                                             context: ChannelHandlerContext,</span>
<span class="lineno">  21 </span><span class="error">                                             engineContext: CoroutineContext,</span>
<span class="lineno">  22 </span><span class="error">                                             userContext: CoroutineContext,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/http2/NettyHttp2ApplicationCall.kt:13:1</span><span class="message">The class `NettyHttp2ApplicationCall` is using inheritance, consider using composition instead.

Does `NettyHttp2ApplicationCall` want to expose the complete interface (`empty public interface`) of `NettyApplicationCall` such that `NettyHttp2ApplicationCall` can be used where `NettyApplicationCall` is expected? Indicates __inheritance__.

Does `NettyHttp2ApplicationCall` want only some/part of the behavior exposed by `NettyApplicationCall`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import io.netty.handler.codec.http2.*
<span class="lineno">  11 </span>import kotlin.coroutines.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">internal class NettyHttp2ApplicationCall(application: Application,</span>
<span class="lineno">  14 </span><span class="error">                                         context: ChannelHandlerContext,</span>
<span class="lineno">  15 </span><span class="error">                                         val headers: Http2Headers,</span>
<span class="lineno">  16 </span><span class="error">                                         handler: NettyHttp2Handler,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/http2/NettyHttp2ApplicationRequest.kt:22:1</span><span class="message">The class `NettyHttp2ApplicationRequest` is using inheritance, consider using composition instead.

Does `NettyHttp2ApplicationRequest` want to expose the complete interface (`close, receiveChannel`) of `NettyApplicationRequest` such that `NettyHttp2ApplicationRequest` can be used where `NettyApplicationRequest` is expected? Indicates __inheritance__.

Does `NettyHttp2ApplicationRequest` want only some/part of the behavior exposed by `NettyApplicationRequest`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  19 </span>import java.net.*
<span class="lineno">  20 </span>import kotlin.coroutines.*
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">internal class NettyHttp2ApplicationRequest(</span>
<span class="lineno">  23 </span><span class="error">    call: ApplicationCall,</span>
<span class="lineno">  24 </span><span class="error">    coroutineContext: CoroutineContext,</span>
<span class="lineno">  25 </span><span class="error">    context: ChannelHandlerContext,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/http2/NettyHttp2ApplicationResponse.kt:16:1</span><span class="message">The class `NettyHttp2ApplicationResponse` is using inheritance, consider using composition instead.

Does `NettyHttp2ApplicationResponse` want to expose the complete interface (`cancel, respondNoContent, responseChannel, respondFromBytes, respondOutgoingContent`) of `NettyApplicationResponse` such that `NettyHttp2ApplicationResponse` can be used where `NettyApplicationResponse` is expected? Indicates __inheritance__.

Does `NettyHttp2ApplicationResponse` want only some/part of the behavior exposed by `NettyApplicationResponse`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import io.netty.handler.codec.http2.*
<span class="lineno">  14 </span>import kotlin.coroutines.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">internal class NettyHttp2ApplicationResponse(call: NettyApplicationCall,</span>
<span class="lineno">  17 </span><span class="error">                                             val handler: NettyHttp2Handler,</span>
<span class="lineno">  18 </span><span class="error">                                             context: ChannelHandlerContext,</span>
<span class="lineno">  19 </span><span class="error">                                             engineContext: CoroutineContext,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/AsyncServlet.kt:19:1</span><span class="message">The class `AsyncServletApplicationCall` is using inheritance, consider using composition instead.

Does `AsyncServletApplicationCall` want to expose the complete interface (`empty public interface`) of `BaseApplicationCall` such that `AsyncServletApplicationCall` can be used where `BaseApplicationCall` is expected? Indicates __inheritance__.

Does `AsyncServletApplicationCall` want only some/part of the behavior exposed by `BaseApplicationCall`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>import javax.servlet.http.*
<span class="lineno">  17 </span>import kotlin.coroutines.*
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  20 </span><span class="error">@EngineAPI</span>
<span class="lineno">  21 </span><span class="error">open class AsyncServletApplicationCall(</span>
<span class="lineno">  22 </span><span class="error">    application: Application,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/AsyncServlet.kt:47:1</span><span class="message">The class `AsyncServletApplicationRequest` is using inheritance, consider using composition instead.

Does `AsyncServletApplicationRequest` want to expose the complete interface (`empty public interface`) of `ServletApplicationRequest` such that `AsyncServletApplicationRequest` can be used where `ServletApplicationRequest` is expected? Indicates __inheritance__.

Does `AsyncServletApplicationRequest` want only some/part of the behavior exposed by `ServletApplicationRequest`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  44 </span>    }
<span class="lineno">  45 </span>}
<span class="lineno">  46 </span>
<span class="lineno">  47 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  48 </span><span class="error">@EngineAPI</span>
<span class="lineno">  49 </span><span class="error">class AsyncServletApplicationRequest(</span>
<span class="lineno">  50 </span><span class="error">    call: ApplicationCall, servletRequest: HttpServletRequest,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/AsyncServlet.kt:67:1</span><span class="message">The class `AsyncServletApplicationResponse` is using inheritance, consider using composition instead.

Does `AsyncServletApplicationResponse` want to expose the complete interface (`responseChannel, setStatus`) of `ServletApplicationResponse` such that `AsyncServletApplicationResponse` can be used where `ServletApplicationResponse` is expected? Indicates __inheritance__.

Does `AsyncServletApplicationResponse` want only some/part of the behavior exposed by `ServletApplicationResponse`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  64 </span>    }
<span class="lineno">  65 </span>}
<span class="lineno">  66 </span>
<span class="lineno">  67 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  68 </span><span class="error">@EngineAPI</span>
<span class="lineno">  69 </span><span class="error">open class AsyncServletApplicationResponse(</span>
<span class="lineno">  70 </span><span class="error">    call: AsyncServletApplicationCall,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/BlockingServlet.kt:18:1</span><span class="message">The class `BlockingServletApplicationCall` is using inheritance, consider using composition instead.

Does `BlockingServletApplicationCall` want to expose the complete interface (`empty public interface`) of `BaseApplicationCall` such that `BlockingServletApplicationCall` can be used where `BaseApplicationCall` is expected? Indicates __inheritance__.

Does `BlockingServletApplicationCall` want only some/part of the behavior exposed by `BaseApplicationCall`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>import javax.servlet.http.*
<span class="lineno">  16 </span>import kotlin.coroutines.*
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">internal class BlockingServletApplicationCall(</span>
<span class="lineno">  19 </span><span class="error">    application: Application,</span>
<span class="lineno">  20 </span><span class="error">    servletRequest: HttpServletRequest,</span>
<span class="lineno">  21 </span><span class="error">    servletResponse: HttpServletResponse,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/BlockingServlet.kt:33:1</span><span class="message">The class `BlockingServletApplicationRequest` is using inheritance, consider using composition instead.

Does `BlockingServletApplicationRequest` want to expose the complete interface (`empty public interface`) of `ServletApplicationRequest` such that `BlockingServletApplicationRequest` can be used where `ServletApplicationRequest` is expected? Indicates __inheritance__.

Does `BlockingServletApplicationRequest` want only some/part of the behavior exposed by `ServletApplicationRequest`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  30 </span>    }
<span class="lineno">  31 </span>}
<span class="lineno">  32 </span>
<span class="lineno">  33 </span><span class="error">private class BlockingServletApplicationRequest(</span>
<span class="lineno">  34 </span><span class="error">    call: ApplicationCall,</span>
<span class="lineno">  35 </span><span class="error">    servletRequest: HttpServletRequest</span>
<span class="lineno">  36 </span><span class="error">) : ServletApplicationRequest(call, servletRequest) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/BlockingServlet.kt:43:1</span><span class="message">The class `BlockingServletApplicationResponse` is using inheritance, consider using composition instead.

Does `BlockingServletApplicationResponse` want to expose the complete interface (`responseChannel, setStatus`) of `ServletApplicationResponse` such that `BlockingServletApplicationResponse` can be used where `ServletApplicationResponse` is expected? Indicates __inheritance__.

Does `BlockingServletApplicationResponse` want only some/part of the behavior exposed by `ServletApplicationResponse`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  40 </span>    override fun receiveChannel() = inputStreamChannel
<span class="lineno">  41 </span>}
<span class="lineno">  42 </span>
<span class="lineno">  43 </span><span class="error">internal class BlockingServletApplicationResponse(</span>
<span class="lineno">  44 </span><span class="error">    call: ApplicationCall,</span>
<span class="lineno">  45 </span><span class="error">    servletResponse: HttpServletResponse,</span>
<span class="lineno">  46 </span><span class="error">    override val coroutineContext: CoroutineContext</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/ServletApplicationEngine.kt:16:1</span><span class="message">The class `ServletApplicationEngine` is using inheritance, consider using composition instead.

Does `ServletApplicationEngine` want to expose the complete interface (`service, destroy, init`) of `KtorServlet` such that `ServletApplicationEngine` can be used where `KtorServlet` is expected? Indicates __inheritance__.

Does `ServletApplicationEngine` want only some/part of the behavior exposed by `KtorServlet`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import javax.servlet.*
<span class="lineno">  14 </span>import javax.servlet.annotation.*
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">/**</span>
<span class="lineno">  17 </span><span class="error"> * This servlet need to be installed into a servlet container</span>
<span class="lineno">  18 </span><span class="error"> */</span>
<span class="lineno">  19 </span><span class="error">@MultipartConfig</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/ServletApplicationRequest.kt:13:1</span><span class="message">The class `ServletApplicationRequest` is using inheritance, consider using composition instead.

Does `ServletApplicationRequest` want to expose the complete interface (`empty public interface`) of `BaseApplicationRequest` such that `ServletApplicationRequest` can be used where `BaseApplicationRequest` is expected? Indicates __inheritance__.

Does `ServletApplicationRequest` want only some/part of the behavior exposed by `BaseApplicationRequest`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import io.ktor.server.engine.*
<span class="lineno">  11 </span>import javax.servlet.http.*
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  14 </span><span class="error">@EngineAPI</span>
<span class="lineno">  15 </span><span class="error">abstract class ServletApplicationRequest(</span>
<span class="lineno">  16 </span><span class="error">    call: ApplicationCall,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/ServletApplicationRequestCookies.kt:11:1</span><span class="message">The class `ServletApplicationRequestCookies` is using inheritance, consider using composition instead.

Does `ServletApplicationRequestCookies` want to expose the complete interface (`get`) of `RequestCookies` such that `ServletApplicationRequestCookies` can be used where `RequestCookies` is expected? Indicates __inheritance__.

Does `ServletApplicationRequestCookies` want only some/part of the behavior exposed by `RequestCookies`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import io.ktor.server.engine.*
<span class="lineno">   9 </span>import javax.servlet.http.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  12 </span><span class="error">@EngineAPI</span>
<span class="lineno">  13 </span><span class="error">class ServletApplicationRequestCookies(</span>
<span class="lineno">  14 </span><span class="error">    private val servletRequest: HttpServletRequest,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-servlet/jvm/src/io/ktor/server/servlet/ServletApplicationResponse.kt:15:1</span><span class="message">The class `ServletApplicationResponse` is using inheritance, consider using composition instead.

Does `ServletApplicationResponse` want to expose the complete interface (`push, status, status`) of `BaseApplicationResponse` such that `ServletApplicationResponse` can be used where `BaseApplicationResponse` is expected? Indicates __inheritance__.

Does `ServletApplicationResponse` want only some/part of the behavior exposed by `BaseApplicationResponse`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>import io.ktor.utils.io.*
<span class="lineno">  13 </span>import javax.servlet.http.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  16 </span><span class="error">@EngineAPI</span>
<span class="lineno">  17 </span><span class="error">abstract class ServletApplicationResponse(</span>
<span class="lineno">  18 </span><span class="error">    call: ApplicationCall,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/EngineStressSuite.kt:29:1</span><span class="message">The class `EngineStressSuite` is using inheritance, consider using composition instead.

Does `EngineStressSuite` want to expose the complete interface (`tearDownBase, setUpBase`) of `EngineTestBase` such that `EngineStressSuite` can be used where `EngineTestBase` is expected? Indicates __inheritance__.

Does `EngineStressSuite` want only some/part of the behavior exposed by `EngineTestBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  26 </span>import kotlin.coroutines.*
<span class="lineno">  27 </span>import kotlin.test.*
<span class="lineno">  28 </span>
<span class="lineno">  29 </span><span class="error">@RunWith(StressSuiteRunner::class)</span>
<span class="lineno">  30 </span><span class="error">abstract class EngineStressSuite&lt;TEngine : ApplicationEngine, TConfiguration : ApplicationEngine.Configuration&gt;(</span>
<span class="lineno">  31 </span><span class="error">    hostFactory: ApplicationEngineFactory&lt;TEngine, TConfiguration&gt;</span>
<span class="lineno">  32 </span><span class="error">) : EngineTestBase&lt;TEngine, TConfiguration&gt;(hostFactory) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/EngineTestSuite.kt:39:1</span><span class="message">The class `EngineTestSuite` is using inheritance, consider using composition instead.

Does `EngineTestSuite` want to expose the complete interface (`tearDownBase, setUpBase`) of `EngineTestBase` such that `EngineTestSuite` can be used where `EngineTestBase` is expected? Indicates __inheritance__.

Does `EngineTestSuite` want only some/part of the behavior exposed by `EngineTestBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  36 </span>import kotlin.coroutines.*
<span class="lineno">  37 </span>import kotlin.test.*
<span class="lineno">  38 </span>
<span class="lineno">  39 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  40 </span><span class="error">abstract class EngineTestSuite&lt;TEngine : ApplicationEngine, TConfiguration : ApplicationEngine.Configuration&gt;(</span>
<span class="lineno">  41 </span><span class="error">    hostFactory: ApplicationEngineFactory&lt;TEngine, TConfiguration&gt;</span>
<span class="lineno">  42 </span><span class="error">) : EngineTestBase&lt;TEngine, TConfiguration&gt;(hostFactory) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/TestApplicationCall.kt:12:1</span><span class="message">The class `TestApplicationCall` is using inheritance, consider using composition instead.

Does `TestApplicationCall` want to expose the complete interface (`empty public interface`) of `BaseApplicationCall` such that `TestApplicationCall` can be used where `BaseApplicationCall` is expected? Indicates __inheritance__.

Does `TestApplicationCall` want only some/part of the behavior exposed by `BaseApplicationCall`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import kotlinx.coroutines.*
<span class="lineno">  10 </span>import kotlin.coroutines.*
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">/**</span>
<span class="lineno">  13 </span><span class="error"> * Represents a test application call that is used in [withTestApplication] and [handleRequest]</span>
<span class="lineno">  14 </span><span class="error"> */</span>
<span class="lineno">  15 </span><span class="error">class TestApplicationCall(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/TestApplicationEngine.kt:24:1</span><span class="message">The class `TestApplicationEngine` is using inheritance, consider using composition instead.

Does `TestApplicationEngine` want to expose the complete interface (`empty public interface`) of `BaseApplicationEngine` such that `TestApplicationEngine` can be used where `BaseApplicationEngine` is expected? Indicates __inheritance__.

Does `TestApplicationEngine` want only some/part of the behavior exposed by `BaseApplicationEngine`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  21 </span>import io.ktor.utils.io.*
<span class="lineno">  22 </span>import kotlin.coroutines.*
<span class="lineno">  23 </span>
<span class="lineno">  24 </span><span class="error">/**</span>
<span class="lineno">  25 </span><span class="error"> * ktor test engine that provides way to simulate application calls to existing application module(s)</span>
<span class="lineno">  26 </span><span class="error"> * without actual HTTP connection</span>
<span class="lineno">  27 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/TestApplicationEngine.kt:39:5</span><span class="message">The class `Configuration` is using inheritance, consider using composition instead.

Does `Configuration` want to expose the complete interface (`empty public interface`) of `Configuration` such that `Configuration` can be used where `Configuration` is expected? Indicates __inheritance__.

Does `Configuration` want only some/part of the behavior exposed by `Configuration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  36 </span>    override val coroutineContext: CoroutineContext
<span class="lineno">  37 </span>        get() = testEngineJob
<span class="lineno">  38 </span>
<span class="lineno">  39 </span>    <span class="error">/**</span>
<span class="lineno">  40 </span><span class="error">     * Test application engine configuration</span>
<span class="lineno">  41 </span><span class="error">     * @property dispatcher to run handlers and interceptors on</span>
<span class="lineno">  42 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/TestApplicationRequest.kt:18:1</span><span class="message">The class `TestApplicationRequest` is using inheritance, consider using composition instead.

Does `TestApplicationRequest` want to expose the complete interface (`empty public interface`) of `BaseApplicationRequest` such that `TestApplicationRequest` can be used where `BaseApplicationRequest` is expected? Indicates __inheritance__.

Does `TestApplicationRequest` want only some/part of the behavior exposed by `BaseApplicationRequest`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>import io.ktor.utils.io.charsets.*
<span class="lineno">  16 </span>import io.ktor.utils.io.core.*
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">/**</span>
<span class="lineno">  19 </span><span class="error"> * Represents a test application request</span>
<span class="lineno">  20 </span><span class="error"> *</span>
<span class="lineno">  21 </span><span class="error"> * @property method HTTP method to be sent or executed</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/TestApplicationResponse.kt:17:1</span><span class="message">The class `TestApplicationResponse` is using inheritance, consider using composition instead.

Does `TestApplicationResponse` want to expose the complete interface (`push, status, status`) of `BaseApplicationResponse` such that `TestApplicationResponse` can be used where `BaseApplicationResponse` is expected? Indicates __inheritance__.

Does `TestApplicationResponse` want only some/part of the behavior exposed by `BaseApplicationResponse`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  14 </span>import io.ktor.utils.io.*
<span class="lineno">  15 </span>import kotlin.coroutines.*
<span class="lineno">  16 </span>
<span class="lineno">  17 </span><span class="error">/**</span>
<span class="lineno">  18 </span><span class="error"> * Represents test call response received from server</span>
<span class="lineno">  19 </span><span class="error"> * @property readResponse if response channel need to be consumed into byteContent</span>
<span class="lineno">  20 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/client/TestHttpClientConfig.kt:10:1</span><span class="message">The class `TestHttpClientConfig` is using inheritance, consider using composition instead.

Does `TestHttpClientConfig` want to expose the complete interface (`empty public interface`) of `HttpClientEngineConfig` such that `TestHttpClientConfig` can be used where `HttpClientEngineConfig` is expected? Indicates __inheritance__.

Does `TestHttpClientConfig` want only some/part of the behavior exposed by `HttpClientEngineConfig`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import io.ktor.client.engine.*
<span class="lineno">   8 </span>import io.ktor.server.testing.*
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">class TestHttpClientConfig : HttpClientEngineConfig() {</span>
<span class="lineno">  11 </span><span class="error">    lateinit var app: TestApplicationEngine</span>
<span class="lineno">  12 </span><span class="error">}</span>
<span class="lineno">  13 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-test-host/jvm/src/io/ktor/server/testing/client/TestHttpClientEngine.kt:19:1</span><span class="message">The class `TestHttpClientEngine` is using inheritance, consider using composition instead.

Does `TestHttpClientEngine` want to expose the complete interface (`close`) of `HttpClientEngineBase` such that `TestHttpClientEngine` can be used where `HttpClientEngineBase` is expected? Indicates __inheritance__.

Does `TestHttpClientEngine` want only some/part of the behavior exposed by `HttpClientEngineBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>import kotlinx.coroutines.*
<span class="lineno">  17 </span>import kotlin.coroutines.*
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  20 </span><span class="error">@KtorExperimentalAPI</span>
<span class="lineno">  21 </span><span class="error">class TestHttpClientEngine(override val config: TestHttpClientConfig) : HttpClientEngineBase(&quot;ktor-test&quot;) {</span>
<span class="lineno">  22 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-tomcat/jvm/src/io/ktor/server/tomcat/TomcatApplicationEngine.kt:24:1</span><span class="message">The class `TomcatApplicationEngine` is using inheritance, consider using composition instead.

Does `TomcatApplicationEngine` want to expose the complete interface (`empty public interface`) of `BaseApplicationEngine` such that `TomcatApplicationEngine` can be used where `BaseApplicationEngine` is expected? Indicates __inheritance__.

Does `TomcatApplicationEngine` want only some/part of the behavior exposed by `BaseApplicationEngine`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  21 </span>import java.util.concurrent.*
<span class="lineno">  22 </span>import javax.servlet.*
<span class="lineno">  23 </span>
<span class="lineno">  24 </span><span class="error">/**</span>
<span class="lineno">  25 </span><span class="error"> * Tomcat application engine that runs it in embedded mode</span>
<span class="lineno">  26 </span><span class="error"> */</span>
<span class="lineno">  27 </span><span class="error">class TomcatApplicationEngine(environment: ApplicationEngineEnvironment, configure: Configuration.() -&gt; Unit) :</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-server/ktor-server-tomcat/jvm/src/io/ktor/server/tomcat/TomcatApplicationEngine.kt:29:5</span><span class="message">The class `Configuration` is using inheritance, consider using composition instead.

Does `Configuration` want to expose the complete interface (`empty public interface`) of `Configuration` such that `Configuration` can be used where `Configuration` is expected? Indicates __inheritance__.

Does `Configuration` want only some/part of the behavior exposed by `Configuration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  26 </span> */
<span class="lineno">  27 </span>class TomcatApplicationEngine(environment: ApplicationEngineEnvironment, configure: Configuration.() -&gt; Unit) :
<span class="lineno">  28 </span>    BaseApplicationEngine(environment) {
<span class="lineno">  29 </span>    <span class="error">/**</span>
<span class="lineno">  30 </span><span class="error">     * Tomcat engine specific configuration builder</span>
<span class="lineno">  31 </span><span class="error">     */</span>
<span class="lineno">  32 </span><span class="error">    class Configuration : BaseApplicationEngine.Configuration() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/common/src/io/ktor/util/cio/Channels.kt:9:1</span><span class="message">The class `ChannelIOException` is using inheritance, consider using composition instead.

Does `ChannelIOException` want to expose the complete interface (`empty public interface`) of `IOException` such that `ChannelIOException` can be used where `IOException` is expected? Indicates __inheritance__.

Does `ChannelIOException` want only some/part of the behavior exposed by `IOException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>
<span class="lineno">   7 </span>import io.ktor.utils.io.errors.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">/**</span>
<span class="lineno">  10 </span><span class="error"> * An exception thrown when an IO error occurred during reading or writing to/from the underlying channel.</span>
<span class="lineno">  11 </span><span class="error"> * The typical error is &quot;connection reset&quot; and so on.</span>
<span class="lineno">  12 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/common/src/io/ktor/util/cio/Channels.kt:15:1</span><span class="message">The class `ChannelWriteException` is using inheritance, consider using composition instead.

Does `ChannelWriteException` want to expose the complete interface (`empty public interface`) of `ChannelIOException` such that `ChannelWriteException` can be used where `ChannelIOException` is expected? Indicates __inheritance__.

Does `ChannelWriteException` want only some/part of the behavior exposed by `ChannelIOException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span> */
<span class="lineno">  13 </span>open class ChannelIOException(message: String, exception: Throwable) : IOException(message, exception)
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">/**</span>
<span class="lineno">  16 </span><span class="error"> * An exception that is thrown when an IO error occurred during writing to the destination channel.</span>
<span class="lineno">  17 </span><span class="error"> * Usually it happens when a remote client closed the connection.</span>
<span class="lineno">  18 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/common/src/io/ktor/util/cio/Channels.kt:22:1</span><span class="message">The class `ChannelReadException` is using inheritance, consider using composition instead.

Does `ChannelReadException` want to expose the complete interface (`empty public interface`) of `ChannelIOException` such that `ChannelReadException` can be used where `ChannelIOException` is expected? Indicates __inheritance__.

Does `ChannelReadException` want only some/part of the behavior exposed by `ChannelIOException`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  19 </span>class ChannelWriteException(message: String = &quot;Cannot write to a channel&quot;, exception: Throwable) :
<span class="lineno">  20 </span>    ChannelIOException(message, exception)
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">/**</span>
<span class="lineno">  23 </span><span class="error"> * An exception that is thrown when an IO error occurred during reading from the request channel.</span>
<span class="lineno">  24 </span><span class="error"> * Usually it happens when a remote client closed the connection.</span>
<span class="lineno">  25 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/common/src/io/ktor/util/collections/ConcurrentSet.kt:9:1</span><span class="message">The class `ConcurrentSet` is using inheritance, consider using composition instead.

Does `ConcurrentSet` want to expose the complete interface (`retainAll, removeAll, remove, iterator, clear, addAll, add, isEmpty, containsAll, contains`) of `ConcurrentCollection` such that `ConcurrentSet` can be used where `ConcurrentCollection` is expected? Indicates __inheritance__.

Does `ConcurrentSet` want only some/part of the behavior exposed by `ConcurrentCollection`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>
<span class="lineno">   7 </span>import io.ktor.util.*
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">@InternalAPI</span>
<span class="lineno">  10 </span><span class="error">class ConcurrentSet&lt;K&gt; constructor(</span>
<span class="lineno">  11 </span><span class="error">    private val delegate: MutableSet&lt;K&gt; = mutableSetOf(),</span>
<span class="lineno">  12 </span><span class="error">    private val lock: Lock = Lock()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/common/src/io/ktor/util/pipeline/Pipeline.kt:107:9</span><span class="message">The class `After` is using inheritance, consider using composition instead.

Does `After` want to expose the complete interface (`empty public interface`) of `PipelinePhaseRelation` such that `After` can be used where `PipelinePhaseRelation` is expected? Indicates __inheritance__.

Does `After` want only some/part of the behavior exposed by `PipelinePhaseRelation`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 104 </span>     * Represents relations between pipeline phases
<span class="lineno"> 105 </span>     */
<span class="lineno"> 106 </span>    private sealed class PipelinePhaseRelation {
<span class="lineno"> 107 </span>        <span class="error">/**</span>
<span class="lineno"> 108 </span><span class="error">         * Given phase should be executed after [relativeTo] phase</span>
<span class="lineno"> 109 </span><span class="error">         * @property relativeTo represents phases for relative positioning</span>
<span class="lineno"> 110 </span><span class="error">         */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/common/src/io/ktor/util/pipeline/Pipeline.kt:113:9</span><span class="message">The class `Before` is using inheritance, consider using composition instead.

Does `Before` want to expose the complete interface (`empty public interface`) of `PipelinePhaseRelation` such that `Before` can be used where `PipelinePhaseRelation` is expected? Indicates __inheritance__.

Does `Before` want only some/part of the behavior exposed by `PipelinePhaseRelation`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 110 </span>         */
<span class="lineno"> 111 </span>        class After(val relativeTo: PipelinePhase) : PipelinePhaseRelation()
<span class="lineno"> 112 </span>
<span class="lineno"> 113 </span>        <span class="error">/**</span>
<span class="lineno"> 114 </span><span class="error">         * Given phase should be executed before [relativeTo] phase</span>
<span class="lineno"> 115 </span><span class="error">         * @property relativeTo represents phases for relative positioning</span>
<span class="lineno"> 116 </span><span class="error">         */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/AttributesJvm.kt:35:1</span><span class="message">The class `ConcurrentSafeAttributes` is using inheritance, consider using composition instead.

Does `ConcurrentSafeAttributes` want to expose the complete interface (`remove, put, contains, getOrNull`) of `AttributesJvmBase` such that `ConcurrentSafeAttributes` can be used where `AttributesJvmBase` is expected? Indicates __inheritance__.

Does `ConcurrentSafeAttributes` want only some/part of the behavior exposed by `AttributesJvmBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  32 </span>        get() = map.keys.toList()
<span class="lineno">  33 </span>}
<span class="lineno">  34 </span>
<span class="lineno">  35 </span><span class="error">private class ConcurrentSafeAttributes : AttributesJvmBase() {</span>
<span class="lineno">  36 </span><span class="error">    override val map: ConcurrentHashMap&lt;AttributeKey&lt;*&gt;, Any?&gt; = ConcurrentHashMap()</span>
<span class="lineno">  37 </span><span class="error"></span>
<span class="lineno">  38 </span><span class="error">    /**</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/AttributesJvm.kt:52:1</span><span class="message">The class `HashMapAttributes` is using inheritance, consider using composition instead.

Does `HashMapAttributes` want to expose the complete interface (`remove, put, contains, getOrNull`) of `AttributesJvmBase` such that `HashMapAttributes` can be used where `AttributesJvmBase` is expected? Indicates __inheritance__.

Does `HashMapAttributes` want only some/part of the behavior exposed by `AttributesJvmBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  49 </span>    }
<span class="lineno">  50 </span>}
<span class="lineno">  51 </span>
<span class="lineno">  52 </span><span class="error">private class HashMapAttributes : AttributesJvmBase() {</span>
<span class="lineno">  53 </span><span class="error">    override val map: MutableMap&lt;AttributeKey&lt;*&gt;, Any?&gt; = HashMap()</span>
<span class="lineno">  54 </span><span class="error"></span>
<span class="lineno">  55 </span><span class="error">    /**</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/cio/ByteBufferPool.kt:21:1</span><span class="message">The class `ByteBufferPool` is using inheritance, consider using composition instead.

Does `ByteBufferPool` want to expose the complete interface (`dispose, recycle, borrow`) of `DefaultPool` such that `ByteBufferPool` can be used where `DefaultPool` is expected? Indicates __inheritance__.

Does `ByteBufferPool` want only some/part of the behavior exposed by `DefaultPool`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  18 </span>@KtorExperimentalAPI
<span class="lineno">  19 </span>val KtorDefaultPool: ObjectPool&lt;ByteBuffer&gt; = ByteBufferPool()
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">@InternalAPI</span>
<span class="lineno">  22 </span><span class="error">@Suppress(&quot;KDocMissingDocumentation&quot;)</span>
<span class="lineno">  23 </span><span class="error">class ByteBufferPool : DefaultPool&lt;ByteBuffer&gt;(DEFAULT_KTOR_POOL_SIZE) {</span>
<span class="lineno">  24 </span><span class="error">    override fun produceInstance(): ByteBuffer = ByteBuffer.allocate(DEFAULT_BUFFER_SIZE)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/internal/LockFreeLinkedList.kt:70:1</span><span class="message">The class `AtomicOp` is using inheritance, consider using composition instead.

Does `AtomicOp` want to expose the complete interface (`perform`) of `OpDescriptor` such that `AtomicOp` can be used where `OpDescriptor` is expected? Indicates __inheritance__.

Does `AtomicOp` want only some/part of the behavior exposed by `OpDescriptor`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  67 </span>
<span class="lineno">  68 </span>private val NO_DECISION: Any = Symbol(&quot;NO_DECISION&quot;)
<span class="lineno">  69 </span>
<span class="lineno">  70 </span><span class="error">/**</span>
<span class="lineno">  71 </span><span class="error"> * Descriptor for multi-word atomic operation.</span>
<span class="lineno">  72 </span><span class="error"> * Based on paper</span>
<span class="lineno">  73 </span><span class="error"> * [&quot;A Practical Multi-Word Compare-and-Swap Operation&quot;](http://www.cl.cam.ac.uk/research/srgnetos/papers/2002-casn.pdf)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/internal/LockFreeLinkedList.kt:149:5</span><span class="message">The class `CondAddOp` is using inheritance, consider using composition instead.

Does `CondAddOp` want to expose the complete interface (`perform, complete, prepare, tryDecide`) of `AtomicOp` such that `CondAddOp` can be used where `AtomicOp` is expected? Indicates __inheritance__.

Does `CondAddOp` want only some/part of the behavior exposed by `AtomicOp`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 146 </span>    private fun removed(): Removed =
<span class="lineno"> 147 </span>        _removedRef.value ?: Removed(this).also { _removedRef.lazySet(it) }
<span class="lineno"> 148 </span>
<span class="lineno"> 149 </span>    <span class="error">@PublishedApi</span>
<span class="lineno"> 150 </span><span class="error">    internal abstract class CondAddOp(</span>
<span class="lineno"> 151 </span><span class="error">        @JvmField val newNode: Node</span>
<span class="lineno"> 152 </span><span class="error">    ) : AtomicOp&lt;Node&gt;() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/internal/LockFreeLinkedList.kt:395:5</span><span class="message">The class `AddLastDesc` is using inheritance, consider using composition instead.

Does `AddLastDesc` want to expose the complete interface (`complete, prepare`) of `AbstractAtomicDesc` such that `AddLastDesc` can be used where `AbstractAtomicDesc` is expected? Indicates __inheritance__.

Does `AddLastDesc` want only some/part of the behavior exposed by `AbstractAtomicDesc`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 392 </span>
<span class="lineno"> 393 </span>    // ------ multi-word atomic operations helpers ------
<span class="lineno"> 394 </span>
<span class="lineno"> 395 </span>    <span class="error">public open class AddLastDesc&lt;T : Node&gt; constructor(</span>
<span class="lineno"> 396 </span><span class="error">        @JvmField val queue: Node,</span>
<span class="lineno"> 397 </span><span class="error">        @JvmField val node: T</span>
<span class="lineno"> 398 </span><span class="error">    ) : AbstractAtomicDesc() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/internal/LockFreeLinkedList.kt:448:5</span><span class="message">The class `RemoveFirstDesc` is using inheritance, consider using composition instead.

Does `RemoveFirstDesc` want to expose the complete interface (`complete, prepare`) of `AbstractAtomicDesc` such that `RemoveFirstDesc` can be used where `AbstractAtomicDesc` is expected? Indicates __inheritance__.

Does `RemoveFirstDesc` want only some/part of the behavior exposed by `AbstractAtomicDesc`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 445 </span>        }
<span class="lineno"> 446 </span>    }
<span class="lineno"> 447 </span>
<span class="lineno"> 448 </span>    <span class="error">public open class RemoveFirstDesc&lt;T&gt;(</span>
<span class="lineno"> 449 </span><span class="error">        @JvmField val queue: Node</span>
<span class="lineno"> 450 </span><span class="error">    ) : AbstractAtomicDesc() {</span>
<span class="lineno"> 451 </span><span class="error">        private val _affectedNode = atomic&lt;Node?&gt;(null)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/internal/LockFreeLinkedList.kt:490:5</span><span class="message">The class `AbstractAtomicDesc` is using inheritance, consider using composition instead.

Does `AbstractAtomicDesc` want to expose the complete interface (`complete, prepare`) of `AtomicDesc` such that `AbstractAtomicDesc` can be used where `AtomicDesc` is expected? Indicates __inheritance__.

Does `AbstractAtomicDesc` want only some/part of the behavior exposed by `AtomicDesc`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 487 </span>        final override fun finishOnSuccess(affected: Node, next: Node) = affected.finishRemove(next)
<span class="lineno"> 488 </span>    }
<span class="lineno"> 489 </span>
<span class="lineno"> 490 </span>    <span class="error">@InternalAPI</span>
<span class="lineno"> 491 </span><span class="error">    abstract class AbstractAtomicDesc : AtomicDesc() {</span>
<span class="lineno"> 492 </span><span class="error">        protected abstract val affectedNode: Node?</span>
<span class="lineno"> 493 </span><span class="error">        protected abstract val originalNext: Node?</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/internal/LockFreeLinkedList.kt:501:9</span><span class="message">The class `PrepareOp` is using inheritance, consider using composition instead.

Does `PrepareOp` want to expose the complete interface (`perform`) of `OpDescriptor` such that `PrepareOp` can be used where `OpDescriptor` is expected? Indicates __inheritance__.

Does `PrepareOp` want only some/part of the behavior exposed by `OpDescriptor`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 498 </span>        protected abstract fun updatedNext(affected: Node, next: Node): Any
<span class="lineno"> 499 </span>        protected abstract fun finishOnSuccess(affected: Node, next: Node)
<span class="lineno"> 500 </span>
<span class="lineno"> 501 </span>        <span class="error">// This is Harris's RDCSS (Restricted Double-Compare Single Swap) operation</span>
<span class="lineno"> 502 </span><span class="error">        // It inserts &quot;op&quot; descriptor of when &quot;op&quot; status is still undecided (rolls back otherwise)</span>
<span class="lineno"> 503 </span><span class="error">        private class PrepareOp(</span>
<span class="lineno"> 504 </span><span class="error">            @JvmField val next: Node,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/School/master/code/ktor/ktor-utils/jvm/src/io/ktor/util/internal/LockFreeLinkedList.kt:749:1</span><span class="message">The class `LockFreeLinkedListHead` is using inheritance, consider using composition instead.

Does `LockFreeLinkedListHead` want to expose the complete interface (`toString, removeFirstIfIsInstanceOfOrPeekIf, removeFirstIfIsInstanceOf, describeRemoveFirst, removeFirstOrNull, describeRemove, helpRemove, remove, addLastIfPrevAndIf, addLastIfPrev, addLastIf, describeAddLast, addLast, addOneIfEmpty`) of `LockFreeLinkedListNode` such that `LockFreeLinkedListHead` can be used where `LockFreeLinkedListNode` is expected? Indicates __inheritance__.

Does `LockFreeLinkedListHead` want only some/part of the behavior exposed by `LockFreeLinkedListNode`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 746 </span>@PublishedApi
<span class="lineno"> 747 </span>internal fun Any.unwrap(): Node = (this as? Removed)?.ref ?: this as Node
<span class="lineno"> 748 </span>
<span class="lineno"> 749 </span><span class="error">/**</span>
<span class="lineno"> 750 </span><span class="error"> * Head (sentinel) item of the linked list that is never removed.</span>
<span class="lineno"> 751 </span><span class="error"> *</span>
<span class="lineno"> 752 </span><span class="error"> * @suppress **This is unstable API and it is subject to change.**</span>
</code></pre>
      </li>
    </ul>
  </details>
</div>


generated with <a href="https://arturbosch.github.io/detekt">detekt version 1.7.4</a> on 2020-04-23 08:33:27 UTC.

</body>
</html>
