<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>detekt report</title>
    <style>
h2 {
  background-color: #666666;
  padding: 0.2em;
  color: #ffffff;
}
h3 {
  background-color:#f8dfdf;
  padding:0.5em;
}
.rule {
  background-color: #dddddd;
  padding: 0.3em;
  font-weight: bold;
}
.description {
  color:#000000;
  padding:0.3em;
}
.location {
  color: #690505;
  font-family: monospace;
  display: block;
}
.message {
  font-size: 0.8em;
  color: #444444;
  display: block;
  margin-top: 1pt;
}
.rule-container {
  border: 0.1em dashed #dddddd;
  padding: 0.1em;
  line-height: 1.5em;
  margin-bottom: 8px;
  margin-top: 8px;
}
pre {
  border: 1px solid #e0e0e0;
  overflow: scroll;
}
.lineno {
  color: #999999;
  background-color: #f0f0f0;
}
.error {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AwCFR4T/3uLMgAAADxJREFUCNdNyLERQEAABMCjL4lQwIzcjErpguAL+C9AvgKJDbeD/PRpLdm35Hm+MU+cB+tCKaJW4L4YBy+CAiLJrFs9mgAAAABJRU5ErkJggg==) bottom repeat-x;
}
.exception {
  color: #b60808;
  display: inline-block;
  background-color: #ecdada;
  border-color: #b60808;
  border-radius: 10px;
  border: solid 2px;
  padding-left: 16px;
  padding-right: 16px;
  margin-bottom: 16px;
}
</style>
</head>
<body>

<h1>detekt report</h1>

<h2>Metrics</h2>

<div>
  <ul>
    <li>667 number of kt files</li>
    <li>120 number of packages</li>
    <li>1,485 number of classes</li>
    <li>3,914 number of functions</li>
    <li>5,398 number of properties</li>
  </ul>
</div>


<h2>Complexity Report</h2>

<div>
  <ul>
    <li>57,996 lines of code (loc)</li>
    <li>46,823 source lines of code (sloc)</li>
    <li>32,945 logical lines of code (lloc)</li>
    <li>2,339 comment lines of code (cloc)</li>
    <li>7,958 McCabe complexity (mcc)</li>
    <li>831 number of total code smells</li>
    <li>4% comment source ratio</li>
    <li>241 mcc per 1,000 lloc</li>
    <li>25 code smells per 1,000 lloc</li>
  </ul>
</div>


<h2>Findings</h2>
<div>Total: 831
  <h3>detekt-hint: 831</h3>
  <details id="InterfaceSegregationPrinciple" open="open">
    <summary class="rule-container"><span class="rule">InterfaceSegregationPrinciple: 88 </span><span class="description">This rule reports classes that violates the Interface Segregation Principle.</span></summary>
    <ul>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-wizarddemo/src/main/java/com/airthings/wizarddemo/DemoActivity.kt:46:13</span><span class="message">backOnClick is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  43 </span>    val navigator by lazy {
<span class="lineno">  44 </span>        object : DemoNavigatorConfig(mutableListOf(DemoPage.PAGE_ONE), resources) {
<span class="lineno">  45 </span>
<span class="lineno">  46 </span>            <span class="error">override fun backOnClick(view: View) {</span>
<span class="lineno">  47 </span><span class="error">                // possiblyGotoPreviousPageOrExit()</span>
<span class="lineno">  48 </span><span class="error">            }</span>
<span class="lineno">  49 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-wizarddemo/src/main/java/com/airthings/wizarddemo/DemoActivity.kt:50:13</span><span class="message">cancelOnClick is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  47 </span>                // possiblyGotoPreviousPageOrExit()
<span class="lineno">  48 </span>            }
<span class="lineno">  49 </span>
<span class="lineno">  50 </span>            <span class="error">override fun cancelOnClick(view: View) {</span>
<span class="lineno">  51 </span><span class="error">                // possiblyCancelWizard()</span>
<span class="lineno">  52 </span><span class="error">            }</span>
<span class="lineno">  53 </span>        }
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-wizarddemo/src/main/java/com/airthings/wizarddemo/DemoActivity.kt:62:5</span><span class="message">restoreViewModelState is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class WizardStateHandler` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  59 </span>) : Wizard(activity, activity.navigator, activity.pagerAdapter), WizardStateHandler {
<span class="lineno">  60 </span>    override fun exportViewModelState(): Bundle? = null
<span class="lineno">  61 </span>
<span class="lineno">  62 </span>    <span class="error">override fun restoreViewModelState(inBundle: Bundle) {</span>
<span class="lineno">  63 </span><span class="error">        // NO-OP.</span>
<span class="lineno">  64 </span><span class="error">    }</span>
<span class="lineno">  65 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/androidTest/java/com/airthings/airthings/repository/TestRealmConfigManager.kt:8:5</span><span class="message">deleteAll is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class RealmConfigManager` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">   5 </span>import io.realm.RealmConfiguration
<span class="lineno">   6 </span>
<span class="lineno">   7 </span>class TestRealmConfigManager(val mainRealmInstance: Realm, val realmProvider: (serial: String) -&gt; RealmConfiguration) : RealmConfigManager {
<span class="lineno">   8 </span>    <span class="error">override suspend fun deleteAll() {</span>
<span class="lineno">   9 </span><span class="error">    }</span>
<span class="lineno">  10 </span>
<span class="lineno">  11 </span>    override fun getMainRealm(): Realm {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/activities/BaseActivity.kt:296:9</span><span class="message">onClick is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 293 </span>
<span class="lineno"> 294 </span>    // Default handler does nothing.
<span class="lineno"> 295 </span>    protected open val fwUpdateAvailableClickHandler = object : FwUpdateAvailableClickHandler {
<span class="lineno"> 296 </span>        <span class="error">override fun onClick() {</span>
<span class="lineno"> 297 </span><span class="error">            // NO-OP</span>
<span class="lineno"> 298 </span><span class="error">        }</span>
<span class="lineno"> 299 </span>    }
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/WaveClassicGen1UserDevice.kt:87:5</span><span class="message">writeDefaultSettings is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  84 </span>        }
<span class="lineno">  85 </span>    }
<span class="lineno">  86 </span>
<span class="lineno">  87 </span>    <span class="error">override suspend fun writeDefaultSettings(btDevice: AirthingsDevice) {</span>
<span class="lineno">  88 </span><span class="error">        // no default settings writing for Wave 1</span>
<span class="lineno">  89 </span><span class="error">    }</span>
<span class="lineno">  90 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/WaveClassicGen2UserDevice.kt:45:5</span><span class="message">writeDefaultSettings is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  42 </span>            SensorType.TEMPERATURE
<span class="lineno">  43 </span>        )
<span class="lineno">  44 </span>    }
<span class="lineno">  45 </span>    <span class="error">override suspend fun writeDefaultSettings(btDevice: AirthingsDevice) {</span>
<span class="lineno">  46 </span><span class="error">        // no default settings for Wave 2</span>
<span class="lineno">  47 </span><span class="error">    }</span>
<span class="lineno">  48 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/BluetoothRecordRepository.kt:19:5</span><span class="message">markRecordsAsSynced is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  16 </span>    serial: String
<span class="lineno">  17 </span>) : RecordRepository(serial, credentialRepository, TAG) {
<span class="lineno">  18 </span>
<span class="lineno">  19 </span>    <span class="error">override suspend fun markRecordsAsSynced(records: List&lt;RecordData&gt;) {</span>
<span class="lineno">  20 </span><span class="error">        // do nothing</span>
<span class="lineno">  21 </span><span class="error">    }</span>
<span class="lineno">  22 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/BluetoothRecordRepository.kt:67:5</span><span class="message">deleteAllRecords is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  64 </span>            }
<span class="lineno">  65 </span>        }
<span class="lineno">  66 </span>
<span class="lineno">  67 </span>    <span class="error">override suspend fun deleteAllRecords() {</span>
<span class="lineno">  68 </span><span class="error">        throw UnsupportedOperationException(&quot;Cannot delete bluetooth device records&quot;)</span>
<span class="lineno">  69 </span><span class="error">    }</span>
<span class="lineno">  70 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/CloudRecordRepository.kt:99:5</span><span class="message">deleteAllRecords is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  96 </span>        }
<span class="lineno">  97 </span>    }
<span class="lineno">  98 </span>
<span class="lineno">  99 </span>    <span class="error">override suspend fun deleteAllRecords() {</span>
<span class="lineno"> 100 </span><span class="error">        throw UnsupportedOperationException(&quot;Cannot delete cloud records&quot;)</span>
<span class="lineno"> 101 </span><span class="error">    }</span>
<span class="lineno"> 102 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/CloudRecordRepository.kt:103:5</span><span class="message">markRecordsAsSynced is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 100 </span>        throw UnsupportedOperationException(&quot;Cannot delete cloud records&quot;)
<span class="lineno"> 101 </span>    }
<span class="lineno"> 102 </span>
<span class="lineno"> 103 </span>    <span class="error">override suspend fun markRecordsAsSynced(records: List&lt;RecordData&gt;) {</span>
<span class="lineno"> 104 </span><span class="error">        // do nothing</span>
<span class="lineno"> 105 </span><span class="error">    }</span>
<span class="lineno"> 106 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/location/LocationServiceRepository.kt:47:5</span><span class="message">onStatusChanged is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  44 </span>        }
<span class="lineno">  45 </span>    }
<span class="lineno">  46 </span>
<span class="lineno">  47 </span>    <span class="error">override fun onStatusChanged(provider: String?, status: Int, extras: Bundle?) {</span>
<span class="lineno">  48 </span><span class="error">        // NO-OP</span>
<span class="lineno">  49 </span><span class="error">    }</span>
<span class="lineno">  50 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/location/LocationServiceRepository.kt:51:5</span><span class="message">onProviderEnabled is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  48 </span>        // NO-OP
<span class="lineno">  49 </span>    }
<span class="lineno">  50 </span>
<span class="lineno">  51 </span>    <span class="error">override fun onProviderEnabled(provider: String?) {</span>
<span class="lineno">  52 </span><span class="error">        // NO-OP</span>
<span class="lineno">  53 </span><span class="error">    }</span>
<span class="lineno">  54 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/location/LocationServiceRepository.kt:55:5</span><span class="message">onProviderDisabled is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  52 </span>        // NO-OP
<span class="lineno">  53 </span>    }
<span class="lineno">  54 </span>
<span class="lineno">  55 </span>    <span class="error">override fun onProviderDisabled(provider: String?) {</span>
<span class="lineno">  56 </span><span class="error">        // NO-OP</span>
<span class="lineno">  57 </span><span class="error">    }</span>
<span class="lineno">  58 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/addnewdevice/SetLocationPosViewModel.kt:140:13</span><span class="message">beforeTextChanged is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 137 </span>        }
<span class="lineno"> 138 </span>        searchEditText.onFocusChangeListener = onFocusChangeListener
<span class="lineno"> 139 </span>        searchEditText.addTextChangedListener(object : TextWatcher {
<span class="lineno"> 140 </span>            <span class="error">override fun beforeTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {</span>
<span class="lineno"> 141 </span><span class="error">            }</span>
<span class="lineno"> 142 </span>
<span class="lineno"> 143 </span>            override fun onTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/addnewdevice/SetLocationPosViewModel.kt:143:13</span><span class="message">onTextChanged is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 140 </span>            override fun beforeTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {
<span class="lineno"> 141 </span>            }
<span class="lineno"> 142 </span>
<span class="lineno"> 143 </span>            <span class="error">override fun onTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {</span>
<span class="lineno"> 144 </span><span class="error">            }</span>
<span class="lineno"> 145 </span>
<span class="lineno"> 146 </span>            override fun afterTextChanged(editable: Editable) {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/addnewdevice/SetLocationPosViewModel.kt:324:5</span><span class="message">onConnectionSuspended is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 321 </span>        googleMap!!.uiSettings.isZoomControlsEnabled = true
<span class="lineno"> 322 </span>    }
<span class="lineno"> 323 </span>
<span class="lineno"> 324 </span>    <span class="error">override fun onConnectionSuspended(i: Int) {</span>
<span class="lineno"> 325 </span><span class="error">        // TODO: NOT IMPLEMENTED</span>
<span class="lineno"> 326 </span><span class="error">    }</span>
<span class="lineno"> 327 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/addnewdevice/SetLocationPosViewModel.kt:328:5</span><span class="message">onConnectionFailed is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 325 </span>        // TODO: NOT IMPLEMENTED
<span class="lineno"> 326 </span>    }
<span class="lineno"> 327 </span>
<span class="lineno"> 328 </span>    <span class="error">override fun onConnectionFailed(connectionResult: ConnectionResult) {</span>
<span class="lineno"> 329 </span><span class="error">        // TODO: NOT IMPLEMENTED</span>
<span class="lineno"> 330 </span><span class="error">    }</span>
<span class="lineno"> 331 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/DetailedDashboardContainerActivity.kt:86:13</span><span class="message">onTabReselected is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  83 </span>        }
<span class="lineno">  84 </span>
<span class="lineno">  85 </span>        detailed_dashboard_tab_layout.addOnTabSelectedListener(object : TabLayout.OnTabSelectedListener {
<span class="lineno">  86 </span>            <span class="error">override fun onTabReselected(p0: TabLayout.Tab?) {</span>
<span class="lineno">  87 </span><span class="error">                // INTENTIONAL STUB</span>
<span class="lineno">  88 </span><span class="error">            }</span>
<span class="lineno">  89 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/DetailedDashboardContainerActivity.kt:90:13</span><span class="message">onTabUnselected is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  87 </span>                // INTENTIONAL STUB
<span class="lineno">  88 </span>            }
<span class="lineno">  89 </span>
<span class="lineno">  90 </span>            <span class="error">override fun onTabUnselected(p0: TabLayout.Tab?) {</span>
<span class="lineno">  91 </span><span class="error">                // INTENTIONAL STUB</span>
<span class="lineno">  92 </span><span class="error">            }</span>
<span class="lineno">  93 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/login/BaseAccountActivity.kt:35:5</span><span class="message">onUnAuthenticated is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  32 </span>        windowManager.defaultDisplay.getMetrics(metrics)
<span class="lineno">  33 </span>    }
<span class="lineno">  34 </span>
<span class="lineno">  35 </span>    <span class="error">override fun onUnAuthenticated() {</span>
<span class="lineno">  36 </span><span class="error">        // do nothing and override default behaviour</span>
<span class="lineno">  37 </span><span class="error">    }</span>
<span class="lineno">  38 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageinstrument/ManageDeviceActivity.kt:158:5</span><span class="message">showManageDevice is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class DeviceManagementParent` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 155 </span>        alertDialog.show()
<span class="lineno"> 156 </span>    }
<span class="lineno"> 157 </span>
<span class="lineno"> 158 </span>    <span class="error">override fun showManageDevice() {</span>
<span class="lineno"> 159 </span><span class="error">    }</span>
<span class="lineno"> 160 </span>
<span class="lineno"> 161 </span>    private suspend fun doUnPair() {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageinstrument/UpdateDevicePage.kt:10:5</span><span class="message">enumerateStepsForHub is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">   7 </span>internal class UpdateDevicePage : BaseProgressPage() {
<span class="lineno">   8 </span>    private lateinit var identifierOfLastStep: String
<span class="lineno">   9 </span>
<span class="lineno">  10 </span>    <span class="error">override fun enumerateStepsForHub() {</span>
<span class="lineno">  11 </span><span class="error">        // todo: what to do here?</span>
<span class="lineno">  12 </span><span class="error">    }</span>
<span class="lineno">  13 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/onboarding/OnboardingContainerActivity.kt:76:17</span><span class="message">onPageScrollStateChanged is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  73 </span>            adapter = OnboardingPageAdapter(supportFragmentManager, onboardingFragments)
<span class="lineno">  74 </span>
<span class="lineno">  75 </span>            addOnPageChangeListener(object : androidx.viewpager.widget.ViewPager.OnPageChangeListener {
<span class="lineno">  76 </span>                <span class="error">override fun onPageScrollStateChanged(p0: Int) {}</span>
<span class="lineno">  77 </span>
<span class="lineno">  78 </span>                override fun onPageScrolled(p0: Int, p1: Float, p2: Int) {}
<span class="lineno">  79 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/onboarding/OnboardingContainerActivity.kt:78:17</span><span class="message">onPageScrolled is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  75 </span>            addOnPageChangeListener(object : androidx.viewpager.widget.ViewPager.OnPageChangeListener {
<span class="lineno">  76 </span>                override fun onPageScrollStateChanged(p0: Int) {}
<span class="lineno">  77 </span>
<span class="lineno">  78 </span>                <span class="error">override fun onPageScrolled(p0: Int, p1: Float, p2: Int) {}</span>
<span class="lineno">  79 </span>
<span class="lineno">  80 </span>                override fun onPageSelected(index: Int) {
<span class="lineno">  81 </span>                    when (index) {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/ApplyWaveMapPage.kt:42:5</span><span class="message">onGoogleMapNotReady is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  39 </span>        updateMapMarker()
<span class="lineno">  40 </span>    }
<span class="lineno">  41 </span>
<span class="lineno">  42 </span>    <span class="error">override fun onGoogleMapNotReady() {</span>
<span class="lineno">  43 </span><span class="error">        // Show an error and enable user to retry? TODO</span>
<span class="lineno">  44 </span><span class="error">    }</span>
<span class="lineno">  45 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/DeviceNameHubPage.kt:60:5</span><span class="message">beforeTextChanged is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  57 </span>        }
<span class="lineno">  58 </span>    }
<span class="lineno">  59 </span>
<span class="lineno">  60 </span>    <span class="error">override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {</span>
<span class="lineno">  61 </span><span class="error">        // NO-OP</span>
<span class="lineno">  62 </span><span class="error">    }</span>
<span class="lineno">  63 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/DeviceNameHubPage.kt:64:5</span><span class="message">onTextChanged is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  61 </span>        // NO-OP
<span class="lineno">  62 </span>    }
<span class="lineno">  63 </span>
<span class="lineno">  64 </span>    <span class="error">override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {</span>
<span class="lineno">  65 </span><span class="error">        // NO-OP</span>
<span class="lineno">  66 </span><span class="error">    }</span>
<span class="lineno">  67 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/ProgressPage.kt:50:5</span><span class="message">saveTransientConfiguration is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class ResultHandler` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  47 </span>        enumerateCommonSteps()
<span class="lineno">  48 </span>    }
<span class="lineno">  49 </span>
<span class="lineno">  50 </span>    <span class="error">override suspend fun saveTransientConfiguration() {</span>
<span class="lineno">  51 </span><span class="error">        // NO-OP.</span>
<span class="lineno">  52 </span><span class="error">    }</span>
<span class="lineno">  53 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/test/java/com/airthings/airthings/repository/TestDeviceRepository.kt:40:5</span><span class="message">syncFromCloud is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class DeviceRepository` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  37 </span>        TODO(&quot;not implemented&quot;) // To change body of created functions use File | Settings | File Templates.
<span class="lineno">  38 </span>    }
<span class="lineno">  39 </span>
<span class="lineno">  40 </span>    <span class="error">override suspend fun syncFromCloud() {</span>
<span class="lineno">  41 </span><span class="error">    }</span>
<span class="lineno">  42 </span>
<span class="lineno">  43 </span>    override suspend fun syncAll() {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/test/java/com/airthings/airthings/repository/TestDeviceRepository.kt:43:5</span><span class="message">syncAll is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class DeviceRepository` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  40 </span>    override suspend fun syncFromCloud() {
<span class="lineno">  41 </span>    }
<span class="lineno">  42 </span>
<span class="lineno">  43 </span>    <span class="error">override suspend fun syncAll() {</span>
<span class="lineno">  44 </span><span class="error">    }</span>
<span class="lineno">  45 </span>
<span class="lineno">  46 </span>    override suspend fun discoverOwnDevices(filter: List&lt;UserDevice&gt;?) {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/test/java/com/airthings/airthings/repository/TestDeviceRepository.kt:46:5</span><span class="message">discoverOwnDevices is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class DeviceRepository` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  43 </span>    override suspend fun syncAll() {
<span class="lineno">  44 </span>    }
<span class="lineno">  45 </span>
<span class="lineno">  46 </span>    <span class="error">override suspend fun discoverOwnDevices(filter: List&lt;UserDevice&gt;?) {</span>
<span class="lineno">  47 </span><span class="error">    }</span>
<span class="lineno">  48 </span>
<span class="lineno">  49 </span>    override suspend fun isPairable(serialNumber: String, macAddress: String): Response&lt;Boolean&gt; {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/HubDevice.kt:20:5</span><span class="message">readCurrentValues is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  17 </span>    override fun connect(fn: (err: Throwable?) -&gt; Unit) =
<span class="lineno">  18 </span>        fn.invoke(NotImplementedError(&quot;Not supported by Hub&quot;))
<span class="lineno">  19 </span>
<span class="lineno">  20 </span>    <span class="error">override suspend fun readCurrentValues(): Pair&lt;Long, Map&lt;RecordType, Float?&gt;&gt; {</span>
<span class="lineno">  21 </span><span class="error">        throw UnsupportedOperationException()</span>
<span class="lineno">  22 </span><span class="error">    }</span>
<span class="lineno">  23 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-deviceio/src/androidTest/java/com/airthings/deviceio/DeviceFirmwareUpgradeTests.kt:67:17</span><span class="message">dfuProgressUpdated is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  64 </span>        Thread(Runnable {
<span class="lineno">  65 </span>            testSetup!!.testDev!!.deviceDFUDoUpgrade(object :
<span class="lineno">  66 </span>                DeviceFirmwareUpgradeProgressCallback {
<span class="lineno">  67 </span>                <span class="error">override fun dfuProgressUpdated(percentProgress: Float) {</span>
<span class="lineno">  68 </span><span class="error">                }</span>
<span class="lineno">  69 </span>
<span class="lineno">  70 </span>                override fun dfuProgressStatusChanged(status: DeviceFirmwareUpgradeProgressCallback.dfuStatus) {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-deviceio/src/androidTest/java/com/airthings/deviceio/DeviceManagerTests.kt:49:13</span><span class="message">deviceScanOKWithResults is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  46 </span>
<span class="lineno">  47 </span>        val d = DeviceManager(appContext)
<span class="lineno">  48 </span>        d.setDeviceManagerScanCB(object : DeviceManager.DeviceManagerScanCB {
<span class="lineno">  49 </span>            <span class="error">override fun deviceScanOKWithResults(ar: ArrayList&lt;Device&gt;) {</span>
<span class="lineno">  50 </span><span class="error">            }</span>
<span class="lineno">  51 </span>
<span class="lineno">  52 </span>            override fun deviceScanNewResult(d: Device) {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-deviceio/src/androidTest/java/com/airthings/deviceio/DeviceManagerTests.kt:58:13</span><span class="message">deviceScanFailed is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  55 </span>                }
<span class="lineno">  56 </span>            }
<span class="lineno">  57 </span>
<span class="lineno">  58 </span>            <span class="error">override fun deviceScanFailed(bleScannerError: BleScannerError) {</span>
<span class="lineno">  59 </span><span class="error">            }</span>
<span class="lineno">  60 </span>        })
<span class="lineno">  61 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/InstrumentInteractionHandler.kt:66:5</span><span class="message">initiateInteraction is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  63 </span>        )
<span class="lineno">  64 </span>    }
<span class="lineno">  65 </span>
<span class="lineno">  66 </span>    <span class="error">override fun initiateInteraction() {</span>
<span class="lineno">  67 </span><span class="error">        // NO-OP.</span>
<span class="lineno">  68 </span><span class="error">    }</span>
<span class="lineno">  69 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/InteractionClient.kt:96:13</span><span class="message">success is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class Callback` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  93 </span>        private fun hasTimedOut() = nextTimeout &lt; System.currentTimeMillis()
<span class="lineno">  94 </span>
<span class="lineno">  95 </span>        inner class StubbedCallback : ReadInstrumentClock.Callback {
<span class="lineno">  96 </span>            <span class="error">override fun success(sensorTime: Long) {</span>
<span class="lineno">  97 </span><span class="error">                // INTENTIONAL STUB</span>
<span class="lineno">  98 </span><span class="error">            }</span>
<span class="lineno">  99 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/InteractionClient.kt:100:13</span><span class="message">failed is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class Callback` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  97 </span>                // INTENTIONAL STUB
<span class="lineno">  98 </span>            }
<span class="lineno">  99 </span>
<span class="lineno"> 100 </span>            <span class="error">override fun failed() {</span>
<span class="lineno"> 101 </span><span class="error">                // INTENTIONAL STUB</span>
<span class="lineno"> 102 </span><span class="error">            }</span>
<span class="lineno"> 103 </span>        }
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/fwutil/BleFwImageLoader.kt:13:5</span><span class="message">tryLoadAndValidateImage is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  10 </span>
<span class="lineno">  11 </span>class BleFwImageLoader(path: String, val context: Context) : FwImageLoader(path) {
<span class="lineno">  12 </span>
<span class="lineno">  13 </span>    <span class="error">@Suppress(&quot;NotImplementedDeclaration&quot;)</span>
<span class="lineno">  14 </span><span class="error">    override fun tryLoadAndValidateImage(fileName: String) = throw NotImplementedError(&quot;Not implemented.&quot;)</span>
<span class="lineno">  15 </span>
<span class="lineno">  16 </span>    companion object {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/BtSampleMakerFactory.kt:28:5</span><span class="message">add5MinuteRecords is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  25 </span>
<span class="lineno">  26 </span>internal class NullBtSampleMaker(dataSetInfo: DataSetInfo, bleFwVersion: String, mspFwVersion: String) :
<span class="lineno">  27 </span>    BtSampleMaker(dataSetInfo, bleFwVersion, mspFwVersion) {
<span class="lineno">  28 </span>    <span class="error">override fun add5MinuteRecords(sensorRecords: ArrayList&lt;SensorRecord&gt;, block: HourInfoBlock, index: Int) {</span>
<span class="lineno">  29 </span><span class="error">        // STUBBED TO DO NOTHING</span>
<span class="lineno">  30 </span><span class="error">    }</span>
<span class="lineno">  31 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/BtSampleMakerFactory.kt:32:5</span><span class="message">addHourlyRecords is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  29 </span>        // STUBBED TO DO NOTHING
<span class="lineno">  30 </span>    }
<span class="lineno">  31 </span>
<span class="lineno">  32 </span>    <span class="error">override fun addHourlyRecords(sensorRecordsHourly: ArrayList&lt;SensorRecord&gt;, block: HourInfoBlock) {</span>
<span class="lineno">  33 </span><span class="error">        // STUBBED TO DO NOTHING</span>
<span class="lineno">  34 </span><span class="error">    }</span>
<span class="lineno">  35 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniCommProtocol.kt:47:5</span><span class="message">startNewMeasurement is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  44 </span>    override fun readBaseTime(): Try&lt;Date&gt; =
<span class="lineno">  45 </span>        Failure(RuntimeException(&quot;readBaseTime has not yet been implemented.&quot;))
<span class="lineno">  46 </span>
<span class="lineno">  47 </span>    <span class="error">override fun startNewMeasurement(delay: Int, durationCode: Int, restartOnDisconnect: Int) {</span>
<span class="lineno">  48 </span><span class="error">        // TODO: Implement</span>
<span class="lineno">  49 </span><span class="error">    }</span>
<span class="lineno">  50 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/WavePlusFwUpgrade2.kt:537:5</span><span class="message">completed is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class OadProgressCB` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 534 </span>        callback.progressUpdate(status, cal)
<span class="lineno"> 535 </span>    }
<span class="lineno"> 536 </span>
<span class="lineno"> 537 </span>    <span class="error">override fun completed(versions: UpdatedFirmwareImages) {</span>
<span class="lineno"> 538 </span><span class="error">        // IMPLEMENTATION IS INTENDED TO DO NOTHING.</span>
<span class="lineno"> 539 </span><span class="error">        throw IllegalStateException(&quot;Do not call this function. $versions&quot;)</span>
<span class="lineno"> 540 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/interactioncontrol/InteractionControllerImpl.kt:46:5</span><span class="message">interactionEstablished is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  43 </span>        }
<span class="lineno">  44 </span>    }
<span class="lineno">  45 </span>
<span class="lineno">  46 </span>    <span class="error">override fun interactionEstablished(serialNumber: String) {</span>
<span class="lineno">  47 </span><span class="error">        // TODO: Never called, so consider removal.</span>
<span class="lineno">  48 </span><span class="error">    }</span>
<span class="lineno">  49 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/oad/FakeGattClient.kt:71:5</span><span class="message">disconnect is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  68 </span>        this.latestConnectionState = connectionState
<span class="lineno">  69 </span>    }
<span class="lineno">  70 </span>
<span class="lineno">  71 </span>    <span class="error">override fun disconnect() {</span>
<span class="lineno">  72 </span><span class="error">    }</span>
<span class="lineno">  73 </span>
<span class="lineno">  74 </span>    override fun close() {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/oad/FakeGattClient.kt:74:5</span><span class="message">close is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  71 </span>    override fun disconnect() {
<span class="lineno">  72 </span>    }
<span class="lineno">  73 </span>
<span class="lineno">  74 </span>    <span class="error">override fun close() {</span>
<span class="lineno">  75 </span><span class="error">    }</span>
<span class="lineno">  76 </span>
<span class="lineno">  77 </span>    var requestedConnPri: Int? = null
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/oad/WavePlusFwUpgradeClientTest.kt:104:5</span><span class="message">progressUpdate is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class OadProgressCB` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 101 </span>        assert(result is Failure)
<span class="lineno"> 102 </span>    }
<span class="lineno"> 103 </span>
<span class="lineno"> 104 </span>    <span class="error">override fun progressUpdate(status: OadProgressCB.OadStatus, progressPercent: Double) {</span>
<span class="lineno"> 105 </span><span class="error">    }</span>
<span class="lineno"> 106 </span>
<span class="lineno"> 107 </span>    override fun completed(versions: UpdatedFirmwareImages) {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/oad/WavePlusFwUpgradeClientTest.kt:107:5</span><span class="message">completed is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class OadProgressCB` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 104 </span>    override fun progressUpdate(status: OadProgressCB.OadStatus, progressPercent: Double) {
<span class="lineno"> 105 </span>    }
<span class="lineno"> 106 </span>
<span class="lineno"> 107 </span>    <span class="error">override fun completed(versions: UpdatedFirmwareImages) {</span>
<span class="lineno"> 108 </span><span class="error">    }</span>
<span class="lineno"> 109 </span>}
<span class="lineno"> 110 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrumentops/NullCommand.kt:6:5</span><span class="message">runAsFailure is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">   3 </span>import android.content.Context
<span class="lineno">   4 </span>
<span class="lineno">   5 </span>internal class NullCommand(context: Context) : InstrumentCommand(context) {
<span class="lineno">   6 </span>    <span class="error">override fun runAsFailure() {</span>
<span class="lineno">   7 </span><span class="error">        // STUB</span>
<span class="lineno">   8 </span><span class="error">    }</span>
<span class="lineno">   9 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/interactioncontrol/InteractionControllerTest.kt:32:5</span><span class="message">interactionEstablished is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class InteractionMonitor` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  29 </span>
<span class="lineno">  30 </span>// This stub exist because mockito couldn't spy on the InteractionMonitor interface.
<span class="lineno">  31 </span>open class StubbedInteractionMonitor : InteractionMonitor {
<span class="lineno">  32 </span>    <span class="error">override fun interactionEstablished(serialNumber: String) {}</span>
<span class="lineno">  33 </span>    override fun interactionPending(serialNumber: String, clientId: UUID?) {}
<span class="lineno">  34 </span>    override fun interactionEnded(serialNumber: String, clientId: UUID?) {}
<span class="lineno">  35 </span>    override fun interactionError(serialNumber: String, clientId: UUID?, reason: String?) {}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/interactioncontrol/InteractionControllerTest.kt:33:5</span><span class="message">interactionPending is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class InteractionMonitor` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  30 </span>// This stub exist because mockito couldn't spy on the InteractionMonitor interface.
<span class="lineno">  31 </span>open class StubbedInteractionMonitor : InteractionMonitor {
<span class="lineno">  32 </span>    override fun interactionEstablished(serialNumber: String) {}
<span class="lineno">  33 </span>    <span class="error">override fun interactionPending(serialNumber: String, clientId: UUID?) {}</span>
<span class="lineno">  34 </span>    override fun interactionEnded(serialNumber: String, clientId: UUID?) {}
<span class="lineno">  35 </span>    override fun interactionError(serialNumber: String, clientId: UUID?, reason: String?) {}
<span class="lineno">  36 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/interactioncontrol/InteractionControllerTest.kt:34:5</span><span class="message">interactionEnded is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class InteractionMonitor` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  31 </span>open class StubbedInteractionMonitor : InteractionMonitor {
<span class="lineno">  32 </span>    override fun interactionEstablished(serialNumber: String) {}
<span class="lineno">  33 </span>    override fun interactionPending(serialNumber: String, clientId: UUID?) {}
<span class="lineno">  34 </span>    <span class="error">override fun interactionEnded(serialNumber: String, clientId: UUID?) {}</span>
<span class="lineno">  35 </span>    override fun interactionError(serialNumber: String, clientId: UUID?, reason: String?) {}
<span class="lineno">  36 </span>}
<span class="lineno">  37 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/interactioncontrol/InteractionControllerTest.kt:35:5</span><span class="message">interactionError is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class InteractionMonitor` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  32 </span>    override fun interactionEstablished(serialNumber: String) {}
<span class="lineno">  33 </span>    override fun interactionPending(serialNumber: String, clientId: UUID?) {}
<span class="lineno">  34 </span>    override fun interactionEnded(serialNumber: String, clientId: UUID?) {}
<span class="lineno">  35 </span>    <span class="error">override fun interactionError(serialNumber: String, clientId: UUID?, reason: String?) {}</span>
<span class="lineno">  36 </span>}
<span class="lineno">  37 </span>
<span class="lineno">  38 </span>internal open class FakeInteractionProvider : InteractionProvider(mock(Context::class.java)) {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/interactioncontrol/InteractionControllerTest.kt:52:5</span><span class="message">disconnect is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  49 </span>    serialNumber: String,
<span class="lineno">  50 </span>    callback: InteractionCallback2
<span class="lineno">  51 </span>) : InstrumentInteraction(context, serialNumber, callback) {
<span class="lineno">  52 </span>    <span class="error">override fun disconnect(serialNumber: String) {}</span>
<span class="lineno">  53 </span>    override fun initiateInteraction() {}
<span class="lineno">  54 </span>    override fun postCommand(commandId: InstrumentCommand) {}
<span class="lineno">  55 </span>    override fun isInitialized(): Boolean {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/interactioncontrol/InteractionControllerTest.kt:53:5</span><span class="message">initiateInteraction is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  50 </span>    callback: InteractionCallback2
<span class="lineno">  51 </span>) : InstrumentInteraction(context, serialNumber, callback) {
<span class="lineno">  52 </span>    override fun disconnect(serialNumber: String) {}
<span class="lineno">  53 </span>    <span class="error">override fun initiateInteraction() {}</span>
<span class="lineno">  54 </span>    override fun postCommand(commandId: InstrumentCommand) {}
<span class="lineno">  55 </span>    override fun isInitialized(): Boolean {
<span class="lineno">  56 </span>        return true
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/interactioncontrol/InteractionControllerTest.kt:54:5</span><span class="message">postCommand is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  51 </span>) : InstrumentInteraction(context, serialNumber, callback) {
<span class="lineno">  52 </span>    override fun disconnect(serialNumber: String) {}
<span class="lineno">  53 </span>    override fun initiateInteraction() {}
<span class="lineno">  54 </span>    <span class="error">override fun postCommand(commandId: InstrumentCommand) {}</span>
<span class="lineno">  55 </span>    override fun isInitialized(): Boolean {
<span class="lineno">  56 </span>        return true
<span class="lineno">  57 </span>    }
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/interactioncontrol/InteractionControllerTest.kt:274:9</span><span class="message">runAsFailure is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 271 </span>    }
<span class="lineno"> 272 </span>
<span class="lineno"> 273 </span>    open inner class DummyCommand(onCompletion: ((Try&lt;Unit&gt;) -&gt; Unit)) : InstrumentCommand(mock(Context::class.java), onCompletion) {
<span class="lineno"> 274 </span>        <span class="error">override fun runAsFailure() {}</span>
<span class="lineno"> 275 </span>    }
<span class="lineno"> 276 </span>
<span class="lineno"> 277 </span>    @Test
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/SandboxActivity.kt:43:13</span><span class="message">onStartTrackingTouch is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  40 </span>                batteryIndicator.setBatteryLevel(p1)
<span class="lineno">  41 </span>            }
<span class="lineno">  42 </span>
<span class="lineno">  43 </span>            <span class="error">override fun onStartTrackingTouch(p0: SeekBar?) {}</span>
<span class="lineno">  44 </span>
<span class="lineno">  45 </span>            override fun onStopTrackingTouch(p0: SeekBar?) {}
<span class="lineno">  46 </span>        })
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/SandboxActivity.kt:45:13</span><span class="message">onStopTrackingTouch is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  42 </span>
<span class="lineno">  43 </span>            override fun onStartTrackingTouch(p0: SeekBar?) {}
<span class="lineno">  44 </span>
<span class="lineno">  45 </span>            <span class="error">override fun onStopTrackingTouch(p0: SeekBar?) {}</span>
<span class="lineno">  46 </span>        })
<span class="lineno">  47 </span>
<span class="lineno">  48 </span>        val syncStatusIndicator = findViewById&lt;SyncStatusIndicator&gt;(R.id.sync_status_indicator)
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/dialogsheet/DialogSheetFragment.kt:104:5</span><span class="message">afterTextChanged is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 101 </span>
<span class="lineno"> 102 </span>    override fun firstButtonOnClick(view: View) = firstButtonOnClick(view, null)
<span class="lineno"> 103 </span>
<span class="lineno"> 104 </span>    <span class="error">final override fun afterTextChanged(s: Editable?) {</span>
<span class="lineno"> 105 </span><span class="error">        // NO-OP</span>
<span class="lineno"> 106 </span><span class="error">    }</span>
<span class="lineno"> 107 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/dialogsheet/DialogSheetFragment.kt:108:5</span><span class="message">beforeTextChanged is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 105 </span>        // NO-OP
<span class="lineno"> 106 </span>    }
<span class="lineno"> 107 </span>
<span class="lineno"> 108 </span>    <span class="error">final override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {</span>
<span class="lineno"> 109 </span><span class="error">        // NO-OP</span>
<span class="lineno"> 110 </span><span class="error">    }</span>
<span class="lineno"> 111 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/sensor/NullConfiguration.kt:9:5</span><span class="message">setSensorClickListeners is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class SensorLayoutConfiguration` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">   6 </span>import com.airthings.utilities.Log
<span class="lineno">   7 </span>
<span class="lineno">   8 </span>internal class NullConfiguration(context: Context, sensorViewLayout: SensorViewLayout) : ConfigurationBase(), SensorLayoutConfiguration {
<span class="lineno">   9 </span>    <span class="error">override fun setSensorClickListeners(function: (SensorViewConfig) -&gt; Unit) {</span>
<span class="lineno">  10 </span><span class="error">        // Intentional. No sensors in the null configuration. Therefore there will be no click listeners to set.</span>
<span class="lineno">  11 </span><span class="error">    }</span>
<span class="lineno">  12 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/bleinteraction/ConnectedState.kt:18:5</span><span class="message">onStateInteraction is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class State` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  15 </span>        stateController.refreshButton.setOnClickListener(null)
<span class="lineno">  16 </span>    }
<span class="lineno">  17 </span>
<span class="lineno">  18 </span>    <span class="error">override fun onStateInteraction(stateController: BluetoothInteractionWidgetController) {</span>
<span class="lineno">  19 </span><span class="error">        // DO NOTHING</span>
<span class="lineno">  20 </span><span class="error">    }</span>
<span class="lineno">  21 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/bleinteraction/ConnectingState.kt:17:5</span><span class="message">onStateInteraction is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class State` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  14 </span>        stateController.refreshButton.setOnClickListener(null)
<span class="lineno">  15 </span>    }
<span class="lineno">  16 </span>
<span class="lineno">  17 </span>    <span class="error">override fun onStateInteraction(stateController: BluetoothInteractionWidgetController) {</span>
<span class="lineno">  18 </span><span class="error">        // DO NOTHING</span>
<span class="lineno">  19 </span><span class="error">    }</span>
<span class="lineno">  20 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:185:5</span><span class="message">startAnimation is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 182 </span>        }
<span class="lineno"> 183 </span>    }
<span class="lineno"> 184 </span>
<span class="lineno"> 185 </span>    <span class="error">override fun startAnimation(updateListener: ValueAnimator.AnimatorUpdateListener) {</span>
<span class="lineno"> 186 </span><span class="error">        // NO ANIMATION FOR THIS CONFIGURATION.</span>
<span class="lineno"> 187 </span><span class="error">    }</span>
<span class="lineno"> 188 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:189:5</span><span class="message">updateAnimatedProperty is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 186 </span>        // NO ANIMATION FOR THIS CONFIGURATION.
<span class="lineno"> 187 </span>    }
<span class="lineno"> 188 </span>
<span class="lineno"> 189 </span>    <span class="error">override fun updateAnimatedProperty(animation: ValueAnimator) {</span>
<span class="lineno"> 190 </span><span class="error">        // NOTHING TO UPDATE HERE.</span>
<span class="lineno"> 191 </span><span class="error">    }</span>
<span class="lineno"> 192 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:193:5</span><span class="message">endAnimation is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 190 </span>        // NOTHING TO UPDATE HERE.
<span class="lineno"> 191 </span>    }
<span class="lineno"> 192 </span>
<span class="lineno"> 193 </span>    <span class="error">override fun endAnimation() {</span>
<span class="lineno"> 194 </span><span class="error">        // NO ANIMATION FOR THIS CONFIGURATION.</span>
<span class="lineno"> 195 </span><span class="error">    }</span>
<span class="lineno"> 196 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:281:5</span><span class="message">startAnimation is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 278 </span>
<span class="lineno"> 279 </span>    override val iconResource: Int = R.drawable.ic_cloud_download_stronghold_24dp
<span class="lineno"> 280 </span>
<span class="lineno"> 281 </span>    <span class="error">override fun startAnimation(updateListener: ValueAnimator.AnimatorUpdateListener) {</span>
<span class="lineno"> 282 </span><span class="error">        // NO ANIMATION FOR THIS CONFIGURATION.</span>
<span class="lineno"> 283 </span><span class="error">    }</span>
<span class="lineno"> 284 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:285:5</span><span class="message">updateAnimatedProperty is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 282 </span>        // NO ANIMATION FOR THIS CONFIGURATION.
<span class="lineno"> 283 </span>    }
<span class="lineno"> 284 </span>
<span class="lineno"> 285 </span>    <span class="error">override fun updateAnimatedProperty(animation: ValueAnimator) {</span>
<span class="lineno"> 286 </span><span class="error">        // NO ANIMATION FOR THIS CONFIGURATION.</span>
<span class="lineno"> 287 </span><span class="error">    }</span>
<span class="lineno"> 288 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:289:5</span><span class="message">endAnimation is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 286 </span>        // NO ANIMATION FOR THIS CONFIGURATION.
<span class="lineno"> 287 </span>    }
<span class="lineno"> 288 </span>
<span class="lineno"> 289 </span>    <span class="error">override fun endAnimation() {</span>
<span class="lineno"> 290 </span><span class="error">        // NO ANIMATION FOR THIS CONFIGURATION.</span>
<span class="lineno"> 291 </span><span class="error">    }</span>
<span class="lineno"> 292 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:307:5</span><span class="message">startAnimation is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 304 </span>
<span class="lineno"> 305 </span>    override val iconResource: Int = R.drawable.ic_cloud_upload_stronghold_24dp
<span class="lineno"> 306 </span>
<span class="lineno"> 307 </span>    <span class="error">override fun startAnimation(updateListener: ValueAnimator.AnimatorUpdateListener) {</span>
<span class="lineno"> 308 </span><span class="error">        // NO ANIMATION FOR THIS CONFIGURATION.</span>
<span class="lineno"> 309 </span><span class="error">    }</span>
<span class="lineno"> 310 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:311:5</span><span class="message">updateAnimatedProperty is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 308 </span>        // NO ANIMATION FOR THIS CONFIGURATION.
<span class="lineno"> 309 </span>    }
<span class="lineno"> 310 </span>
<span class="lineno"> 311 </span>    <span class="error">override fun updateAnimatedProperty(animation: ValueAnimator) {</span>
<span class="lineno"> 312 </span><span class="error">        // NO ANIMATION FOR THIS CONFIGURATION.</span>
<span class="lineno"> 313 </span><span class="error">    }</span>
<span class="lineno"> 314 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:315:5</span><span class="message">endAnimation is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 312 </span>        // NO ANIMATION FOR THIS CONFIGURATION.
<span class="lineno"> 313 </span>    }
<span class="lineno"> 314 </span>
<span class="lineno"> 315 </span>    <span class="error">override fun endAnimation() {</span>
<span class="lineno"> 316 </span><span class="error">        // NO ANIMATION FOR THIS CONFIGURATION.</span>
<span class="lineno"> 317 </span><span class="error">    }</span>
<span class="lineno"> 318 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:333:5</span><span class="message">startAnimation is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 330 </span>
<span class="lineno"> 331 </span>    override val iconResource: Int = R.drawable.ic_cloud_off_stronghold_24dp
<span class="lineno"> 332 </span>
<span class="lineno"> 333 </span>    <span class="error">override fun startAnimation(updateListener: ValueAnimator.AnimatorUpdateListener) {</span>
<span class="lineno"> 334 </span><span class="error">        // NO ANIMATION FOR THIS CONFIGURATION.</span>
<span class="lineno"> 335 </span><span class="error">    }</span>
<span class="lineno"> 336 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:337:5</span><span class="message">updateAnimatedProperty is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 334 </span>        // NO ANIMATION FOR THIS CONFIGURATION.
<span class="lineno"> 335 </span>    }
<span class="lineno"> 336 </span>
<span class="lineno"> 337 </span>    <span class="error">override fun updateAnimatedProperty(animation: ValueAnimator) {</span>
<span class="lineno"> 338 </span><span class="error">        // NO ANIMATION FOR THIS CONFIGURATION.</span>
<span class="lineno"> 339 </span><span class="error">    }</span>
<span class="lineno"> 340 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:341:5</span><span class="message">endAnimation is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 338 </span>        // NO ANIMATION FOR THIS CONFIGURATION.
<span class="lineno"> 339 </span>    }
<span class="lineno"> 340 </span>
<span class="lineno"> 341 </span>    <span class="error">override fun endAnimation() {</span>
<span class="lineno"> 342 </span><span class="error">        // NO ANIMATION FOR THIS CONFIGURATION.</span>
<span class="lineno"> 343 </span><span class="error">    }</span>
<span class="lineno"> 344 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:442:13</span><span class="message">onAnimationRepeat is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 439 </span>        animator.interpolator = AccelerateDecelerateInterpolator()
<span class="lineno"> 440 </span>        animator.addUpdateListener(updateListener)
<span class="lineno"> 441 </span>        animator.addListener(object : Animator.AnimatorListener {
<span class="lineno"> 442 </span>            <span class="error">override fun onAnimationRepeat(animation: Animator?) {</span>
<span class="lineno"> 443 </span><span class="error">                // INTENTIONAL STUB</span>
<span class="lineno"> 444 </span><span class="error">            }</span>
<span class="lineno"> 445 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:446:13</span><span class="message">onAnimationCancel is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 443 </span>                // INTENTIONAL STUB
<span class="lineno"> 444 </span>            }
<span class="lineno"> 445 </span>
<span class="lineno"> 446 </span>            <span class="error">override fun onAnimationCancel(animation: Animator?) {</span>
<span class="lineno"> 447 </span><span class="error">                // INTENTIONAL STUB</span>
<span class="lineno"> 448 </span><span class="error">            }</span>
<span class="lineno"> 449 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:450:13</span><span class="message">onAnimationStart is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 447 </span>                // INTENTIONAL STUB
<span class="lineno"> 448 </span>            }
<span class="lineno"> 449 </span>
<span class="lineno"> 450 </span>            <span class="error">override fun onAnimationStart(animation: Animator?) {</span>
<span class="lineno"> 451 </span><span class="error">                // INTENTIONAL STUB</span>
<span class="lineno"> 452 </span><span class="error">            }</span>
<span class="lineno"> 453 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:486:5</span><span class="message">startAnimation is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 483 </span>
<span class="lineno"> 484 </span>    override val iconResource: Int = R.drawable.ic_bluetooth_connected_stronghold_24dp
<span class="lineno"> 485 </span>
<span class="lineno"> 486 </span>    <span class="error">override fun startAnimation(updateListener: ValueAnimator.AnimatorUpdateListener) {</span>
<span class="lineno"> 487 </span><span class="error">        // NO ANIMATION FOR THIS CONFIGURATION.</span>
<span class="lineno"> 488 </span><span class="error">    }</span>
<span class="lineno"> 489 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:490:5</span><span class="message">updateAnimatedProperty is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 487 </span>        // NO ANIMATION FOR THIS CONFIGURATION.
<span class="lineno"> 488 </span>    }
<span class="lineno"> 489 </span>
<span class="lineno"> 490 </span>    <span class="error">override fun updateAnimatedProperty(animation: ValueAnimator) {</span>
<span class="lineno"> 491 </span><span class="error">        // NO ANIMATION FOR THIS CONFIGURATION.</span>
<span class="lineno"> 492 </span><span class="error">    }</span>
<span class="lineno"> 493 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:494:5</span><span class="message">endAnimation is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno"> 491 </span>        // NO ANIMATION FOR THIS CONFIGURATION.
<span class="lineno"> 492 </span>    }
<span class="lineno"> 493 </span>
<span class="lineno"> 494 </span>    <span class="error">override fun endAnimation() {</span>
<span class="lineno"> 495 </span><span class="error">        // NO ANIMATION FOR THIS CONFIGURATION.</span>
<span class="lineno"> 496 </span><span class="error">    }</span>
<span class="lineno"> 497 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/wizard/WizardPagerAdapter.kt:53:5</span><span class="message">onPageScrolled is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  50 </span>
<span class="lineno">  51 </span>    override fun containsItem(itemId: Long): Boolean = fragments.containsKey(itemId)
<span class="lineno">  52 </span>
<span class="lineno">  53 </span>    <span class="error">@CallSuper</span>
<span class="lineno">  54 </span><span class="error">    override fun onPageScrolled(position: Int, positionOffset: Float, @Px positionOffsetPixels: Int) {</span>
<span class="lineno">  55 </span><span class="error">        // NO-OP.</span>
<span class="lineno">  56 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/wizard/WizardPagerAdapter.kt:92:5</span><span class="message">onPageScrollStateChanged is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  89 </span>        previousPosition = position
<span class="lineno">  90 </span>    }
<span class="lineno">  91 </span>
<span class="lineno">  92 </span>    <span class="error">@CallSuper</span>
<span class="lineno">  93 </span><span class="error">    override fun onPageScrollStateChanged(state: Int) {</span>
<span class="lineno">  94 </span><span class="error">        // NO-OP.</span>
<span class="lineno">  95 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/wizard/transformer/CupertinoPageNavigationTransformer.kt:45:5</span><span class="message">onPreviousPageHidden is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class WizardPageTransformer` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  42 </span>        }
<span class="lineno">  43 </span>    }
<span class="lineno">  44 </span>
<span class="lineno">  45 </span>    <span class="error">override fun onPreviousPageHidden(rootBinding: WizardRootBinding, pageBinding: WizardPageBinding) {</span>
<span class="lineno">  46 </span><span class="error">        // NO-OP.</span>
<span class="lineno">  47 </span><span class="error">    }</span>
<span class="lineno">  48 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/wizard/transformer/CupertinoPageNavigationTransformer.kt:49:5</span><span class="message">onNextPageHidden is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up `class WizardPageTransformer` into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  46 </span>        // NO-OP.
<span class="lineno">  47 </span>    }
<span class="lineno">  48 </span>
<span class="lineno">  49 </span>    <span class="error">override fun onNextPageHidden(rootBinding: WizardRootBinding, pageBinding: WizardPageBinding) {</span>
<span class="lineno">  50 </span><span class="error">        // NO-OP.</span>
<span class="lineno">  51 </span><span class="error">    }</span>
<span class="lineno">  52 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/test/java/com/airthings/uicomponents/view/widget/inappnotificationpager/NotificationPagerAdapterTest.kt:93:9</span><span class="message">setViewPagerAdapter is not implemented an may not be necessary. This is a possible violation of the interface segregation principle. Consider splitting up into smaller interfaces with a single responsibility.</span>
        <pre><code><span class="lineno">  90 </span>    }
<span class="lineno">  91 </span>
<span class="lineno">  92 </span>    class NotificationContainerViewMock : NotificationContainerView(mock(Context::class.java)) {
<span class="lineno">  93 </span>        <span class="error">override fun setViewPagerAdapter(adapter: NotificationPagerAdapter?) {</span>
<span class="lineno">  94 </span><span class="error">            // INTENTIONAL STUB</span>
<span class="lineno">  95 </span><span class="error">        }</span>
<span class="lineno">  96 </span>    }
</code></pre>
      </li>
    </ul>
  </details>
  <details id="LackOfCohesionMethods" open="open">
    <summary class="rule-container"><span class="rule">LackOfCohesionMethods: 173 </span><span class="description">This rule reports a file with low LCOM value.</span></summary>
    <ul>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/ui/main/DeviceActionsViewModel.kt:35:1</span><span class="message">DeviceActionsViewModel have a too high LCOM value: 0.8917112299465241. Number of methods: 17, number of properties: 44, number of references: 81</span>
        <pre><code><span class="lineno">  32 </span>import kotlinx.coroutines.GlobalScope
<span class="lineno">  33 </span>import kotlinx.coroutines.launch
<span class="lineno">  34 </span>
<span class="lineno">  35 </span><span class="error">@Suppress(&quot;UndocumentedPublicProperty&quot;, &quot;TooManyFunctions&quot;)</span>
<span class="lineno">  36 </span><span class="error">class DeviceActionsViewModel : ViewModel() {</span>
<span class="lineno">  37 </span><span class="error">    private val log = mutableListOf&lt;Pair&lt;String, String&gt;&gt;()</span>
<span class="lineno">  38 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/ui/main/DeviceLogAdapter.kt:13:1</span><span class="message">DeviceLogAdapter have a too high LCOM value: 1.0. Number of methods: 4, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">  10 </span>import androidx.recyclerview.widget.RecyclerView
<span class="lineno">  11 </span>import com.airthings.waver.R
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class DeviceLogAdapter(private val log: List&lt;Pair&lt;String, String&gt;&gt;) : RecyclerView.Adapter&lt;DeviceLogAdapter.ViewHolder&gt;() {</span>
<span class="lineno">  14 </span><span class="error"></span>
<span class="lineno">  15 </span><span class="error">    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {</span>
<span class="lineno">  16 </span><span class="error">        return ViewHolder((parent.context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)!! as LayoutInflater)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/ui/main/LimitedDeviceActionsViewModel.kt:30:1</span><span class="message">LimitedDeviceActionsViewModel have a too high LCOM value: 0.8625. Number of methods: 5, number of properties: 16, number of references: 11</span>
        <pre><code><span class="lineno">  27 </span>        fn(this)
<span class="lineno">  28 </span>    }
<span class="lineno">  29 </span>
<span class="lineno">  30 </span><span class="error">@Suppress(&quot;UndocumentedPublicProperty&quot;)</span>
<span class="lineno">  31 </span><span class="error">class LimitedDeviceActionsViewModel : ViewModel() {</span>
<span class="lineno">  32 </span><span class="error"></span>
<span class="lineno">  33 </span><span class="error">    private lateinit var serial: String</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/ui/main/ScanResultAdapter.kt:15:1</span><span class="message">ScanResultAdapter have a too high LCOM value: 1.0. Number of methods: 5, number of properties: 5, number of references: 0</span>
        <pre><code><span class="lineno">  12 </span>import com.airthings.utilities.ui
<span class="lineno">  13 </span>import com.airthings.waver.R
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">class ScanResultAdapter : RecyclerView.Adapter&lt;ScanResultAdapter.ViewHolder&gt;() {</span>
<span class="lineno">  16 </span><span class="error">    @Suppress(&quot;MemberVisibilityCanBePrivate&quot;)</span>
<span class="lineno">  17 </span><span class="error">    var scanResults = mutableListOf&lt;AirthingsDevice&gt;()</span>
<span class="lineno">  18 </span><span class="error">    var onItemClicked: ((d: AirthingsDevice) -&gt; Unit)? = null</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/uisettings/UiSettingsComposerDialog.kt:22:1</span><span class="message">UiSettingsComposerDialog have a too high LCOM value: 0.8. Number of methods: 5, number of properties: 3, number of references: 3</span>
        <pre><code><span class="lineno">  19 </span>import com.google.android.material.bottomsheet.BottomSheetDialogFragment
<span class="lineno">  20 </span>import kotlinx.android.synthetic.main.ui_settings_placeholder.*
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">class UiSettingsComposerDialog private constructor(</span>
<span class="lineno">  23 </span><span class="error">    private val childFragment: UiSettingsComposerFragment</span>
<span class="lineno">  24 </span><span class="error">) : BottomSheetDialogFragment() {</span>
<span class="lineno">  25 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/uisettings/UiSettingsComposerDialog.kt:107:1</span><span class="message">PlaceholderUiSettingsComposerFragment have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno"> 104 </span>    abstract val onUpdate: ((uiSettings: UISettings) -&gt; Unit)
<span class="lineno"> 105 </span>}
<span class="lineno"> 106 </span>
<span class="lineno"> 107 </span><span class="error">class PlaceholderUiSettingsComposerFragment : UiSettingsComposerFragment() {</span>
<span class="lineno"> 108 </span><span class="error">    override val onUpdate: ((uiSettings: UISettings) -&gt; Unit) = {</span>
<span class="lineno"> 109 </span><span class="error">        // NO-OP</span>
<span class="lineno"> 110 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/androidTest/java/com/airthings/airthings/usecase/manageaccount/LogoutProcessTest.kt:24:1</span><span class="message">LogoutProcessTest have a too high LCOM value: 0.8333333333333334. Number of methods: 6, number of properties: 1, number of references: 1</span>
        <pre><code><span class="lineno">  21 </span>    }
<span class="lineno">  22 </span>}
<span class="lineno">  23 </span>
<span class="lineno">  24 </span><span class="error">class LogoutProcessTest {</span>
<span class="lineno">  25 </span><span class="error"></span>
<span class="lineno">  26 </span><span class="error">    private lateinit var logoutProcess: LogoutProcess</span>
<span class="lineno">  27 </span><span class="error">    private val context = InstrumentationRegistry.getTargetContext()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/AirthingsApp.kt:29:1</span><span class="message">AirthingsApp have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 4, number of references: 0</span>
        <pre><code><span class="lineno">  26 </span>import io.realm.Realm
<span class="lineno">  27 </span>import io.realm.RealmConfiguration
<span class="lineno">  28 </span>
<span class="lineno">  29 </span><span class="error">open class AirthingsApp : Application() {</span>
<span class="lineno">  30 </span><span class="error">    override fun onCreate() {</span>
<span class="lineno">  31 </span><span class="error">        super.onCreate()</span>
<span class="lineno">  32 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/AirthingsViewModel.kt:12:1</span><span class="message">AirthingsViewModel have a too high LCOM value: 0.8055555555555556. Number of methods: 4, number of properties: 9, number of references: 7</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.airthings.repository.location.LocationServiceRepository
<span class="lineno">  10 </span>import com.airthings.airthings.repository.storage.StorageServiceRepository
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">abstract class AirthingsViewModel(</span>
<span class="lineno">  13 </span><span class="error">    protected val credentialRepository: CredentialRepository,</span>
<span class="lineno">  14 </span><span class="error">    protected val userRepository: UserRepository,</span>
<span class="lineno">  15 </span><span class="error">    protected val internetServiceRepository: InternetServiceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/activities/BaseActivity.kt:34:1</span><span class="message">BaseActivity have a too high LCOM value: 0.8947368421052632. Number of methods: 19, number of properties: 8, number of references: 16</span>
        <pre><code><span class="lineno">  31 </span>import com.airthings.utilities.PermissionHelper
<span class="lineno">  32 </span>import javax.inject.Inject
<span class="lineno">  33 </span>
<span class="lineno">  34 </span><span class="error">abstract class BaseActivity&lt;VM : AirthingsViewModel&gt; : AppCompatActivity() {</span>
<span class="lineno">  35 </span><span class="error">    @Suppress(&quot;MemberVisibilityCanBePrivate&quot;)</span>
<span class="lineno">  36 </span><span class="error">    protected lateinit var viewModel: VM</span>
<span class="lineno">  37 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/activities/about/AboutMenuActivity.kt:11:1</span><span class="message">AboutMenuActivity have a too high LCOM value: 1.0. Number of methods: 10, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.airthings.activities.BaseActivity
<span class="lineno">   9 </span>import kotlinx.android.synthetic.main.activity_about_menu.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">class AboutMenuActivity : BaseActivity&lt;AboutMenuViewModel&gt;() {</span>
<span class="lineno">  12 </span><span class="error">    override val viewModelClass = AboutMenuViewModel::class.java</span>
<span class="lineno">  13 </span><span class="error"></span>
<span class="lineno">  14 </span><span class="error">    override fun onCreate(savedInstanceState: Bundle?) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/AppError.kt:5:1</span><span class="message">ApiAppError have a too high LCOM value: 0.9166666666666666. Number of methods: 2, number of properties: 24, number of references: 4</span>
        <pre><code><span class="lineno">   2 </span>
<span class="lineno">   3 </span>sealed class AppError
<span class="lineno">   4 </span>
<span class="lineno">   5 </span><span class="error">@Suppress(&quot;unused&quot;)</span>
<span class="lineno">   6 </span><span class="error">data class ApiAppError(val error: String = &quot;N/A&quot;, val errorCode: Int = -1) : AppError() {</span>
<span class="lineno">   7 </span><span class="error">    override fun toString(): String = &quot;$error ($errorCode)&quot;</span>
<span class="lineno">   8 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/Response.kt:3:1</span><span class="message">Response have a too high LCOM value: 0.8333333333333334. Number of methods: 3, number of properties: 4, number of references: 2</span>
        <pre><code><span class="lineno">   1 </span>package com.airthings.airthings.models
<span class="lineno">   2 </span>
<span class="lineno">   3 </span><span class="error">class Response&lt;T&gt; private constructor(val data: T?, val appError: AppError? = null) {</span>
<span class="lineno">   4 </span><span class="error">    companion object {</span>
<span class="lineno">   5 </span><span class="error">        fun &lt;T&gt; success(data: T) = Response(data)</span>
<span class="lineno">   6 </span><span class="error">        fun &lt;T&gt; fail(appError: AppError) = Response&lt;T&gt;(null, appError)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/data/Modules.kt:13:1</span><span class="message">RecordStoreModel have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  10 </span>import io.realm.RealmSchema
<span class="lineno">  11 </span>import io.realm.annotations.RealmModule
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">@RealmModule(classes = [RecordData::class])</span>
<span class="lineno">  14 </span><span class="error">open class RecordStoreModel {</span>
<span class="lineno">  15 </span><span class="error">    companion object {</span>
<span class="lineno">  16 </span><span class="error">        const val SCHEMA_VERSION = 1L</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/data/Modules.kt:24:1</span><span class="message">DeviceStoreModel have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">  21 </span>    }
<span class="lineno">  22 </span>}
<span class="lineno">  23 </span>
<span class="lineno">  24 </span><span class="error">@RealmModule(classes = [</span>
<span class="lineno">  25 </span><span class="error">    UserDeviceData::class,</span>
<span class="lineno">  26 </span><span class="error">    UserDeviceConfiguration::class,</span>
<span class="lineno">  27 </span><span class="error">    MetaData::class,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/data/Modules.kt:51:1</span><span class="message">DeviceStoreModelMigration have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  48 </span>    }
<span class="lineno">  49 </span>}
<span class="lineno">  50 </span>
<span class="lineno">  51 </span><span class="error">private class DeviceStoreModelMigration : RealmMigration {</span>
<span class="lineno">  52 </span><span class="error">    @Suppress(&quot;MagicNumber&quot;)</span>
<span class="lineno">  53 </span><span class="error">    @AddTrace(name = &quot;realmMigration&quot;, enabled = true)</span>
<span class="lineno">  54 </span><span class="error">    override fun migrate(realm: DynamicRealm, oldVersion: Long, newVersion: Long) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/data/RecordData.kt:13:1</span><span class="message">RecordData have a too high LCOM value: 0.84. Number of methods: 1, number of properties: 25, number of references: 4</span>
        <pre><code><span class="lineno">  10 </span>import io.realm.annotations.PrimaryKey
<span class="lineno">  11 </span>import io.realm.annotations.Required
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">open class RecordData : RealmObject() {</span>
<span class="lineno">  14 </span><span class="error">    @PrimaryKey</span>
<span class="lineno">  15 </span><span class="error">    lateinit var id: String</span>
<span class="lineno">  16 </span><span class="error">    @Required</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/data/UserDeviceData.kt:145:1</span><span class="message">UserDeviceConfiguration have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno"> 142 </span>    }
<span class="lineno"> 143 </span>}
<span class="lineno"> 144 </span>
<span class="lineno"> 145 </span><span class="error">@Suppress(&quot;MemberVisibilityCanBePrivate&quot;)</span>
<span class="lineno"> 146 </span><span class="error">open class UserDeviceConfiguration : RealmObject() {</span>
<span class="lineno"> 147 </span><span class="error">    /**</span>
<span class="lineno"> 148 </span><span class="error">     * The type of connection this device is configured to operate with (&quot;APP&quot; / &quot;HUB&quot;).</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/Assessor.kt:3:1</span><span class="message">Assessor have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 16, number of references: 0</span>
        <pre><code><span class="lineno">   1 </span>package com.airthings.airthings.models.device
<span class="lineno">   2 </span>
<span class="lineno">   3 </span><span class="error">open class Assessor {</span>
<span class="lineno">   4 </span><span class="error">    open fun overallAssessment(dataPoint: DataPoint): Assessment&lt;DataPoint&gt; {</span>
<span class="lineno">   5 </span><span class="error">        return dataPoint.values</span>
<span class="lineno">   6 </span><span class="error">                .map { getAssessment(it.key, it.value?.toFloat()) }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/ConnectedUserDevice.kt:34:1</span><span class="message">ConnectedUserDevice have a too high LCOM value: 0.9838709677419355. Number of methods: 31, number of properties: 4, number of references: 2</span>
        <pre><code><span class="lineno">  31 </span>import java.util.TreeMap
<span class="lineno">  32 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  33 </span>
<span class="lineno">  34 </span><span class="error">@Suppress(&quot;TooManyFunctions&quot;, &quot;LargeClass&quot;)</span>
<span class="lineno">  35 </span><span class="error">abstract class ConnectedUserDevice constructor(</span>
<span class="lineno">  36 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  37 </span><span class="error">    protected val deviceRepository: DeviceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/GriffinUserDevice.kt:17:1</span><span class="message">GriffinUserDevice have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 5, number of references: 0</span>
        <pre><code><span class="lineno">  14 </span>import com.airthings.instrumentapi.instrumentops.uisettings.griffin.B2CSetting
<span class="lineno">  15 </span>import com.airthings.instrumentapi.instrumentops.uisettings.griffin.SoundSetting
<span class="lineno">  16 </span>
<span class="lineno">  17 </span><span class="error">abstract class GriffinUserDevice(</span>
<span class="lineno">  18 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  19 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  20 </span><span class="error">    credentialRepository: CredentialRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/HubUserDevice.kt:6:1</span><span class="message">HubUserDevice have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 4, number of references: 0</span>
        <pre><code><span class="lineno">   3 </span>import com.airthings.airthings.models.data.UserDeviceData
<span class="lineno">   4 </span>import com.airthings.airthings.models.data.UserDeviceType
<span class="lineno">   5 </span>
<span class="lineno">   6 </span><span class="error">class HubUserDevice(userDeviceData: UserDeviceData) : UserDevice(userDeviceData) {</span>
<span class="lineno">   7 </span><span class="error">    override val modelName: String = &quot;Hub&quot;</span>
<span class="lineno">   8 </span><span class="error">    override val shortModelName = SHORT_MODEL_NAME</span>
<span class="lineno">   9 </span><span class="error">    override var isLinkable = false</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/UserDevice.kt:9:1</span><span class="message">UserDevice have a too high LCOM value: 0.8076923076923077. Number of methods: 4, number of properties: 13, number of references: 10</span>
        <pre><code><span class="lineno">   6 </span>import com.airthings.airthings.models.data.UserDeviceType
<span class="lineno">   7 </span>import io.realm.RealmChangeListener
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">abstract class UserDevice(protected val userDeviceData: UserDeviceData) {</span>
<span class="lineno">  10 </span><span class="error">    /**</span>
<span class="lineno">  11 </span><span class="error">     * The full model name of this device, for example: &quot;Wave Mini&quot;.</span>
<span class="lineno">  12 </span><span class="error">     */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/WaveClassicGen1UserDevice.kt:19:1</span><span class="message">WaveClassicGen1UserDevice have a too high LCOM value: 0.9714285714285714. Number of methods: 5, number of properties: 7, number of references: 1</span>
        <pre><code><span class="lineno">  16 </span>import com.airthings.instrumentapi.BleException
<span class="lineno">  17 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">class WaveClassicGen1UserDevice(</span>
<span class="lineno">  20 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  21 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  22 </span><span class="error">    credentialRepository: CredentialRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/WaveClassicGen2UserDevice.kt:12:1</span><span class="message">WaveClassicGen2UserDevice have a too high LCOM value: 0.9166666666666666. Number of methods: 2, number of properties: 6, number of references: 1</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.airthings.repository.RecordRepository
<span class="lineno">  10 </span>import com.airthings.airthings.repository.bluetooth.BluetoothServiceRepository
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class WaveClassicGen2UserDevice(</span>
<span class="lineno">  13 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  14 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  15 </span><span class="error">    credentialRepository: CredentialRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/WaveMiniUserDevice.kt:22:1</span><span class="message">WaveMiniUserDevice have a too high LCOM value: 0.9722222222222222. Number of methods: 4, number of properties: 9, number of references: 1</span>
        <pre><code><span class="lineno">  19 </span>import com.airthings.utilities.Success
<span class="lineno">  20 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">class WaveMiniUserDevice(</span>
<span class="lineno">  23 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  24 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  25 </span><span class="error">    credentialRepository: CredentialRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/WavePlusUserDevice.kt:18:1</span><span class="message">WavePlusUserDevice have a too high LCOM value: 0.9166666666666666. Number of methods: 2, number of properties: 6, number of references: 1</span>
        <pre><code><span class="lineno">  15 </span>import com.airthings.utilities.Success
<span class="lineno">  16 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">class WavePlusUserDevice(</span>
<span class="lineno">  19 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  20 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  21 </span><span class="error">    credentialRepository: CredentialRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/notifications/ATFirebaseMessagingService.kt:11:1</span><span class="message">ATFirebaseMessagingService have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   8 </span>import com.google.firebase.messaging.FirebaseMessagingService
<span class="lineno">   9 </span>import com.google.firebase.messaging.RemoteMessage
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">class ATFirebaseMessagingService : FirebaseMessagingService() {</span>
<span class="lineno">  12 </span><span class="error"></span>
<span class="lineno">  13 </span><span class="error">    companion object {</span>
<span class="lineno">  14 </span><span class="error">        private var notificationId = (System.currentTimeMillis() / 1000).toInt()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/persistence/RealmManager.kt:48:1</span><span class="message">RealmManager have a too high LCOM value: 0.8367346938775511. Number of methods: 7, number of properties: 7, number of references: 8</span>
        <pre><code><span class="lineno">  45 </span>suspend fun &lt;T&gt; withRealmContext(block: suspend CoroutineScope.() -&gt; T): T =
<span class="lineno">  46 </span>    withContext(RealmManager.dispatchContext, block)
<span class="lineno">  47 </span>
<span class="lineno">  48 </span><span class="error">class RealmManager(val context: Context) : RealmConfigManager {</span>
<span class="lineno">  49 </span><span class="error">    private var mainConfig: RealmConfiguration</span>
<span class="lineno">  50 </span><span class="error"></span>
<span class="lineno">  51 </span><span class="error">    private var mainRealm: Realm</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/realm/RealmMigration.kt:7:1</span><span class="message">RealmMigration have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   4 </span>import io.realm.FieldAttribute
<span class="lineno">   5 </span>import io.realm.RealmSchema
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">@Suppress(&quot;SimpleRedundantLet&quot;)</span>
<span class="lineno">   8 </span><span class="error">class RealmMigration : io.realm.RealmMigration {</span>
<span class="lineno">   9 </span><span class="error"></span>
<span class="lineno">  10 </span><span class="error">    override fun migrate(realm: DynamicRealm, oldVersion: Long, newVersion: Long) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/BluetoothRecordRepository.kt:13:1</span><span class="message">BluetoothRecordRepository have a too high LCOM value: 0.8571428571428572. Number of methods: 7, number of properties: 2, number of references: 2</span>
        <pre><code><span class="lineno">  10 </span>import java.util.Date
<span class="lineno">  11 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class BluetoothRecordRepository(</span>
<span class="lineno">  14 </span><span class="error">    private var atDevice: AirthingsDevice?,</span>
<span class="lineno">  15 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  16 </span><span class="error">    serial: String</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/CustomerSupportRepository.kt:29:1</span><span class="message">CustomerSupportRepositoryImpl have a too high LCOM value: 0.875. Number of methods: 4, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno">  26 </span>    ATTR_PRODUCT_WAVE_HUB(&quot;product_hub&quot;)
<span class="lineno">  27 </span>}
<span class="lineno">  28 </span>
<span class="lineno">  29 </span><span class="error">class CustomerSupportRepositoryImpl(</span>
<span class="lineno">  30 </span><span class="error">    private val intercomProvider: () -&gt; Intercom = { Intercom.client() }</span>
<span class="lineno">  31 </span><span class="error">) : CustomerSupportRepository {</span>
<span class="lineno">  32 </span><span class="error">    override fun userDevicesUpdated(userDevices: List&lt;UserDevice&gt;) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/DeviceRepository.kt:141:1</span><span class="message">DeviceRepositoryImpl have a too high LCOM value: 0.8842105263157894. Number of methods: 15, number of properties: 19, number of references: 33</span>
        <pre><code><span class="lineno"> 138 </span>    )
<span class="lineno"> 139 </span>}
<span class="lineno"> 140 </span>
<span class="lineno"> 141 </span><span class="error">class DeviceRepositoryImpl(</span>
<span class="lineno"> 142 </span><span class="error">    private val credentialRepository: CredentialRepository,</span>
<span class="lineno"> 143 </span><span class="error">    private val realmConfigManager: RealmConfigManager,</span>
<span class="lineno"> 144 </span><span class="error">    private val bluetoothServiceRepository: BluetoothServiceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/RealmRecordRepository.kt:12:1</span><span class="message">RealmRecordRepository have a too high LCOM value: 0.9583333333333334. Number of methods: 12, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno">   9 </span>import io.realm.Sort
<span class="lineno">  10 </span>import java.io.File
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class RealmRecordRepository(</span>
<span class="lineno">  13 </span><span class="error">    private val realmManager: RealmConfigManager,</span>
<span class="lineno">  14 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  15 </span><span class="error">    serial: String</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/addnewdevice/PairingCompletedViewModel.kt:25:1</span><span class="message">PairingCompletedViewModel have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">  22 </span>
<span class="lineno">  23 </span>data class PairedInstrument(val serialNumber: String, val room: String, val imageR: Int)
<span class="lineno">  24 </span>
<span class="lineno">  25 </span><span class="error">class PairingCompletedViewModel @Inject constructor(</span>
<span class="lineno">  26 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  27 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  28 </span><span class="error">    deviceRepository: DeviceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/addnewdevice/SetLocationPosViewModel.kt:49:1</span><span class="message">SetLocationPosViewModel have a too high LCOM value: 0.8290909090909091. Number of methods: 11, number of properties: 25, number of references: 47</span>
        <pre><code><span class="lineno">  46 </span>import java.util.Locale
<span class="lineno">  47 </span>import java.util.concurrent.TimeUnit
<span class="lineno">  48 </span>
<span class="lineno">  49 </span><span class="error">internal class SetLocationPosViewModel(</span>
<span class="lineno">  50 </span><span class="error">    private val activity: Activity,</span>
<span class="lineno">  51 </span><span class="error">    rootView: View,</span>
<span class="lineno">  52 </span><span class="error">    private val setLocationMode: PairingFlow.SetLocationMode,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/confirmaccount/ConfirmAccountActivity.kt:29:1</span><span class="message">ConfirmAccountActivity have a too high LCOM value: 0.8701298701298701. Number of methods: 7, number of properties: 11, number of references: 10</span>
        <pre><code><span class="lineno">  26 </span>import java.util.ArrayList
<span class="lineno">  27 </span>import java.util.Locale
<span class="lineno">  28 </span>
<span class="lineno">  29 </span><span class="error">class ConfirmAccountActivity : BaseAccountActivity&lt;ConfirmAccountViewModel&gt;(),</span>
<span class="lineno">  30 </span><span class="error">    InputValidatorListener {</span>
<span class="lineno">  31 </span><span class="error">    companion object {</span>
<span class="lineno">  32 </span><span class="error">        private const val TAG = &quot;ConfirmAccountActivity&quot;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/controlsync/ManageInstrumentDialogFragment.kt:25:1</span><span class="message">ManageInstrumentDialogFragment have a too high LCOM value: 1.0. Number of methods: 13, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  22 </span>import com.google.android.material.bottomsheet.BottomSheetBehavior
<span class="lineno">  23 </span>import com.google.android.material.bottomsheet.BottomSheetDialogFragment
<span class="lineno">  24 </span>
<span class="lineno">  25 </span><span class="error">class ManageInstrumentDialogFragment : DeviceManagementParent, BottomSheetDialogFragment() {</span>
<span class="lineno">  26 </span><span class="error">    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {</span>
<span class="lineno">  27 </span><span class="error">        val view = inflater.inflate(R.layout.fragment_bottom_sheet_dialog, container, false)</span>
<span class="lineno">  28 </span><span class="error">        childFragmentManager.replace(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/controlsync/SyncControlViewModel.kt:21:1</span><span class="message">SyncControlViewModel have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 4, number of references: 0</span>
        <pre><code><span class="lineno">  18 </span>import com.airthings.airthings.utils.suspendGetValue
<span class="lineno">  19 </span>import javax.inject.Inject
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">class SyncControlViewModel @Inject constructor(</span>
<span class="lineno">  22 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  23 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  24 </span><span class="error">    userRepository: UserRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/createaccount/CreateAccountActivity.kt:27:1</span><span class="message">CreateAccountActivity have a too high LCOM value: 0.89. Number of methods: 10, number of properties: 10, number of references: 11</span>
        <pre><code><span class="lineno">  24 </span>import com.airthings.uicomponents.view.inputcontainerlayout.PasswordInputContainerLayout
<span class="lineno">  25 </span>import java.util.ArrayList
<span class="lineno">  26 </span>
<span class="lineno">  27 </span><span class="error">class CreateAccountActivity : BaseAccountActivity&lt;CreateAccountViewModel&gt;(), InputValidatorListener {</span>
<span class="lineno">  28 </span><span class="error">    override val viewModelClass = CreateAccountViewModel::class.java</span>
<span class="lineno">  29 </span><span class="error"></span>
<span class="lineno">  30 </span><span class="error">    private lateinit var layoutName: NameInputContainerLayout</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/dashboard/DeviceSummaryActivity.kt:45:1</span><span class="message">DeviceSummaryActivity have a too high LCOM value: 0.9523809523809523. Number of methods: 3, number of properties: 7, number of references: 1</span>
        <pre><code><span class="lineno">  42 </span>import java.util.Date
<span class="lineno">  43 </span>import kotlinx.android.synthetic.main.activity_device_summary.*
<span class="lineno">  44 </span>
<span class="lineno">  45 </span><span class="error">class DeviceSummaryActivity : BaseActivity&lt;DeviceSummaryViewModel&gt;() {</span>
<span class="lineno">  46 </span><span class="error">    override val viewModelClass: Class&lt;DeviceSummaryViewModel&gt; = DeviceSummaryViewModel::class.java</span>
<span class="lineno">  47 </span><span class="error">    override val fwUpdateAvailableClickHandler = LaunchFwUpdateFragmentOperation()</span>
<span class="lineno">  48 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/DetailDashboardViewModel.kt:30:1</span><span class="message">DetailDashboardViewModel have a too high LCOM value: 0.875. Number of methods: 4, number of properties: 10, number of references: 5</span>
        <pre><code><span class="lineno">  27 </span>import java.util.TreeMap
<span class="lineno">  28 </span>import javax.inject.Inject
<span class="lineno">  29 </span>
<span class="lineno">  30 </span><span class="error">class DetailDashboardViewModel @Inject constructor(</span>
<span class="lineno">  31 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  32 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  33 </span><span class="error">    userRepository: UserRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/view/SensorHistoryFragment.kt:30:1</span><span class="message">SensorHistoryFragment have a too high LCOM value: 0.8. Number of methods: 6, number of properties: 10, number of references: 12</span>
        <pre><code><span class="lineno">  27 </span>import com.airthings.utilities.Log
<span class="lineno">  28 </span>import kotlinx.android.synthetic.main.fragment_detailed_dashboard_page.*
<span class="lineno">  29 </span>
<span class="lineno">  30 </span><span class="error">class SensorHistoryFragment : Fragment() {</span>
<span class="lineno">  31 </span><span class="error">    private lateinit var sensorType: SensorType</span>
<span class="lineno">  32 </span><span class="error">    private lateinit var h48Selected: LiveData&lt;Boolean&gt;</span>
<span class="lineno">  33 </span><span class="error">    private lateinit var weekSelected: LiveData&lt;Boolean&gt;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/devicemenu/DevicesActivity.kt:13:1</span><span class="message">DevicesActivity have a too high LCOM value: 1.0. Number of methods: 4, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">  10 </span>import com.airthings.airthings.wizard.device.page.progress.WizardActivity.Companion.STATE_NAVIGATOR_INITIAL_PAGE
<span class="lineno">  11 </span>import com.airthings.utilities.Log
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class DevicesActivity : BaseActivity&lt;DevicesViewModel&gt;() {</span>
<span class="lineno">  14 </span><span class="error">    override val viewModelClass = DevicesViewModel::class.java</span>
<span class="lineno">  15 </span><span class="error"></span>
<span class="lineno">  16 </span><span class="error">    override fun onCreate(savedInstanceState: Bundle?) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/devicemenu/DevicesListAdapter.kt:11:1</span><span class="message">DevicesListAdapter have a too high LCOM value: 1.0. Number of methods: 5, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.airthings.R
<span class="lineno">   9 </span>import com.airthings.airthings.models.device.UserDevice
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">class DevicesListAdapter : RecyclerView.Adapter&lt;DevicesListAdapter.ViewHolder&gt;() {</span>
<span class="lineno">  12 </span><span class="error"></span>
<span class="lineno">  13 </span><span class="error">    var items: List&lt;Item&gt; = mutableListOf()</span>
<span class="lineno">  14 </span><span class="error">        set(value) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/forgotpassword/ForgotPasswordActivity.kt:12:1</span><span class="message">ForgotPasswordActivity have a too high LCOM value: 1.0. Number of methods: 4, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.airthings.usecase.login.BaseAccountActivity
<span class="lineno">  10 </span>import com.airthings.airthings.usecase.selectinstrument.SelectInstrumentActivity
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class ForgotPasswordActivity : BaseAccountActivity&lt;ForgotPasswordViewModel&gt;() {</span>
<span class="lineno">  13 </span><span class="error">    override val viewModelClass = ForgotPasswordViewModel::class.java</span>
<span class="lineno">  14 </span><span class="error"></span>
<span class="lineno">  15 </span><span class="error">    override fun onAuthenticated() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/instrumentInfo/InstrumentInfoViewModel.kt:14:1</span><span class="message">InstrumentInfoViewModel have a too high LCOM value: 1.0. Number of methods: 6, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.airthings.utils.suspendGetValue
<span class="lineno">  12 </span>import javax.inject.Inject
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">class InstrumentInfoViewModel @Inject constructor(</span>
<span class="lineno">  15 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  16 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  17 </span><span class="error">    userRepository: UserRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/login/LoginActivity.kt:30:1</span><span class="message">LoginActivity have a too high LCOM value: 0.8375. Number of methods: 8, number of properties: 10, number of references: 13</span>
        <pre><code><span class="lineno">  27 </span>import java.util.Locale
<span class="lineno">  28 </span>import kotlinx.coroutines.Job
<span class="lineno">  29 </span>
<span class="lineno">  30 </span><span class="error">class LoginActivity : BaseAccountActivity&lt;LoginViewModel&gt;(), InputValidatorListener {</span>
<span class="lineno">  31 </span><span class="error">    companion object {</span>
<span class="lineno">  32 </span><span class="error">        private val TAG = LoginActivity::class.java.simpleName</span>
<span class="lineno">  33 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageaccount/ManageAccountViewModel.kt:17:1</span><span class="message">ManageAccountViewModel have a too high LCOM value: 0.8666666666666667. Number of methods: 3, number of properties: 5, number of references: 2</span>
        <pre><code><span class="lineno">  14 </span>import com.airthings.airthings.utils.not
<span class="lineno">  15 </span>import javax.inject.Inject
<span class="lineno">  16 </span>
<span class="lineno">  17 </span><span class="error">class ManageAccountViewModel @Inject constructor(</span>
<span class="lineno">  18 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  19 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  20 </span><span class="error">    internetServiceRepository: InternetServiceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageinstrument/ManageDeviceActivity.kt:29:1</span><span class="message">ManageDeviceActivity have a too high LCOM value: 0.925. Number of methods: 10, number of properties: 8, number of references: 6</span>
        <pre><code><span class="lineno">  26 </span>import java.util.Locale
<span class="lineno">  27 </span>import java.util.UUID
<span class="lineno">  28 </span>
<span class="lineno">  29 </span><span class="error">class ManageDeviceActivity : DeviceManagementParent, BaseActivity&lt;ManageDeviceViewModel&gt;() {</span>
<span class="lineno">  30 </span><span class="error"></span>
<span class="lineno">  31 </span><span class="error">    override val viewModelClass = ManageDeviceViewModel::class.java</span>
<span class="lineno">  32 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageinstrument/ManageDeviceFragment.kt:23:1</span><span class="message">ManageDeviceFragment have a too high LCOM value: 0.8. Number of methods: 6, number of properties: 5, number of references: 6</span>
        <pre><code><span class="lineno">  20 </span>import com.airthings.utilities.Log
<span class="lineno">  21 </span>import kotlinx.android.synthetic.main.fragment_manage_device.*
<span class="lineno">  22 </span>
<span class="lineno">  23 </span><span class="error">class ManageDeviceFragment : Fragment() {</span>
<span class="lineno">  24 </span><span class="error">    private lateinit var manageDeviceParent: DeviceManagementParent</span>
<span class="lineno">  25 </span><span class="error">    private val viewModel: ManageDeviceViewModel by viewModel()</span>
<span class="lineno">  26 </span><span class="error">    private lateinit var binding: FragmentManageDeviceBinding</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageinstrument/ManageDeviceViewModel.kt:26:1</span><span class="message">ManageDeviceViewModel have a too high LCOM value: 0.9494949494949495. Number of methods: 9, number of properties: 11, number of references: 5</span>
        <pre><code><span class="lineno">  23 </span>import com.airthings.utilities.Log
<span class="lineno">  24 </span>import javax.inject.Inject
<span class="lineno">  25 </span>
<span class="lineno">  26 </span><span class="error">class ManageDeviceViewModel @Inject constructor(</span>
<span class="lineno">  27 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  28 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  29 </span><span class="error">    deviceRepository: DeviceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageinstrument/UpdateDeviceWizardActivity.kt:14:1</span><span class="message">UpdateDeviceWizardActivity have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.uicomponents.wizard.WizardNavigatorConfig
<span class="lineno">  12 </span>import com.airthings.uicomponents.wizard.WizardPage
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">class UpdateDeviceWizardActivity : WizardActivity() {</span>
<span class="lineno">  15 </span><span class="error"></span>
<span class="lineno">  16 </span><span class="error">    override fun onCreate(savedInstanceState: Bundle?) {</span>
<span class="lineno">  17 </span><span class="error">        super.onCreate(savedInstanceState)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/onboarding/OnboardingContainerActivity.kt:17:1</span><span class="message">OnboardingContainerActivity have a too high LCOM value: 0.8333333333333334. Number of methods: 6, number of properties: 4, number of references: 4</span>
        <pre><code><span class="lineno">  14 </span>import com.airthings.airthings.usecase.selectinstrument.SelectInstrumentActivity
<span class="lineno">  15 </span>import kotlinx.android.synthetic.main.activity_onboarding.*
<span class="lineno">  16 </span>
<span class="lineno">  17 </span><span class="error">class OnboardingContainerActivity : BaseActivity&lt;OnBoardingViewModel&gt;() {</span>
<span class="lineno">  18 </span><span class="error">    override val viewModelClass: Class&lt;OnBoardingViewModel&gt; = OnBoardingViewModel::class.java</span>
<span class="lineno">  19 </span><span class="error"></span>
<span class="lineno">  20 </span><span class="error">    private val LOCAL_APP_HISTORY = &quot;LOCAL_APP_HISTORY&quot;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/selectinstrument/SelectInstrumentActivity.kt:39:1</span><span class="message">SelectInstrumentActivity have a too high LCOM value: 0.9333333333333333. Number of methods: 3, number of properties: 5, number of references: 1</span>
        <pre><code><span class="lineno">  36 </span>import kotlinx.android.synthetic.main.activity_select_instrument_main_view.select_instrument_recyclerView
<span class="lineno">  37 </span>import kotlinx.android.synthetic.main.activity_select_instrument_main_view.sync_refresh_layout
<span class="lineno">  38 </span>
<span class="lineno">  39 </span><span class="error">class SelectInstrumentActivity : BaseActivity&lt;SelectInstrumentViewModel&gt;() {</span>
<span class="lineno">  40 </span><span class="error">    private val instrumentSelectorAdapter = UserDevicesAdapter()</span>
<span class="lineno">  41 </span><span class="error">    private val deviceObservers = mutableMapOf&lt;ConnectedUserDevice, WeakReference&lt;Observer&lt;Long&gt;&gt;&gt;()</span>
<span class="lineno">  42 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/selectinstrument/UserDevicesAdapter.kt:25:1</span><span class="message">UserDevicesAdapter have a too high LCOM value: 0.859375. Number of methods: 8, number of properties: 8, number of references: 9</span>
        <pre><code><span class="lineno">  22 </span>import java.util.Calendar
<span class="lineno">  23 </span>import java.util.Date
<span class="lineno">  24 </span>
<span class="lineno">  25 </span><span class="error">class UserDevicesAdapter : RecyclerView.Adapter&lt;UserDevicesAdapter.ViewHolder&gt;() {</span>
<span class="lineno">  26 </span><span class="error"></span>
<span class="lineno">  27 </span><span class="error">    private var onInstrumentSelectedListener: ((String, View) -&gt; Unit)? = null</span>
<span class="lineno">  28 </span><span class="error">    private var itemList = mutableListOf&lt;ListItem&gt;()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/setlocation/SetLocationFragment.kt:18:1</span><span class="message">SetLocationFragment have a too high LCOM value: 0.825. Number of methods: 8, number of properties: 5, number of references: 7</span>
        <pre><code><span class="lineno">  15 </span>import com.google.android.gms.maps.MapsInitializer
<span class="lineno">  16 </span>import kotlinx.android.synthetic.main.fragment_set_location.*
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">class SetLocationFragment : Fragment() {</span>
<span class="lineno">  19 </span><span class="error"></span>
<span class="lineno">  20 </span><span class="error">    private var setLocationMode: PairingFlow.SetLocationMode = PairingFlow.SetLocationMode.AUTOMATIC</span>
<span class="lineno">  21 </span><span class="error">    private var locationPosViewModel: SetLocationPosViewModel? = null</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/settingsmenu/SettingsActivity.kt:15:1</span><span class="message">SettingsActivity have a too high LCOM value: 0.8333333333333334. Number of methods: 2, number of properties: 3, number of references: 1</span>
        <pre><code><span class="lineno">  12 </span>import com.airthings.utilities.Log
<span class="lineno">  13 </span>import kotlinx.android.synthetic.main.activity_settings.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">class SettingsActivity : BaseActivity&lt;ManageSettingsViewModel&gt;() {</span>
<span class="lineno">  16 </span><span class="error">    override val viewModelClass = ManageSettingsViewModel::class.java</span>
<span class="lineno">  17 </span><span class="error">    lateinit var waitDialog: ProgressDialog</span>
<span class="lineno">  18 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/support/SupportActivity.kt:9:1</span><span class="message">SupportActivity have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   6 </span>import com.airthings.airthings.activities.BaseActivity
<span class="lineno">   7 </span>import io.intercom.android.sdk.Intercom
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">class SupportActivity : BaseActivity&lt;SupportViewModel&gt;() {</span>
<span class="lineno">  10 </span><span class="error">    override val viewModelClass: Class&lt;SupportViewModel&gt; = SupportViewModel::class.java</span>
<span class="lineno">  11 </span><span class="error">    override fun onCreate(savedInstanceState: Bundle?) {</span>
<span class="lineno">  12 </span><span class="error">        super.onCreate(savedInstanceState)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/widget/circleview/CircleViewResources.kt:7:1</span><span class="message">CircleViewResources have a too high LCOM value: 0.8461538461538461. Number of methods: 3, number of properties: 26, number of references: 12</span>
        <pre><code><span class="lineno">   4 </span>import androidx.core.content.ContextCompat
<span class="lineno">   5 </span>import com.airthings.airthings.R
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">/**</span>
<span class="lineno">   8 </span><span class="error"> * Created by Vegard Stjerna Lindrup on 16.11.2016.</span>
<span class="lineno">   9 </span><span class="error"> */</span>
<span class="lineno">  10 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/AddDeviceWizardActivity.kt:9:1</span><span class="message">AddDeviceWizardActivity have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">   6 </span>import com.airthings.uicomponents.wizard.WizardPage
<span class="lineno">   7 </span>import com.airthings.uicomponents.wizard.WizardPagerAdapter
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">class AddDeviceWizardActivity : WizardActivity() {</span>
<span class="lineno">  10 </span><span class="error"></span>
<span class="lineno">  11 </span><span class="error">    override val pagerAdapter: WizardPagerAdapter by lazy { DevicePagerAdapter(this, navigator) }</span>
<span class="lineno">  12 </span><span class="error">    override val wizard by lazy {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/BaseCustomNameAdapter.kt:21:1</span><span class="message">BaseCustomNameAdapter have a too high LCOM value: 0.8611111111111112. Number of methods: 12, number of properties: 3, number of references: 5</span>
        <pre><code><span class="lineno">  18 </span>import com.airthings.uicomponents.UI_DELAY_SHORT
<span class="lineno">  19 </span>import java.util.UUID
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">/*</span>
<span class="lineno">  22 </span><span class="error">    This should be refactored to use separate views for each type of view in the list.</span>
<span class="lineno">  23 </span><span class="error">    One view for Default list items, and one view for custom list items.</span>
<span class="lineno">  24 </span><span class="error">*/</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/ConnectionFailedFragment.kt:13:1</span><span class="message">ConnectionFailedFragment have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">  10 </span>import com.airthings.utilities.NonNullMutableLiveData
<span class="lineno">  11 </span>import com.google.android.material.bottomsheet.BottomSheetDialog
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class ConnectionFailedFragment : DialogSheetFragment() {</span>
<span class="lineno">  14 </span><span class="error">    override val themeResourceId =</span>
<span class="lineno">  15 </span><span class="error">        R.style.DeviceWizardBottomSheetDialogTheme_Accent</span>
<span class="lineno">  16 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/DeviceViewModel.kt:36:1</span><span class="message">DeviceViewModel have a too high LCOM value: 0.9411764705882353. Number of methods: 29, number of properties: 17, number of references: 29</span>
        <pre><code><span class="lineno">  33 </span>import javax.inject.Inject
<span class="lineno">  34 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  35 </span>
<span class="lineno">  36 </span><span class="error">@Suppress(&quot;TooManyFunctions&quot;)</span>
<span class="lineno">  37 </span><span class="error">class DeviceViewModel @Inject constructor(</span>
<span class="lineno">  38 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  39 </span><span class="error">    userRepository: UserRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/TroubleshootingSheetFragment.kt:14:1</span><span class="message">TroubleshootingSheetFragment have a too high LCOM value: 0.9047619047619048. Number of methods: 3, number of properties: 7, number of references: 2</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.uicomponents.dialogsheet.FirstButtonPluggableDialogSheetUiConfig
<span class="lineno">  12 </span>import com.google.android.material.bottomsheet.BottomSheetDialog
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">/**</span>
<span class="lineno">  15 </span><span class="error"> * Shows a troubleshooting dialog that explains common problems when pairing a device.</span>
<span class="lineno">  16 </span><span class="error"> *</span>
<span class="lineno">  17 </span><span class="error"> * PS: Android requires this to be a public class, keep it as such -- or at least an internal one.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/ApplyWaveMapPage.kt:13:1</span><span class="message">ApplyWaveMapPage have a too high LCOM value: 0.8571428571428572. Number of methods: 7, number of properties: 2, number of references: 2</span>
        <pre><code><span class="lineno">  10 </span>import com.google.android.gms.maps.GoogleMap
<span class="lineno">  11 </span>import java.util.UUID
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">internal class ApplyWaveMapPage :</span>
<span class="lineno">  14 </span><span class="error">    GoogleMapsPage&lt;WizardDeviceApplyMapBinding&gt;(),</span>
<span class="lineno">  15 </span><span class="error">    LocationServiceRepository.LocationUpdateListener {</span>
<span class="lineno">  16 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/BasePage.kt:159:1</span><span class="message">LocationServicesDialogSheetFragmentImpl have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno"> 156 </span>    abstract fun isDependencyMet(context: Context): Boolean
<span class="lineno"> 157 </span>}
<span class="lineno"> 158 </span>
<span class="lineno"> 159 </span><span class="error">/**</span>
<span class="lineno"> 160 </span><span class="error"> * Implementation for a dialog bottom sheet asking the user to enable Location Services.</span>
<span class="lineno"> 161 </span><span class="error"> *</span>
<span class="lineno"> 162 </span><span class="error"> * PS: Android requires this to be a public class, keep it as such -- or at least an internal one.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/BasePage.kt:189:1</span><span class="message">ShareLocationDialogSheetFragmentImpl have a too high LCOM value: 0.8333333333333334. Number of methods: 3, number of properties: 4, number of references: 2</span>
        <pre><code><span class="lineno"> 186 </span>    }
<span class="lineno"> 187 </span>}
<span class="lineno"> 188 </span>
<span class="lineno"> 189 </span><span class="error">/**</span>
<span class="lineno"> 190 </span><span class="error"> * Implementation for a dialog bottom sheet asking the user to share her location.</span>
<span class="lineno"> 191 </span><span class="error"> *</span>
<span class="lineno"> 192 </span><span class="error"> * PS: Android requires this to be a public class, keep it as such -- or at least an internal one.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/BasePage.kt:253:1</span><span class="message">BluetoothDisabledDialogSheetFragmentImpl have a too high LCOM value: 0.875. Number of methods: 4, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno"> 250 </span>    }
<span class="lineno"> 251 </span>}
<span class="lineno"> 252 </span>
<span class="lineno"> 253 </span><span class="error">/**</span>
<span class="lineno"> 254 </span><span class="error"> * Implementation for a dialog bottom sheet asking the user to enable Bluetooth.</span>
<span class="lineno"> 255 </span><span class="error"> *</span>
<span class="lineno"> 256 </span><span class="error"> * PS: Android requires this to be a public class, keep it as such -- or at least an internal one.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/BaseResultAdapter.kt:10:1</span><span class="message">BaseResultAdapter have a too high LCOM value: 0.8. Number of methods: 5, number of properties: 1, number of references: 1</span>
        <pre><code><span class="lineno">   7 </span>import com.airthings.airthings.databinding.TileWizardDeviceUnpairedBinding
<span class="lineno">   8 </span>import com.airthings.airthings.utils.BaseRecyclerViewAdapter
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">internal abstract class BaseResultAdapter constructor(</span>
<span class="lineno">  11 </span><span class="error">    override val clickHandler: OnClickHandler&lt;AirthingsDevice, TileWizardDeviceUnpairedBinding&gt;</span>
<span class="lineno">  12 </span><span class="error">) : BaseRecyclerViewAdapter&lt;AirthingsDevice, TileWizardDeviceUnpairedBinding&gt;() {</span>
<span class="lineno">  13 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/DeviceNameHubPage.kt:18:1</span><span class="message">DeviceNameHubPage have a too high LCOM value: 0.8. Number of methods: 5, number of properties: 1, number of references: 1</span>
        <pre><code><span class="lineno">  15 </span>import com.airthings.airthings.utils.requestSoftKeyboard
<span class="lineno">  16 </span>import com.airthings.airthings.wizard.device.AddDevicePage
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">internal class DeviceNameHubPage : BasePage&lt;WizardDeviceNameHubBinding&gt;(), TextWatcher {</span>
<span class="lineno">  19 </span><span class="error"></span>
<span class="lineno">  20 </span><span class="error">    private lateinit var binding: WizardDeviceNameHubBinding</span>
<span class="lineno">  21 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/DeviceSelectionPage.kt:19:1</span><span class="message">DeviceSelectionPage have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  16 </span>import com.airthings.uicomponents.dialogsheet.PluggableDialogSheetFragment
<span class="lineno">  17 </span>import com.airthings.utilities.NonNullMutableLiveData
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">internal class DeviceSelectionPage : BaseDeviceSelectionPage() {</span>
<span class="lineno">  20 </span><span class="error"></span>
<span class="lineno">  21 </span><span class="error">    override val adapter: BaseResultAdapter = DeviceResultAdapter(this)</span>
<span class="lineno">  22 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/DeviceSelectionPage.kt:83:1</span><span class="message">UnpairableErrorSheetFragment have a too high LCOM value: 0.8666666666666667. Number of methods: 3, number of properties: 5, number of references: 2</span>
        <pre><code><span class="lineno">  80 </span>    }
<span class="lineno">  81 </span>}
<span class="lineno">  82 </span>
<span class="lineno">  83 </span><span class="error">// Android requires this to be a public class, keep it as such -- or at least an internal one.</span>
<span class="lineno">  84 </span><span class="error">internal class UnpairableErrorSheetFragment(</span>
<span class="lineno">  85 </span><span class="error">    private val serialNumber: String,</span>
<span class="lineno">  86 </span><span class="error">    private val launchSupport: (() -&gt; Unit)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/GoogleMapsPage.kt:18:1</span><span class="message">GoogleMapsPage have a too high LCOM value: 0.8461538461538461. Number of methods: 13, number of properties: 4, number of references: 8</span>
        <pre><code><span class="lineno">  15 </span>import com.google.android.gms.maps.model.LatLng
<span class="lineno">  16 </span>import com.google.android.gms.maps.model.MarkerOptions
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">internal abstract class GoogleMapsPage&lt;B : ViewDataBinding&gt; : BasePage&lt;B&gt;(), OnMapReadyCallback {</span>
<span class="lineno">  19 </span><span class="error"></span>
<span class="lineno">  20 </span><span class="error">    protected lateinit var mapView: MapView</span>
<span class="lineno">  21 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/LinkDeviceSelectionPage.kt:20:1</span><span class="message">LinkDeviceSelectionPage have a too high LCOM value: 0.9. Number of methods: 5, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno">  17 </span>import com.airthings.airthings.wizard.device.locationNameOf
<span class="lineno">  18 </span>import com.airthings.uicomponents.dialogsheet.PluggableDialogSheetFragment
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">internal class LinkDeviceSelectionPage : BaseDeviceSelectionPage() {</span>
<span class="lineno">  21 </span><span class="error"></span>
<span class="lineno">  22 </span><span class="error">    private val localDevices = mutableListOf&lt;UserDevice&gt;()</span>
<span class="lineno">  23 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/SetRegionPage.kt:140:1</span><span class="message">UnsupportedRegionFragment have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno"> 137 </span>    }
<span class="lineno"> 138 </span>}
<span class="lineno"> 139 </span>
<span class="lineno"> 140 </span><span class="error">// Android requires this to be a public class, keep it as such -- or at least an internal one.</span>
<span class="lineno"> 141 </span><span class="error">internal class UnsupportedRegionFragment : DialogSheetFragment() {</span>
<span class="lineno"> 142 </span><span class="error">    override val identifier = &quot;UnsupportedRegion&quot;</span>
<span class="lineno"> 143 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/BaseProgressPage.kt:231:1</span><span class="message">ProgressStep have a too high LCOM value: 0.9464285714285714. Number of methods: 7, number of properties: 8, number of references: 3</span>
        <pre><code><span class="lineno"> 228 </span>    }
<span class="lineno"> 229 </span>}
<span class="lineno"> 230 </span>
<span class="lineno"> 231 </span><span class="error">/**</span>
<span class="lineno"> 232 </span><span class="error"> * This includes logic to calculate the progress percentage of the [android.widget.ProgressBar] embedded in each</span>
<span class="lineno"> 233 </span><span class="error"> * progress page. Most pages will extend this class.</span>
<span class="lineno"> 234 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/BaseProgressPage.kt:301:1</span><span class="message">ProgressErrorSheetFragment have a too high LCOM value: 0.88. Number of methods: 5, number of properties: 5, number of references: 3</span>
        <pre><code><span class="lineno"> 298 </span>    }
<span class="lineno"> 299 </span>}
<span class="lineno"> 300 </span>
<span class="lineno"> 301 </span><span class="error">// Android requires this to be a public class, keep it as such -- or at least an internal one.</span>
<span class="lineno"> 302 </span><span class="error">internal class ProgressErrorSheetFragment(</span>
<span class="lineno"> 303 </span><span class="error">    val title: String,</span>
<span class="lineno"> 304 </span><span class="error">    val message: String,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/CheckFirmwareProgressStep.kt:7:1</span><span class="message">CheckFirmwareProgressStep have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.airthings.R
<span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class CheckFirmwareProgressStep(</span>
<span class="lineno">   8 </span><span class="error">    logTag: String,</span>
<span class="lineno">   9 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  10 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/ConnectProgressStep.kt:7:1</span><span class="message">ConnectProgressStep have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.airthings.R
<span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class ConnectProgressStep(</span>
<span class="lineno">   8 </span><span class="error">    logTag: String,</span>
<span class="lineno">   9 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  10 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/DownloadProgressStep.kt:7:1</span><span class="message">DownloadProgressStep have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.airthings.R
<span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class DownloadProgressStep(</span>
<span class="lineno">   8 </span><span class="error">    logTag: String,</span>
<span class="lineno">   9 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  10 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/PairProgressStep.kt:7:1</span><span class="message">PairProgressStep have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.airthings.R
<span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class PairProgressStep(</span>
<span class="lineno">   8 </span><span class="error">    logTag: String,</span>
<span class="lineno">   9 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  10 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/ProgressPage.kt:14:1</span><span class="message">ProgressPage have a too high LCOM value: 1.0. Number of methods: 4, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.airthings.wizard.device.page.RegionItem
<span class="lineno">  12 </span>import com.airthings.airthings.wizard.device.page.progress.WizardActivity.Companion.STATE_NAVIGATOR_INITIAL_PAGE
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">internal class ProgressPage : BaseProgressPage(), DoneProgressStep.ResultHandler {</span>
<span class="lineno">  15 </span><span class="error"></span>
<span class="lineno">  16 </span><span class="error">    private val region: RegionItem by lazy {</span>
<span class="lineno">  17 </span><span class="error">        val region = viewModel.region.value</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/ReadFirmwareProgressStep.kt:8:1</span><span class="message">ReadFirmwareProgressStep have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   6 </span>import com.airthings.instrumentapi.BleException
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">internal class ReadFirmwareProgressStep(</span>
<span class="lineno">   9 </span><span class="error">    logTag: String,</span>
<span class="lineno">  10 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  11 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/SetHubRegionProgressStep.kt:7:1</span><span class="message">SetHubRegionProgressStep have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.airthings.R
<span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class SetHubRegionProgressStep constructor(</span>
<span class="lineno">   8 </span><span class="error">    logTag: String,</span>
<span class="lineno">   9 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  10 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/SetWaveRegionProgressStep.kt:7:1</span><span class="message">SetWaveRegionProgressStep have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.airthings.R
<span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class SetWaveRegionProgressStep constructor(</span>
<span class="lineno">   8 </span><span class="error">    logTag: String,</span>
<span class="lineno">   9 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  10 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/WizardActivity.kt:14:1</span><span class="message">WizardActivity have a too high LCOM value: 0.8392857142857143. Number of methods: 8, number of properties: 7, number of references: 9</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.uicomponents.wizard.WizardPage
<span class="lineno">  12 </span>import com.airthings.uicomponents.wizard.WizardPagerAdapter
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">abstract class WizardActivity : BaseActivity&lt;DeviceViewModel&gt;() {</span>
<span class="lineno">  15 </span><span class="error"></span>
<span class="lineno">  16 </span><span class="error">    internal lateinit var navigator: WizardNavigatorConfig</span>
<span class="lineno">  17 </span><span class="error">    internal abstract val pagerAdapter: WizardPagerAdapter</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/test/java/com/airthings/airthings/models/device/ConnectedUserDeviceTest.kt:35:1</span><span class="message">TestUserDevice have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 6, number of references: 0</span>
        <pre><code><span class="lineno">  32 </span>import org.mockito.Mockito.`when`
<span class="lineno">  33 </span>import org.mockito.Mockito.mock
<span class="lineno">  34 </span>
<span class="lineno">  35 </span><span class="error">class TestUserDevice(</span>
<span class="lineno">  36 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  37 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  38 </span><span class="error">    credentialRepository: CredentialRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/test/java/com/airthings/airthings/models/device/ConnectedUserDeviceTest.kt:64:1</span><span class="message">ConnectedUserDeviceTest have a too high LCOM value: 0.9583333333333334. Number of methods: 8, number of properties: 6, number of references: 2</span>
        <pre><code><span class="lineno">  61 </span>        Boolean = availableUpdates.isNotEmpty()
<span class="lineno">  62 </span>}
<span class="lineno">  63 </span>
<span class="lineno">  64 </span><span class="error">class ConnectedUserDeviceTest {</span>
<span class="lineno">  65 </span><span class="error">    @get:Rule</span>
<span class="lineno">  66 </span><span class="error">    val rule = InstantTaskExecutorRule()</span>
<span class="lineno">  67 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/test/java/com/airthings/airthings/repository/RecordRepositoryTest.kt:15:1</span><span class="message">RecordRepositoryTest have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  12 </span>import org.mockito.Mockito.`when`
<span class="lineno">  13 </span>import org.mockito.Mockito.mock
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">class RecordRepositoryTest {</span>
<span class="lineno">  16 </span><span class="error">    @get:Rule</span>
<span class="lineno">  17 </span><span class="error">    val rule = InstantTaskExecutorRule()</span>
<span class="lineno">  18 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/test/java/com/airthings/airthings/repository/TestDeviceRepository.kt:14:1</span><span class="message">TestDeviceRepository have a too high LCOM value: 1.0. Number of methods: 13, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.core.util.FirmwareImage
<span class="lineno">  12 </span>import com.airthings.core.util.FirmwareImageType
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">class TestDeviceRepository(testDevices: List&lt;UserDevice&gt;) : DeviceRepository {</span>
<span class="lineno">  15 </span><span class="error">    override val devicesLiveData: LiveData&lt;List&lt;UserDevice&gt;&gt; = MutableLiveData&lt;List&lt;UserDevice&gt;&gt;().apply {</span>
<span class="lineno">  16 </span><span class="error">        value = testDevices</span>
<span class="lineno">  17 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/test/java/com/airthings/airthings/repository/TestUserRepository.kt:12:1</span><span class="message">TestUserRepository have a too high LCOM value: 0.96875. Number of methods: 16, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.airthings.models.data.UserData
<span class="lineno">  10 </span>import com.airthings.core.entities.Region
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class TestUserRepository : UserRepository {</span>
<span class="lineno">  13 </span><span class="error">    private val isAuthenticated = MutableLiveData&lt;Boolean&gt;().apply { value = true }</span>
<span class="lineno">  14 </span><span class="error"></span>
<span class="lineno">  15 </span><span class="error">    override fun isAuthenticated(): LiveData&lt;Boolean&gt; = isAuthenticated</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/AirthingsDevice.kt:72:1</span><span class="message">AirthingsDevice have a too high LCOM value: 0.8148148148148149. Number of methods: 27, number of properties: 1, number of references: 5</span>
        <pre><code><span class="lineno">  69 </span>
<span class="lineno">  70 </span>typealias DeviceScannerListener = (status: ScanStatus, device: AirthingsDevice?, err: ScannerException?) -&gt; Unit
<span class="lineno">  71 </span>
<span class="lineno">  72 </span><span class="error">@Suppress(&quot;TooManyFunctions&quot;) // Why? This is the nature of the beast :)</span>
<span class="lineno">  73 </span><span class="error">abstract class AirthingsDevice protected constructor(val serial: String, val mac: String, val model: Model) {</span>
<span class="lineno">  74 </span><span class="error"></span>
<span class="lineno">  75 </span><span class="error">    private lateinit var scanResult: InstrumentScanResult</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/GriffinDevice.kt:16:1</span><span class="message">GriffinDevice have a too high LCOM value: 1.0. Number of methods: 5, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  13 </span>import com.airthings.utilities.ui
<span class="lineno">  14 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">abstract class GriffinDevice(serial: String, mac: String, model: Model) : AirthingsRadonDevice(serial, mac, model) {</span>
<span class="lineno">  17 </span><span class="error">    override val defaultUISettings: UISettings = WavePlusUiSettings()</span>
<span class="lineno">  18 </span><span class="error"></span>
<span class="lineno">  19 </span><span class="error">    override fun pulse(fn: (err: Throwable?) -&gt; Unit) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/HubDevice.kt:11:1</span><span class="message">HubDevice have a too high LCOM value: 1.0. Number of methods: 8, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.utilities.TryCallback
<span class="lineno">   9 </span>import java.lang.UnsupportedOperationException
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">open class HubDevice(serial: String, mac: String) : AirthingsDevice(serial, mac, Model.Hub) {</span>
<span class="lineno">  12 </span><span class="error"></span>
<span class="lineno">  13 </span><span class="error">    override val modelName: String = &quot;Hub&quot;</span>
<span class="lineno">  14 </span><span class="error">    override val defaultUISettings: UISettings</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/MerlinDevice.kt:15:1</span><span class="message">MerlinDevice have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  12 </span>import com.airthings.utilities.ui
<span class="lineno">  13 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">abstract class MerlinDevice(serial: String, mac: String, model: Model) : AirthingsDevice(serial, mac, model) {</span>
<span class="lineno">  16 </span><span class="error">    override val defaultUISettings: UISettings = MerlinUiSettings()</span>
<span class="lineno">  17 </span><span class="error">    override fun pulse(fn: (err: Throwable?) -&gt; Unit) {</span>
<span class="lineno">  18 </span><span class="error">        this.interactionClient.postCommand(this.serial,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/Observer.kt:8:1</span><span class="message">Observable have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   5 </span>
<span class="lineno">   6 </span>typealias Observer&lt;T&gt; = ((MutableObservable&lt;T&gt;) -&gt; Boolean)
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">abstract class Observable&lt;T&gt; {</span>
<span class="lineno">   9 </span><span class="error">    abstract val value: T</span>
<span class="lineno">  10 </span><span class="error"></span>
<span class="lineno">  11 </span><span class="error">    abstract fun observe(observer: (Observable&lt;T&gt;) -&gt; Boolean)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/UnknownDevice.kt:6:1</span><span class="message">UnknownDevice have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">   3 </span>import com.airthings.core.entities.Region
<span class="lineno">   4 </span>import com.airthings.instrumentapi.instrumentops.uisettings.UISettings
<span class="lineno">   5 </span>
<span class="lineno">   6 </span><span class="error">/**</span>
<span class="lineno">   7 </span><span class="error"> * This is left here in case the app needs to use it for some reason. It has no power in AirCurtain beyond that.</span>
<span class="lineno">   8 </span><span class="error"> */</span>
<span class="lineno">   9 </span><span class="error">@Suppress(&quot;unused&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/Wave1Device.kt:20:1</span><span class="message">Wave1Device have a too high LCOM value: 1.0. Number of methods: 8, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">  17 </span>import com.airthings.utilities.Success
<span class="lineno">  18 </span>import com.airthings.utilities.ui
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">open class Wave1Device(serial: String, mac: String) : AirthingsRadonDevice(serial, mac, Model.Wave1) {</span>
<span class="lineno">  21 </span><span class="error"></span>
<span class="lineno">  22 </span><span class="error">    override val modelName: String = &quot;Wave&quot;</span>
<span class="lineno">  23 </span><span class="error">    override val defaultUISettings: UISettings = WaveUiSettings()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/Wave2Device.kt:7:1</span><span class="message">Wave2Device have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.instrumentapi.instrumentops.UICommand
<span class="lineno">   5 </span>import com.airthings.utilities.ui
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">open class Wave2Device(serial: String, mac: String) : GriffinDevice(serial, mac, Model.Wave2) {</span>
<span class="lineno">   8 </span><span class="error">    override val modelName: String = &quot;Wave&quot;</span>
<span class="lineno">   9 </span><span class="error"></span>
<span class="lineno">  10 </span><span class="error">    override fun pulse(fn: (err: Throwable?) -&gt; Unit) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/WavePlusDevice.kt:7:1</span><span class="message">WavePlusDevice have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.instrumentapi.instrumentops.UICommand
<span class="lineno">   5 </span>import com.airthings.utilities.ui
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">open class WavePlusDevice(serial: String, mac: String) : GriffinDevice(serial, mac, Model.WavePlus) {</span>
<span class="lineno">   8 </span><span class="error">    override val modelName: String = &quot;Wave Plus&quot;</span>
<span class="lineno">   9 </span><span class="error"></span>
<span class="lineno">  10 </span><span class="error">    override fun pulse(fn: (err: Throwable?) -&gt; Unit) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-core/src/main/java/com/airthings/core/entities/instrument/Instrument.kt:8:1</span><span class="message">Instrument have a too high LCOM value: 0.9875776397515528. Number of methods: 7, number of properties: 23, number of references: 2</span>
        <pre><code><span class="lineno">   5 </span>
<span class="lineno">   6 </span>open class SimpleInstrument(open val type: Instrument.Type, open val serialNumber: String)
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">class Instrument(</span>
<span class="lineno">   9 </span><span class="error">    override val type: Type,</span>
<span class="lineno">  10 </span><span class="error">    override val serialNumber: String</span>
<span class="lineno">  11 </span><span class="error">) : SimpleInstrument(type, serialNumber), ISensors {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-core/src/main/java/com/airthings/core/entities/instrument/SampleMetaData.kt:5:1</span><span class="message">SampleMetaData have a too high LCOM value: 0.8888888888888888. Number of methods: 1, number of properties: 18, number of references: 2</span>
        <pre><code><span class="lineno">   2 </span>
<span class="lineno">   3 </span>import java.util.Date
<span class="lineno">   4 </span>
<span class="lineno">   5 </span><span class="error">class SampleMetaData(val sampleId: String, val timestamp: Date) {</span>
<span class="lineno">   6 </span><span class="error"></span>
<span class="lineno">   7 </span><span class="error">    companion object</span>
<span class="lineno">   8 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-core/src/main/java/com/airthings/core/entities/instrument/Segment.kt:5:1</span><span class="message">Segment have a too high LCOM value: 0.9777777777777777. Number of methods: 5, number of properties: 18, number of references: 2</span>
        <pre><code><span class="lineno">   2 </span>
<span class="lineno">   3 </span>import java.util.Date
<span class="lineno">   4 </span>
<span class="lineno">   5 </span><span class="error">abstract class Segment(val segmentId: String, val startDate: Date) {</span>
<span class="lineno">   6 </span><span class="error">    companion object;</span>
<span class="lineno">   7 </span><span class="error"></span>
<span class="lineno">   8 </span><span class="error">    constructor(segmentId: String, startDate: Long) : this(segmentId, Date(startDate))</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-core/src/main/java/com/airthings/core/entities/segments/Segment.kt:6:1</span><span class="message">Segment have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 8, number of references: 0</span>
        <pre><code><span class="lineno">   3 </span>import java.util.SortedMap
<span class="lineno">   4 </span>import java.util.TreeMap
<span class="lineno">   5 </span>
<span class="lineno">   6 </span><span class="error">abstract class Segment {</span>
<span class="lineno">   7 </span><span class="error"></span>
<span class="lineno">   8 </span><span class="error">    abstract val id: String</span>
<span class="lineno">   9 </span><span class="error">    abstract val startTime: Long</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-core/src/main/java/com/airthings/core/entities/segments/WaveSegment.kt:6:1</span><span class="message">WaveSegment have a too high LCOM value: 0.9166666666666666. Number of methods: 4, number of properties: 6, number of references: 2</span>
        <pre><code><span class="lineno">   3 </span>import java.util.ArrayList
<span class="lineno">   4 </span>import java.util.TreeMap
<span class="lineno">   5 </span>
<span class="lineno">   6 </span><span class="error">open class WaveSegment(override val id: String, override val startTime: Long) : Segment() {</span>
<span class="lineno">   7 </span><span class="error"></span>
<span class="lineno">   8 </span><span class="error">    var latitude: Double = 0.toDouble()</span>
<span class="lineno">   9 </span><span class="error">    var longitude: Double = 0.toDouble()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-core/src/main/java/com/airthings/core/entities/user/AirthingsUser.kt:10:1</span><span class="message">AirthingsUser have a too high LCOM value: 0.8148148148148149. Number of methods: 6, number of properties: 9, number of references: 10</span>
        <pre><code><span class="lineno">   7 </span>    CONSUMER, BUSINESS
<span class="lineno">   8 </span>}
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">class AirthingsUser(val username: String, val userId: String, val intercomUserHash: String, val name: String) {</span>
<span class="lineno">  11 </span><span class="error"></span>
<span class="lineno">  12 </span><span class="error">    fun email() = username</span>
<span class="lineno">  13 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/androidTest/java/com/airthings/instrumentapi/DeviceHolderTest.kt:20:1</span><span class="message">MockIns have a too high LCOM value: 0.9444444444444444. Number of methods: 3, number of properties: 6, number of references: 1</span>
        <pre><code><span class="lineno">  17 </span>import org.mockito.Mockito
<span class="lineno">  18 </span>import org.mockito.Mockito.mock
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">internal class MockIns(private val sn: Long) : Instrument() {</span>
<span class="lineno">  21 </span><span class="error">    override val context: Context</span>
<span class="lineno">  22 </span><span class="error">        get() = mock(Context::class.java)</span>
<span class="lineno">  23 </span><span class="error">    override val serialNumber: Long</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/androidTest/java/com/airthings/instrumentapi/fwupdate/WavePlusFwUpgrade2Test.kt:342:1</span><span class="message">FirmwareImageProvider have a too high LCOM value: 0.8484848484848485. Number of methods: 3, number of properties: 11, number of references: 5</span>
        <pre><code><span class="lineno"> 339 </span>    }
<span class="lineno"> 340 </span>}
<span class="lineno"> 341 </span>
<span class="lineno"> 342 </span><span class="error">class FirmwareImageProvider(val context: Context) {</span>
<span class="lineno"> 343 </span><span class="error"></span>
<span class="lineno"> 344 </span><span class="error">    private val dir = FW_DIR</span>
<span class="lineno"> 345 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/androidTest/java/com/airthings/instrumentapi/scanner/ScannerErrorCode2Test.kt:74:1</span><span class="message">ScannerSpy have a too high LCOM value: 0.8. Number of methods: 5, number of properties: 5, number of references: 5</span>
        <pre><code><span class="lineno">  71 </span>    }
<span class="lineno">  72 </span>}
<span class="lineno">  73 </span>
<span class="lineno">  74 </span><span class="error">class ScannerSpy(scannerProvider: ScannerProvider) : InstrumentScanCallback {</span>
<span class="lineno">  75 </span><span class="error"></span>
<span class="lineno">  76 </span><span class="error">    private val client = ScannerClient(scannerProvider)</span>
<span class="lineno">  77 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/InstrumentInteraction.kt:8:1</span><span class="message">InstrumentInteraction have a too high LCOM value: 0.8. Number of methods: 5, number of properties: 3, number of references: 3</span>
        <pre><code><span class="lineno">   5 </span>
<span class="lineno">   6 </span>typealias InstrumentInteractionCallback = (err: Throwable?) -&gt; Unit
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">abstract class InstrumentInteraction(</span>
<span class="lineno">   9 </span><span class="error">    val context: Context,</span>
<span class="lineno">  10 </span><span class="error">    val serialNumber: String,</span>
<span class="lineno">  11 </span><span class="error">    val interactionCB: InteractionCallback2</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/InteractionClient.kt:14:1</span><span class="message">InteractionClient have a too high LCOM value: 0.8365384615384616. Number of methods: 13, number of properties: 8, number of references: 17</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.instrumentapi.interactioncontrol.InteractionController
<span class="lineno">  12 </span>import java.util.UUID
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">class InteractionClient(</span>
<span class="lineno">  15 </span><span class="error">    val context: Context,</span>
<span class="lineno">  16 </span><span class="error">    private val monitor: InteractionMonitor?,</span>
<span class="lineno">  17 </span><span class="error">    val interactionController: InteractionController</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/fwutil/FwImage.kt:3:1</span><span class="message">FwImage have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">   1 </span>package com.airthings.instrumentapi.fwutil
<span class="lineno">   2 </span>
<span class="lineno">   3 </span><span class="error">@Suppress(&quot;unused&quot;)</span>
<span class="lineno">   4 </span><span class="error">abstract class FwImage {</span>
<span class="lineno">   5 </span><span class="error">    abstract var imageName: String</span>
<span class="lineno">   6 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/fwutil/waveplus/WavePlusImageLoader.kt:23:1</span><span class="message">Header have a too high LCOM value: 1.0. Number of methods: 4, number of properties: 5, number of references: 0</span>
        <pre><code><span class="lineno">  20 </span>    val type: FirmwareImageType
<span class="lineno">  21 </span>)
<span class="lineno">  22 </span>
<span class="lineno">  23 </span><span class="error">open class Header(private val rawData: ByteArray) {</span>
<span class="lineno">  24 </span><span class="error">    var imageId = ByteArray(8)</span>
<span class="lineno">  25 </span><span class="error">    var imageInformation = ByteArray(4)</span>
<span class="lineno">  26 </span><span class="error">    private val imageSoftwareVersion = ByteArray(4)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/AtCommProtocol2.kt:22:1</span><span class="message">AtCommProtocol2 have a too high LCOM value: 0.8666666666666667. Number of methods: 15, number of properties: 2, number of references: 4</span>
        <pre><code><span class="lineno">  19 </span>
<span class="lineno">  20 </span>typealias CommProtocolProgress = (current: Int, total: Int) -&gt; Unit
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">internal abstract class AtCommProtocol2(</span>
<span class="lineno">  23 </span><span class="error">    val gattProfile: AtGattProfile,</span>
<span class="lineno">  24 </span><span class="error">    val gattClient: GattClient,</span>
<span class="lineno">  25 </span><span class="error">    onDisconnectListener: OnDisconnectListener</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/Instrument.kt:11:1</span><span class="message">Instrument have a too high LCOM value: 0.8775510204081632. Number of methods: 7, number of properties: 7, number of references: 6</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.utilities.Failure
<span class="lineno">   9 </span>import com.airthings.utilities.Try
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal abstract class Instrument : OnDisconnectListener {</span>
<span class="lineno">  12 </span><span class="error"></span>
<span class="lineno">  13 </span><span class="error">    protected abstract val context: Context</span>
<span class="lineno">  14 </span><span class="error">    abstract val serialNumber: Long</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/Instrument.kt:48:1</span><span class="message">NullInstrument have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  45 </span>    }
<span class="lineno">  46 </span>}
<span class="lineno">  47 </span>
<span class="lineno">  48 </span><span class="error">internal open class NullInstrument(</span>
<span class="lineno">  49 </span><span class="error">    override val context: Context,</span>
<span class="lineno">  50 </span><span class="error">    override val serialNumber: Long,</span>
<span class="lineno">  51 </span><span class="error">    final override val scanResult: ScanResult</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/conversion/SelfCheckSummaryParser.kt:14:1</span><span class="message">SelfCheckSummaryParser have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 4, number of references: 0</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.utilities.Success
<span class="lineno">  12 </span>import com.airthings.utilities.Try
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">internal class SelfCheckSummaryParser {</span>
<span class="lineno">  15 </span><span class="error"></span>
<span class="lineno">  16 </span><span class="error">    companion object {</span>
<span class="lineno">  17 </span><span class="error">        const val DEVICE_TYPE_UNKNOWN: Byte = 0</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/AtGattProfile.kt:26:1</span><span class="message">WavePlusGattProfile have a too high LCOM value: 0.9230769230769231. Number of methods: 2, number of properties: 13, number of references: 2</span>
        <pre><code><span class="lineno">  23 </span>    abstract var btSigDisFirmwareRevisionChar: BluetoothGattCharacteristic
<span class="lineno">  24 </span>}
<span class="lineno">  25 </span>
<span class="lineno">  26 </span><span class="error">internal open class WavePlusGattProfile(gattClient: GattClient) : AtGattProfile() {</span>
<span class="lineno">  27 </span><span class="error"></span>
<span class="lineno">  28 </span><span class="error">    override val airSensorServiceUUID = UUID.fromString(&quot;b42e1c08-ade7-11e4-89d3-123b93f75cba&quot;)</span>
<span class="lineno">  29 </span><span class="error">    override val asracpCharUUID = UUID.fromString(ASRACP_UUID)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:14:1</span><span class="message">GattClient have a too high LCOM value: 0.8214285714285714. Number of methods: 14, number of properties: 12, number of references: 30</span>
        <pre><code><span class="lineno">  11 </span>import java.util.concurrent.ConcurrentHashMap
<span class="lineno">  12 </span>import java.util.concurrent.ConcurrentMap
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">abstract class GattClient : BluetoothGattCallback(), GattTransactions2 {</span>
<span class="lineno">  15 </span><span class="error">    abstract fun connect(bluetoothDevice: BluetoothDevice, context: Context)</span>
<span class="lineno">  16 </span><span class="error">    abstract fun disconnect()</span>
<span class="lineno">  17 </span><span class="error">    abstract fun close()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/hub/HubInstrument.kt:11:1</span><span class="message">HubInstrument have a too high LCOM value: 0.8. Number of methods: 3, number of properties: 5, number of references: 3</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.utilities.Failure
<span class="lineno">   9 </span>import com.airthings.utilities.Try
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class HubInstrument(</span>
<span class="lineno">  12 </span><span class="error">    override val context: Context,</span>
<span class="lineno">  13 </span><span class="error">    override val serialNumber: Long,</span>
<span class="lineno">  14 </span><span class="error">    override val scanResult: ScanResult</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave2/Wave2Instrument.kt:52:1</span><span class="message">Wave2ConnectionSequence have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  49 </span>    }
<span class="lineno">  50 </span>}
<span class="lineno">  51 </span>
<span class="lineno">  52 </span><span class="error">@Suppress(&quot;ReturnCount&quot;) // Considered readable by the author, despite the high return count.</span>
<span class="lineno">  53 </span><span class="error">private class Wave2ConnectionSequence {</span>
<span class="lineno">  54 </span><span class="error"></span>
<span class="lineno">  55 </span><span class="error">    fun execute(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinBtSampleMaker.kt:11:1</span><span class="message">MerlinBtSampleMaker have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.instrumentapi.util.makeMerlinSampleId
<span class="lineno">   9 </span>import java.util.Date
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class MerlinBtSampleMaker {</span>
<span class="lineno">  12 </span><span class="error">    fun makeBtSample5Min(merlinDatasetInfo: MerlinDatasetInfo, block: MerlinHourBlock, index: Int): BtSample {</span>
<span class="lineno">  13 </span><span class="error">        val sensorRecords = ArrayList&lt;SensorRecord&gt;()</span>
<span class="lineno">  14 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinCurrentValueParser.kt:11:1</span><span class="message">MerlinCurrentValueParser have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   8 </span>import java.io.IOException
<span class="lineno">   9 </span>import java.util.HashMap
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class MerlinCurrentValueParser {</span>
<span class="lineno">  12 </span><span class="error">    companion object {</span>
<span class="lineno">  13 </span><span class="error">        private const val CURRENT_VALUES_ARRAY_SIZE = 20</span>
<span class="lineno">  14 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniGattProfile.kt:13:1</span><span class="message">WaveMiniGattProfile have a too high LCOM value: 0.9545454545454546. Number of methods: 2, number of properties: 11, number of references: 1</span>
        <pre><code><span class="lineno">  10 </span>import com.airthings.utilities.Try
<span class="lineno">  11 </span>import java.util.UUID
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">internal class WaveMiniGattProfile(val gattClient: GattClient) : AtGattProfile() {</span>
<span class="lineno">  14 </span><span class="error">    override val airSensorServiceUUID: UUID = UUID.fromString(DeviceDefines.WaveMiniServiceUUID)</span>
<span class="lineno">  15 </span><span class="error">    override val asracpCharUUID: UUID = UUID.fromString(&quot;b42e3ef4-ade7-11e4-89d3-123b93f75cba&quot;)</span>
<span class="lineno">  16 </span><span class="error">    override val asrCharUUID: UUID = UUID.fromString(&quot;b42e41c4-ade7-11e4-89d3-123b93f75cba&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniInstrument.kt:84:1</span><span class="message">WaveMiniConnectionSequence have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  81 </span>    }
<span class="lineno">  82 </span>}
<span class="lineno">  83 </span>
<span class="lineno">  84 </span><span class="error">private class WaveMiniConnectionSequence {</span>
<span class="lineno">  85 </span><span class="error"></span>
<span class="lineno">  86 </span><span class="error">    fun execute(</span>
<span class="lineno">  87 </span><span class="error">        bluetoothDevice: BluetoothDevice,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/BleFwVersionInterpreter.kt:8:1</span><span class="message">BleFwVersionInterpreter have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">   5 </span>import com.airthings.utilities.Success
<span class="lineno">   6 </span>import com.airthings.utilities.Try
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">class BleFwVersionInterpreter {</span>
<span class="lineno">   9 </span><span class="error"></span>
<span class="lineno">  10 </span><span class="error">    companion object {</span>
<span class="lineno">  11 </span><span class="error">        private const val MONTH_CODE_INDEX_VER2 = 2</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/CurrentValuesParser.kt:11:1</span><span class="message">CurrentValuesParser have a too high LCOM value: 1.0. Number of methods: 11, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   8 </span>import java.io.IOException
<span class="lineno">   9 </span>import java.util.HashMap
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal open class CurrentValuesParser {</span>
<span class="lineno">  12 </span><span class="error"></span>
<span class="lineno">  13 </span><span class="error">    companion object {</span>
<span class="lineno">  14 </span><span class="error">        private const val CURRENT_VALUES_ARRAY_SIZE = 20</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/DataSetInfo.kt:17:1</span><span class="message">ToDataSetInfo have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  14 </span>import kotlin.math.max
<span class="lineno">  15 </span>import kotlin.math.min
<span class="lineno">  16 </span>
<span class="lineno">  17 </span><span class="error">internal class ToDataSetInfo {</span>
<span class="lineno">  18 </span><span class="error">    fun invoke(params: ByteArray): Try&lt;DataSetInfo&gt; {</span>
<span class="lineno">  19 </span><span class="error">        val formatCheckOutcome = checkFormatAndRemoveHeader(params)</span>
<span class="lineno">  20 </span><span class="error">        if (formatCheckOutcome !is Success) return Failure((formatCheckOutcome as Failure).e)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/ReadSensorSampleSequence.kt:297:1</span><span class="message">AnalyticsReadSensorSamplesSequence have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno"> 294 </span>    return &quot;${this.map { it.toString() }}&quot;
<span class="lineno"> 295 </span>}
<span class="lineno"> 296 </span>
<span class="lineno"> 297 </span><span class="error">internal class AnalyticsReadSensorSamplesSequence(</span>
<span class="lineno"> 298 </span><span class="error">    gattClient: GattClient,</span>
<span class="lineno"> 299 </span><span class="error">    gattProfile: AtGattProfile,</span>
<span class="lineno"> 300 </span><span class="error">    fwVersions: HashMap&lt;FirmwareImageType, String&gt;,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/VersionComparator.kt:25:1</span><span class="message">VersionComparator have a too high LCOM value: 0.9285714285714286. Number of methods: 7, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno">  22 </span>private const val illegalArgumentMessage =
<span class="lineno">  23 </span>    &quot;The arguments must be formatted as either \&quot;$dateFormat\&quot; or \&quot;$semanticFormat\&quot;.&quot;
<span class="lineno">  24 </span>
<span class="lineno">  25 </span><span class="error">class VersionComparator(private val versionStringA: String) {</span>
<span class="lineno">  26 </span><span class="error"></span>
<span class="lineno">  27 </span><span class="error">    fun tryIsBefore(versionStringB: String): Try&lt;Boolean&gt; {</span>
<span class="lineno">  28 </span><span class="error">        val versionFactory = VersionFactory()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/WavePlusInstrument.kt:51:1</span><span class="message">WavePlus2ConnectionSequence have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  48 </span>    }
<span class="lineno">  49 </span>}
<span class="lineno">  50 </span>
<span class="lineno">  51 </span><span class="error">private class WavePlus2ConnectionSequence {</span>
<span class="lineno">  52 </span><span class="error"></span>
<span class="lineno">  53 </span><span class="error">    fun execute(</span>
<span class="lineno">  54 </span><span class="error">        bluetoothDevice: BluetoothDevice,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/oad/OadGattProfile.kt:13:1</span><span class="message">OadGattProfile have a too high LCOM value: 0.9444444444444444. Number of methods: 2, number of properties: 9, number of references: 1</span>
        <pre><code><span class="lineno">  10 </span>import com.airthings.utilities.Try
<span class="lineno">  11 </span>import java.util.UUID
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">/**</span>
<span class="lineno">  14 </span><span class="error"> * Ref:</span>
<span class="lineno">  15 </span><span class="error"> * http://dev.ti.com/tirex/content/simplelink_cc2640r2_sdk_1_40_00_45/docs/blestack/ble_user_guide/html/oad-ble-stack-3.x/oad_profile.html</span>
<span class="lineno">  16 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/readfw/ExternalFlashImageVersionReader.kt:45:1</span><span class="message">ExternalFlashImageVersionParser have a too high LCOM value: 0.875. Number of methods: 2, number of properties: 8, number of references: 2</span>
        <pre><code><span class="lineno">  42 </span>    }
<span class="lineno">  43 </span>}
<span class="lineno">  44 </span>
<span class="lineno">  45 </span><span class="error">internal class ExternalFlashImageVersionParser(private val bleFwVersion: String) {</span>
<span class="lineno">  46 </span><span class="error">    fun tryParse(rawData: ByteArray): Try&lt;String&gt; {</span>
<span class="lineno">  47 </span><span class="error">        return when {</span>
<span class="lineno">  48 </span><span class="error">            rawData.size != CORRECT_RESPONSE_SIZE -&gt; Failure(makeWrongSizeException(rawData))</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/ReadRFRegionCommandFactory.kt:11:1</span><span class="message">ReadRFRegionCommandFactory have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.utilities.Success
<span class="lineno">   9 </span>import com.airthings.utilities.Try
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class ReadRFRegionCommandFactory : CmdFactory&lt;Any?&gt;() {</span>
<span class="lineno">  12 </span><span class="error">    companion object {</span>
<span class="lineno">  13 </span><span class="error">        private val PASSTHROUGH_COMMAND = byteArrayOf(</span>
<span class="lineno">  14 </span><span class="error">            PassThrough.FLAG.code,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/SendUICommand.kt:48:1</span><span class="message">WavePlusUiCommand have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  45 </span>    abstract fun getByteArray(): ByteArray
<span class="lineno">  46 </span>}
<span class="lineno">  47 </span>
<span class="lineno">  48 </span><span class="error">class WavePlusUiCommand(operation: Operation) : UICommand(operation) {</span>
<span class="lineno">  49 </span><span class="error">    override fun getByteArray(): ByteArray {</span>
<span class="lineno">  50 </span><span class="error">        val commandParams = when (operation) {</span>
<span class="lineno">  51 </span><span class="error">            Operation.WELCOME -&gt; byteArrayOf(UI_COMMAND, 1)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/SendUICommand.kt:71:1</span><span class="message">WaveUiCommand have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  68 </span>    }
<span class="lineno">  69 </span>}
<span class="lineno">  70 </span>
<span class="lineno">  71 </span><span class="error">class WaveUiCommand(operation: Operation) : UICommand(operation) {</span>
<span class="lineno">  72 </span><span class="error">    override fun getByteArray(): ByteArray {</span>
<span class="lineno">  73 </span><span class="error">        val commandParams = when (operation) {</span>
<span class="lineno">  74 </span><span class="error">            Operation.WELCOME -&gt; byteArrayOf(248.toByte(), UI_COMMAND, 0, 1, 0)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/WavePlusFwUpgrade2.kt:29:1</span><span class="message">WavePlusFwUpgrade2 have a too high LCOM value: 0.8560606060606061. Number of methods: 12, number of properties: 11, number of references: 19</span>
        <pre><code><span class="lineno">  26 </span>import kotlinx.coroutines.delay
<span class="lineno">  27 </span>import kotlinx.coroutines.runBlocking
<span class="lineno">  28 </span>
<span class="lineno">  29 </span><span class="error">@Deprecated(&quot;Use com.airthings.instrumentapi.instrumentops.FwUpgradeCommand.kt instead.&quot;)</span>
<span class="lineno">  30 </span><span class="error">open class WavePlusFwUpgrade2(</span>
<span class="lineno">  31 </span><span class="error">    context: Context,</span>
<span class="lineno">  32 </span><span class="error">    val serialNumber: String,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/uisettings/griffin/WavePlusUiSettings.kt:117:1</span><span class="message">InitialFormatParser have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 14, number of references: 0</span>
        <pre><code><span class="lineno"> 114 </span>    }
<span class="lineno"> 115 </span>}
<span class="lineno"> 116 </span>
<span class="lineno"> 117 </span><span class="error">private class InitialFormatParser {</span>
<span class="lineno"> 118 </span><span class="error">    companion object {</span>
<span class="lineno"> 119 </span><span class="error">        private const val HUMIDITY_UPPER_YELLOW_LEVEL_POS = 7</span>
<span class="lineno"> 120 </span><span class="error">        private const val HUMIDITY_UPPER_RED_LEVEL_POS = 8</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/uisettings/griffin/WavePlusUiSettings.kt:226:1</span><span class="message">Version_1_4_0_FormatParser have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 14, number of references: 0</span>
        <pre><code><span class="lineno"> 223 </span>    }
<span class="lineno"> 224 </span>}
<span class="lineno"> 225 </span>
<span class="lineno"> 226 </span><span class="error">@Suppress(&quot;ClassNaming&quot;, &quot;ClassName&quot;)</span>
<span class="lineno"> 227 </span><span class="error">// The importance of clearly expressing the version takes precedence over the importance of naming standards.</span>
<span class="lineno"> 228 </span><span class="error">private class Version_1_4_0_FormatParser {</span>
<span class="lineno"> 229 </span><span class="error">    companion object {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/uisettings/griffin/WavePlusUiSettingsBuilder.kt:6:1</span><span class="message">WavePlusUiSettingsBuilder have a too high LCOM value: 0.8181818181818181. Number of methods: 11, number of properties: 10, number of references: 20</span>
        <pre><code><span class="lineno">   3 </span>import com.airthings.instrumentapi.instrumentops.uisettings.ColorThreshold
<span class="lineno">   4 </span>import com.airthings.instrumentapi.instrumentops.uisettings.LightSettingWavePlus
<span class="lineno">   5 </span>
<span class="lineno">   6 </span><span class="error">class WavePlusUiSettingsBuilder {</span>
<span class="lineno">   7 </span><span class="error">    private lateinit var humidityLevelsUpper: ColorThreshold</span>
<span class="lineno">   8 </span><span class="error">    private lateinit var humidityLevelsLower: ColorThreshold</span>
<span class="lineno">   9 </span><span class="error">    private lateinit var radonLevels: ColorThreshold</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/interactioncontrol/InteractionController.kt:10:1</span><span class="message">InteractionController have a too high LCOM value: 1.0. Number of methods: 3, number of properties: 4, number of references: 0</span>
        <pre><code><span class="lineno">   7 </span>import java.util.UUID
<span class="lineno">   8 </span>import java.util.concurrent.ConcurrentHashMap
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">abstract class InteractionController : InteractionCallback2 {</span>
<span class="lineno">  11 </span><span class="error"></span>
<span class="lineno">  12 </span><span class="error">    companion object {</span>
<span class="lineno">  13 </span><span class="error">        const val MAX_ACTIVE_INTERACTIONS: Int = 1</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/interactioncontrol/InteractionControllerImpl.kt:10:1</span><span class="message">InteractionControllerImpl have a too high LCOM value: 0.8125. Number of methods: 8, number of properties: 2, number of references: 3</span>
        <pre><code><span class="lineno">   7 </span>import java.util.UUID
<span class="lineno">   8 </span>import java.util.concurrent.ConcurrentHashMap
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">internal class InteractionControllerImpl(private val interactionProvider: InteractionProvider) :</span>
<span class="lineno">  11 </span><span class="error">    InteractionController() {</span>
<span class="lineno">  12 </span><span class="error"></span>
<span class="lineno">  13 </span><span class="error">    companion object {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/scanner/BleScanRecord.kt:73:1</span><span class="message">BleScanRecord have a too high LCOM value: 0.8133333333333334. Number of methods: 15, number of properties: 5, number of references: 14</span>
        <pre><code><span class="lineno">  70 </span>    }
<span class="lineno">  71 </span>}
<span class="lineno">  72 </span>
<span class="lineno">  73 </span><span class="error">/**</span>
<span class="lineno">  74 </span><span class="error"> * This is an almost identical class which mimics the internal Android SDK {@link ScanRecord}</span>
<span class="lineno">  75 </span><span class="error"> * class, but with the added benefit that it'll parse both advertisement and scan record data</span>
<span class="lineno">  76 </span><span class="error"> * packets and produce distinct records for each.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/scanner/BleScanner.kt:22:1</span><span class="message">ScannerObserver have a too high LCOM value: 0.8. Number of methods: 5, number of properties: 1, number of references: 1</span>
        <pre><code><span class="lineno">  19 </span>    internal abstract fun restartBluetoothAdapter(onCompletion: (Try&lt;Unit&gt;) -&gt; Unit)
<span class="lineno">  20 </span>}
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">internal abstract class ScannerObserver(val observerId: UUID) {</span>
<span class="lineno">  23 </span><span class="error">    abstract fun scanStarted()</span>
<span class="lineno">  24 </span><span class="error"></span>
<span class="lineno">  25 </span><span class="error">    abstract fun scanResultUpdated(resultDevice: Instrument)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/scanner/BleScannerImpl.kt:30:1</span><span class="message">BleScannerImpl have a too high LCOM value: 0.9191919191919192. Number of methods: 9, number of properties: 11, number of references: 8</span>
        <pre><code><span class="lineno">  27 </span>import com.airthings.utilities.Try
<span class="lineno">  28 </span>import java.util.UUID
<span class="lineno">  29 </span>
<span class="lineno">  30 </span><span class="error">internal class BleScannerImpl private constructor(val context: Context) : BleScanner() {</span>
<span class="lineno">  31 </span><span class="error">    private val scannerControlHandler = Handler(Looper.getMainLooper())</span>
<span class="lineno">  32 </span><span class="error">    private val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager</span>
<span class="lineno">  33 </span><span class="error">    private val bluetoothAdapter: BluetoothAdapter? by lazy(LazyThreadSafetyMode.NONE) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/conversion/SelfCheckParserTest.kt:14:1</span><span class="message">SelfCheckParserTest have a too high LCOM value: 0.8333333333333334. Number of methods: 6, number of properties: 4, number of references: 4</span>
        <pre><code><span class="lineno">  11 </span>import org.junit.Assert.assertTrue
<span class="lineno">  12 </span>import org.junit.Test
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">class SelfCheckParserTest {</span>
<span class="lineno">  15 </span><span class="error">    @Test</span>
<span class="lineno">  16 </span><span class="error">    fun create() {</span>
<span class="lineno">  17 </span><span class="error">        SelfCheckSummaryParser()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/gatt/GattClientImpl2Test.kt:14:1</span><span class="message">GattClientImpl2Test have a too high LCOM value: 0.8333333333333334. Number of methods: 6, number of properties: 3, number of references: 3</span>
        <pre><code><span class="lineno">  11 </span>import org.junit.Test
<span class="lineno">  12 </span>import org.mockito.Mockito.mock
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">class GattClientImpl2Test {</span>
<span class="lineno">  15 </span><span class="error"></span>
<span class="lineno">  16 </span><span class="error">    @Test</span>
<span class="lineno">  17 </span><span class="error">    fun create() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/wavemini/MerlinDatasetInfoTest.kt:11:1</span><span class="message">MerlinDatasetInfoTest have a too high LCOM value: 0.9285714285714286. Number of methods: 7, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno">   8 </span>private const val MILLIS_PER_HOUR = 3600_000L
<span class="lineno">   9 </span>private const val MILLIS_IN_FIVE_MINUTES = 5 * 60_000L
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">class MerlinDatasetInfoTest {</span>
<span class="lineno">  12 </span><span class="error"></span>
<span class="lineno">  13 </span><span class="error">    private val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd,hh:mm&quot;)</span>
<span class="lineno">  14 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/BtSampleValidatorTest.kt:12:1</span><span class="message">BtSampleValidatorTest have a too high LCOM value: 0.8148148148148149. Number of methods: 9, number of properties: 3, number of references: 5</span>
        <pre><code><span class="lineno">   9 </span>import org.junit.Test
<span class="lineno">  10 </span>import org.mockito.Mockito.mock
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class BtSampleValidatorTest : BadSampleReporter {</span>
<span class="lineno">  13 </span><span class="error"></span>
<span class="lineno">  14 </span><span class="error">    private var badSamples = listOf&lt;BtSample&gt;()</span>
<span class="lineno">  15 </span><span class="error">    private var sampleReporterWasCalled = false</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/oad/FakeGattClient.kt:19:1</span><span class="message">FakeGattClient have a too high LCOM value: 0.8823529411764706. Number of methods: 17, number of properties: 19, number of references: 38</span>
        <pre><code><span class="lineno">  16 </span>import org.mockito.Mockito.mock
<span class="lineno">  17 </span>import org.powermock.reflect.Whitebox
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">open class FakeGattClient : GattClient() {</span>
<span class="lineno">  20 </span><span class="error">    override fun connect(bluetoothDevice: BluetoothDevice, context: Context) {</span>
<span class="lineno">  21 </span><span class="error">        TODO(&quot;not implemented&quot;) // To change body of created functions use File | Settings | File Templates.</span>
<span class="lineno">  22 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/ReadRfRegionNonPassThroughCommandTest.kt:19:1</span><span class="message">ReadRfRegionNonPassThroughCommandTest have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  16 </span>import io.kotlintest.shouldBe
<span class="lineno">  17 </span>import io.kotlintest.specs.StringSpec
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">class ReadRfRegionNonPassThroughCommandTest : StringSpec() {</span>
<span class="lineno">  20 </span><span class="error">    companion object {</span>
<span class="lineno">  21 </span><span class="error">        private fun createMockGattInstances(): Pair&lt;GattClient, AtGattProfile&gt; =</span>
<span class="lineno">  22 </span><span class="error">            mock&lt;GattClient&gt; {} to mock {}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/ReadRfRegionPassThroughCommandTest.kt:18:1</span><span class="message">ReadRfRegionPassThroughCommandTest have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">  15 </span>import io.kotlintest.shouldBe
<span class="lineno">  16 </span>import io.kotlintest.specs.StringSpec
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">class ReadRfRegionPassThroughCommandTest : StringSpec() {</span>
<span class="lineno">  19 </span><span class="error">    companion object {</span>
<span class="lineno">  20 </span><span class="error">        private fun createMockGattInstances(): Pair&lt;GattClient, AtGattProfile&gt; =</span>
<span class="lineno">  21 </span><span class="error">            mock&lt;GattClient&gt; {} to mock {}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/WriteRfRegionNonPassThroughCommandTest.kt:18:1</span><span class="message">WriteRfRegionNonPassThroughCommandTest have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">  15 </span>import io.kotlintest.shouldBe
<span class="lineno">  16 </span>import io.kotlintest.specs.StringSpec
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">class WriteRfRegionNonPassThroughCommandTest : StringSpec() {</span>
<span class="lineno">  19 </span><span class="error">    companion object {</span>
<span class="lineno">  20 </span><span class="error">        internal fun asracp(resp: Try&lt;ByteArray&gt; = Success(byteArrayOf())): ASRACP {</span>
<span class="lineno">  21 </span><span class="error">            return mock {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrumentops/uisettings/WavePlusUiSettingsBuilderTest.kt:11:1</span><span class="message">WavePlusUiSettingsBuilderTest have a too high LCOM value: 0.8333333333333334. Number of methods: 6, number of properties: 2, number of references: 2</span>
        <pre><code><span class="lineno">   8 </span>import kotlin.test.assertTrue
<span class="lineno">   9 </span>import org.junit.Test
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">class WavePlusUiSettingsBuilderTest {</span>
<span class="lineno">  12 </span><span class="error"></span>
<span class="lineno">  13 </span><span class="error">    private val oldFormatExample = byteArrayOf(</span>
<span class="lineno">  14 </span><span class="error">        0x66, 0x0, 0x0, 0x0, 0x0, // ASRACP header and three hitchhiking bytes.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/scanner/ScannerClientTest.kt:13:1</span><span class="message">ScannerClientTest have a too high LCOM value: 0.8. Number of methods: 10, number of properties: 1, number of references: 2</span>
        <pre><code><span class="lineno">  10 </span>import org.junit.Test
<span class="lineno">  11 </span>import org.mockito.Mockito.mock
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class ScannerClientTest {</span>
<span class="lineno">  14 </span><span class="error"></span>
<span class="lineno">  15 </span><span class="error">    private var bleScanner: MockBleScanner? = null</span>
<span class="lineno">  16 </span><span class="error">    private var scannerClient: ScannerClient? = null</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/dialogsheet/BaseDialogSheetFragment.kt:21:1</span><span class="message">BaseDialogSheetFragment have a too high LCOM value: 0.9411764705882353. Number of methods: 17, number of properties: 7, number of references: 7</span>
        <pre><code><span class="lineno">  18 </span>import com.google.android.material.bottomsheet.BottomSheetDialog
<span class="lineno">  19 </span>import com.google.android.material.bottomsheet.BottomSheetDialogFragment
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">abstract class BaseDialogSheetFragment&lt;B : ViewDataBinding&gt; : BottomSheetDialogFragment(), StringIdentifiable {</span>
<span class="lineno">  22 </span><span class="error">    protected lateinit var binding: B</span>
<span class="lineno">  23 </span><span class="error">        private set</span>
<span class="lineno">  24 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/dialogsheet/DialogSheetFragment.kt:18:1</span><span class="message">DialogSheetFragment have a too high LCOM value: 0.8787878787878788. Number of methods: 11, number of properties: 3, number of references: 4</span>
        <pre><code><span class="lineno">  15 </span>import com.airthings.uicomponents.databinding.BottomSheetDialogBinding
<span class="lineno">  16 </span>import com.google.android.material.bottomsheet.BottomSheetDialog
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">@Suppress(&quot;TooManyFunctions&quot;)</span>
<span class="lineno">  19 </span><span class="error">abstract class DialogSheetFragment : BaseDialogSheetFragment&lt;BottomSheetDialogBinding&gt;(), TextWatcher {</span>
<span class="lineno">  20 </span><span class="error">    override val layoutResourceId = R.layout.bottom_sheet_dialog</span>
<span class="lineno">  21 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/format/ValueFormatter.kt:5:1</span><span class="message">ValueFormatter have a too high LCOM value: 0.8148148148148149. Number of methods: 9, number of properties: 3, number of references: 5</span>
        <pre><code><span class="lineno">   2 </span>
<span class="lineno">   3 </span>import java.util.Locale
<span class="lineno">   4 </span>
<span class="lineno">   5 </span><span class="error">class ValueFormatter {</span>
<span class="lineno">   6 </span><span class="error">    private var preferredUnit: PreferredUnit? = null</span>
<span class="lineno">   7 </span><span class="error"></span>
<span class="lineno">   8 </span><span class="error">    constructor(preferredUnit: PreferredUnit) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/ConnectivityStateImageView.kt:11:1</span><span class="message">ConnectivityStateImageView have a too high LCOM value: 1.0. Number of methods: 4, number of properties: 1, number of references: 0</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.utilities.IntIdentifiable
<span class="lineno">   9 </span>import com.airthings.utilities.Log
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">class ConnectivityStateImageView : AppCompatImageView {</span>
<span class="lineno">  12 </span><span class="error">    constructor(context: Context?) : super(context)</span>
<span class="lineno">  13 </span><span class="error">    constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs)</span>
<span class="lineno">  14 </span><span class="error">    constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/dashboarddevicelist/DashboardInstrumentListAdapter.kt:16:1</span><span class="message">DashboardInstrumentListAdapter have a too high LCOM value: 0.9428571428571428. Number of methods: 7, number of properties: 5, number of references: 2</span>
        <pre><code><span class="lineno">  13 </span>import com.airthings.utilities.Log
<span class="lineno">  14 </span>import java.util.ArrayList
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">internal class DashboardInstrumentListAdapter(context: Context, private val selectedListener: InstrumentSelectedListener?) : BaseAdapter() {</span>
<span class="lineno">  17 </span><span class="error"></span>
<span class="lineno">  18 </span><span class="error">    private var list = ArrayList&lt;Any&gt;()</span>
<span class="lineno">  19 </span><span class="error">    private val layoutInflater: LayoutInflater = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/dashboarddevicelist/DashboardInstrumentListAdapter.kt:126:5</span><span class="message">RoomItemViewHolder have a too high LCOM value: 0.8. Number of methods: 2, number of properties: 5, number of references: 2</span>
        <pre><code><span class="lineno"> 123 </span>        internal var locationText: TextView = v.findViewById(R.id.lblLocation)
<span class="lineno"> 124 </span>    }
<span class="lineno"> 125 </span>
<span class="lineno"> 126 </span>    <span class="error">private class RoomItemViewHolder internal constructor(v: View, internal val serialNumber: String) {</span>
<span class="lineno"> 127 </span><span class="error">        internal var roomText: TextView = v.findViewById(R.id.lblRoom)</span>
<span class="lineno"> 128 </span><span class="error">        private val airQualityImage: ImageView = v.findViewById(R.id.imgAirQuality)</span>
<span class="lineno"> 129 </span><span class="error">        internal var isSelectedImage: ImageView = v.findViewById(R.id.imgSelection)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/dashboarddevicelist/InstrumentListItem.kt:3:1</span><span class="message">InstrumentListItem have a too high LCOM value: 0.8. Number of methods: 3, number of properties: 5, number of references: 3</span>
        <pre><code><span class="lineno">   1 </span>package com.airthings.uicomponents.view.widget.dashboarddevicelist
<span class="lineno">   2 </span>
<span class="lineno">   3 </span><span class="error">class InstrumentListItem(</span>
<span class="lineno">   4 </span><span class="error">    val serialNumber: String,</span>
<span class="lineno">   5 </span><span class="error">    roomName: String,</span>
<span class="lineno">   6 </span><span class="error">    locationName: String,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/GraphView.kt:95:1</span><span class="message">GraphView have a too high LCOM value: 0.8555555555555556. Number of methods: 9, number of properties: 40, number of references: 52</span>
        <pre><code><span class="lineno">  92 </span>    }
<span class="lineno">  93 </span>}
<span class="lineno">  94 </span>
<span class="lineno">  95 </span><span class="error">class GraphView(context: Context, attrs: AttributeSet) : View(context, attrs) {</span>
<span class="lineno">  96 </span><span class="error">    private var adapter: GraphViewAdapter? = null</span>
<span class="lineno">  97 </span><span class="error">    private var timeHorizon = GraphDefines.H48_HORIZON</span>
<span class="lineno">  98 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/GraphViewAdapter.kt:13:1</span><span class="message">GraphViewAdapter have a too high LCOM value: 0.9285714285714286. Number of methods: 3, number of properties: 14, number of references: 3</span>
        <pre><code><span class="lineno">  10 </span>import java.util.TreeMap
<span class="lineno">  11 </span>import kotlin.math.roundToInt
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">abstract class GraphViewAdapter(</span>
<span class="lineno">  14 </span><span class="error">    val valueFormatter: ValueFormatter,</span>
<span class="lineno">  15 </span><span class="error">    var yellowLevel: Int,</span>
<span class="lineno">  16 </span><span class="error">    var redLevel: Int</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/GraphViewOverlay.kt:12:1</span><span class="message">GraphViewOverlay have a too high LCOM value: 1.0. Number of methods: 2, number of properties: 3, number of references: 0</span>
        <pre><code><span class="lineno">   9 </span>import android.widget.TextView
<span class="lineno">  10 </span>import com.airthings.uicomponents.R
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class GraphViewOverlay(context: Context, attributeSet: AttributeSet) : LinearLayout(context, attributeSet) {</span>
<span class="lineno">  13 </span><span class="error"></span>
<span class="lineno">  14 </span><span class="error">    private val textView: TextView</span>
<span class="lineno">  15 </span><span class="error">    private val imageView: ImageView</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/path/DataPathBuilder.kt:10:1</span><span class="message">DataPathBuilder have a too high LCOM value: 1.0. Number of methods: 1, number of properties: 2, number of references: 0</span>
        <pre><code><span class="lineno">   7 </span>import com.airthings.uicomponents.view.widget.graph.segment.SegmentDataBuilder
<span class="lineno">   8 </span>import java.util.ArrayList
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">class DataPathBuilder : PathBuilder() {</span>
<span class="lineno">  11 </span><span class="error"></span>
<span class="lineno">  12 </span><span class="error">    fun buildDataPaths(segmentDataBuilder: SegmentDataBuilder, graphTopPadding_px: Float): SparseArray&lt;ArrayList&lt;Path&gt;&gt; {</span>
<span class="lineno">  13 </span><span class="error">        val paths = SparseArray&lt;ArrayList&lt;Path&gt;&gt;()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusbanner/SyncStatusBanner.kt:15:1</span><span class="message">SyncStatusBanner have a too high LCOM value: 0.875. Number of methods: 4, number of properties: 4, number of references: 2</span>
        <pre><code><span class="lineno">  12 </span>import com.airthings.uicomponents.R
<span class="lineno">  13 </span>import com.airthings.uicomponents.UI_DELAY_DEFAULT
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">class SyncStatusBanner : ConstraintLayout {</span>
<span class="lineno">  16 </span><span class="error">    constructor(context: Context?) : super(context)</span>
<span class="lineno">  17 </span><span class="error">    constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs)</span>
<span class="lineno">  18 </span><span class="error">    constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : super(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:156:1</span><span class="message">IndicatorConfiguration have a too high LCOM value: 0.9166666666666666. Number of methods: 4, number of properties: 3, number of references: 1</span>
        <pre><code><span class="lineno"> 153 </span>    }
<span class="lineno"> 154 </span>}
<span class="lineno"> 155 </span>
<span class="lineno"> 156 </span><span class="error">abstract class IndicatorConfiguration(context: Context) {</span>
<span class="lineno"> 157 </span><span class="error">    val backgroundCirclePaint: Paint = Paint()</span>
<span class="lineno"> 158 </span><span class="error">    abstract val colorCirclePaint: Paint</span>
<span class="lineno"> 159 </span><span class="error">    abstract val iconResource: Int</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:268:1</span><span class="message">CloudDownloadConfiguration have a too high LCOM value: 0.875. Number of methods: 4, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno"> 265 </span>    }
<span class="lineno"> 266 </span>}
<span class="lineno"> 267 </span>
<span class="lineno"> 268 </span><span class="error">class CloudDownloadConfiguration(context: Context, dpToPx: DpToPx) : IndicatorConfiguration(context) {</span>
<span class="lineno"> 269 </span><span class="error">    override val colorCirclePaint: Paint = Paint()</span>
<span class="lineno"> 270 </span><span class="error"></span>
<span class="lineno"> 271 </span><span class="error">    init {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:294:1</span><span class="message">CloudUploadConfiguration have a too high LCOM value: 0.875. Number of methods: 4, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno"> 291 </span>    }
<span class="lineno"> 292 </span>}
<span class="lineno"> 293 </span>
<span class="lineno"> 294 </span><span class="error">class CloudUploadConfiguration(context: Context, dpToPx: DpToPx) : IndicatorConfiguration(context) {</span>
<span class="lineno"> 295 </span><span class="error">    override val colorCirclePaint: Paint = Paint()</span>
<span class="lineno"> 296 </span><span class="error"></span>
<span class="lineno"> 297 </span><span class="error">    init {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:320:1</span><span class="message">CloudOfflineConfiguration have a too high LCOM value: 0.875. Number of methods: 4, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno"> 317 </span>    }
<span class="lineno"> 318 </span>}
<span class="lineno"> 319 </span>
<span class="lineno"> 320 </span><span class="error">class CloudOfflineConfiguration(context: Context, dpToPx: DpToPx) : IndicatorConfiguration(context) {</span>
<span class="lineno"> 321 </span><span class="error">    override val colorCirclePaint: Paint = Paint()</span>
<span class="lineno"> 322 </span><span class="error"></span>
<span class="lineno"> 323 </span><span class="error">    init {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:473:1</span><span class="message">ConnectedConfiguration have a too high LCOM value: 0.875. Number of methods: 4, number of properties: 2, number of references: 1</span>
        <pre><code><span class="lineno"> 470 </span>    }
<span class="lineno"> 471 </span>}
<span class="lineno"> 472 </span>
<span class="lineno"> 473 </span><span class="error">open class ConnectedConfiguration(context: Context, dpToPx: DpToPx) : IndicatorConfiguration(context) {</span>
<span class="lineno"> 474 </span><span class="error">    final override val colorCirclePaint: Paint = Paint()</span>
<span class="lineno"> 475 </span><span class="error"></span>
<span class="lineno"> 476 </span><span class="error">    init {</span>
</code></pre>
      </li>
    </ul>
  </details>
  <details id="OpenClosedPrinciple" open="open">
    <summary class="rule-container"><span class="rule">OpenClosedPrinciple: 249 </span><span class="description">This rule reports use of switching on enums and classes, which may be a sign of violation the open closed principle.</span></summary>
    <ul>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/DeviceDetailViewModel.kt:35:13</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ScanStatus`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  32 </span>        scanResultAdapter.clear()
<span class="lineno">  33 </span>        Log.d(&quot;DeviceDetailViewModel&quot;, &quot;Scan requested&quot;)
<span class="lineno">  34 </span>        AirthingsDevice.scan(listOf(), isDebug = isDebug) { status, foundDevice, _ -&gt;
<span class="lineno">  35 </span>            <span class="error">when (status) {</span>
<span class="lineno">  36 </span><span class="error">                ScanStatus.DONE -&gt; _isScanning.value = false</span>
<span class="lineno">  37 </span><span class="error">                ScanStatus.ONGOING -&gt; {</span>
<span class="lineno">  38 </span><span class="error">                    _isScanning.value = true</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/ui/main/DeviceActionsViewModel.kt:118:27</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Wave1Device`, `MerlinDevice`, `GriffinDevice`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 115 </span>    fun setCurrentDevice(serial: String) {
<span class="lineno"> 116 </span>        val device = AirthingsDevice.getDevice(serial) ?: error(&quot;Device not found&quot;)
<span class="lineno"> 117 </span>        _currentDevice.value = device
<span class="lineno"> 118 </span>        firmwareBundles = <span class="error">when (device) {</span>
<span class="lineno"> 119 </span><span class="error">            is GriffinDevice -&gt; FirmwareSource.griffinFirmware</span>
<span class="lineno"> 120 </span><span class="error">            is MerlinDevice -&gt; FirmwareSource.merlinFirmware</span>
<span class="lineno"> 121 </span><span class="error">            is Wave1Device -&gt; FirmwareSource.wave1Firmware</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/ui/main/DeviceActionsViewModel.kt:153:30</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `MerlinUiSettings`, `WaveUiSettings`, `WavePlusUiSettings`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 150 </span>                log(&quot;readUiSettings&quot; to err.message!!)
<span class="lineno"> 151 </span>                fn.invoke(Failure(IOException(err.message)))
<span class="lineno"> 152 </span>            } else {
<span class="lineno"> 153 </span>                val result = <span class="error">when (settings) {</span>
<span class="lineno"> 154 </span><span class="error">                    is WavePlusUiSettings -&gt; listOf(</span>
<span class="lineno"> 155 </span><span class="error">                        &quot;&lt;b&gt;humidityLevelsUpper&lt;/b&gt;&quot; to settings.humidityLevelsUpper.describe(),</span>
<span class="lineno"> 156 </span><span class="error">                        &quot;&lt;b&gt;humidityLevelsLower&lt;/b&gt;&quot; to settings.humidityLevelsLower.describe(),</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/ui/main/DeviceActionsViewModel.kt:199:17</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 196 </span>        currentDevice.value?.let {
<span class="lineno"> 197 </span>            _wrSettingsButtonEnabled.value = false
<span class="lineno"> 198 </span>            it.writeUiSettings(uiSettings) { result -&gt;
<span class="lineno"> 199 </span>                <span class="error">when (result) {</span>
<span class="lineno"> 200 </span><span class="error">                    is Failure -&gt; log(&quot;wrUISettings&quot; to (result.e.message ?: &quot;Failed&quot;))</span>
<span class="lineno"> 201 </span><span class="error">                    is Success -&gt; log(&quot;wrUISettings&quot; to &quot;Success&quot;)</span>
<span class="lineno"> 202 </span><span class="error">                }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/ui/main/DeviceActionsViewModel.kt:318:32</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 315 </span>        _fwButtonEnabled.value = false
<span class="lineno"> 316 </span>        device.getFirmwareVersion { result -&gt;
<span class="lineno"> 317 </span>            _fwButtonEnabled.value = true
<span class="lineno"> 318 </span>            val resultString = <span class="error">when (result) {</span>
<span class="lineno"> 319 </span><span class="error">                is Success -&gt; result.value.map { &quot;${it.key.name}:${it.value}&quot; }.joinToString()</span>
<span class="lineno"> 320 </span><span class="error">                is Failure -&gt; result.e.message!!</span>
<span class="lineno"> 321 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/ui/main/DeviceActionsViewModel.kt:353:17</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `GriffinDevice`, `MerlinDevice`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 350 </span>        uiDispatch {
<span class="lineno"> 351 </span>            _readRfRegionButtonEnabled.value = true
<span class="lineno"> 352 </span>            val result: String = try {
<span class="lineno"> 353 </span>                <span class="error">when (device) {</span>
<span class="lineno"> 354 </span><span class="error">                    is MerlinDevice -&gt; device.readRfRegion().name</span>
<span class="lineno"> 355 </span><span class="error">                    is GriffinDevice -&gt; device.readRfRegion().name</span>
<span class="lineno"> 356 </span><span class="error">                    else -&gt; &quot;Device doesn't support Rf region&quot;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/ui/main/DeviceActionsViewModel.kt:371:17</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `GriffinDevice`, `MerlinDevice`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 368 </span>        uiDispatch {
<span class="lineno"> 369 </span>            _writeRfRegionButtonEnabled.value = false
<span class="lineno"> 370 </span>            val result = try {
<span class="lineno"> 371 </span>                <span class="error">when (device) {</span>
<span class="lineno"> 372 </span><span class="error">                    is MerlinDevice -&gt; device.writeRfRegion(region)</span>
<span class="lineno"> 373 </span><span class="error">                    is GriffinDevice -&gt; device.writeRfRegion(region)</span>
<span class="lineno"> 374 </span><span class="error">                    else -&gt; error(&quot;Device does not support RF region commands&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/ui/main/LimitedDeviceActionsViewModel.kt:140:21</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 137 </span>        suspendCoroutine { cont -&gt;
<span class="lineno"> 138 </span>            device.getFirmwareVersion { result -&gt;
<span class="lineno"> 139 </span>                cont.resumeWith(
<span class="lineno"> 140 </span>                    <span class="error">when (result) {</span>
<span class="lineno"> 141 </span><span class="error">                        is Failure -&gt; Result.failure(result.e)</span>
<span class="lineno"> 142 </span><span class="error">                        is Success -&gt; Result.success(result.value)</span>
<span class="lineno"> 143 </span><span class="error">                    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/uisettings/GriffinUiSettingsComposerFragment.kt:181:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `AlarmSetting`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 178 </span>    }
<span class="lineno"> 179 </span>
<span class="lineno"> 180 </span>    private fun AlarmSetting.toButtonId(): Int {
<span class="lineno"> 181 </span>        return <span class="error">when (this) {</span>
<span class="lineno"> 182 </span><span class="error">            AlarmSetting.ENABLED -&gt; alarm_on_radioButton.id</span>
<span class="lineno"> 183 </span><span class="error">            AlarmSetting.DISABLED -&gt; alarm_off_radioButton.id</span>
<span class="lineno"> 184 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/uisettings/GriffinUiSettingsComposerFragment.kt:188:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `LightSettingWavePlus`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 185 </span>    }
<span class="lineno"> 186 </span>
<span class="lineno"> 187 </span>    private fun LightSettingWavePlus.toButtonId(): Int {
<span class="lineno"> 188 </span>        return <span class="error">when (this) {</span>
<span class="lineno"> 189 </span><span class="error">            LightSettingWavePlus.LIGHT_LOW -&gt; light_low_radioButton.id</span>
<span class="lineno"> 190 </span><span class="error">            LightSettingWavePlus.LIGHT_MEDIUM -&gt; light_medium_radioButton.id</span>
<span class="lineno"> 191 </span><span class="error">            LightSettingWavePlus.LIGHT_HIGH -&gt; light_high_radioButton.id</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/uisettings/GriffinUiSettingsComposerFragment.kt:197:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `AliveIndicatorSetting`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 194 </span>    }
<span class="lineno"> 195 </span>
<span class="lineno"> 196 </span>    private fun AliveIndicatorSetting.toButtonId(): Int {
<span class="lineno"> 197 </span>        return <span class="error">when (this) {</span>
<span class="lineno"> 198 </span><span class="error">            AliveIndicatorSetting.ENABLED -&gt; indicator_enabled_radioButton.id</span>
<span class="lineno"> 199 </span><span class="error">            AliveIndicatorSetting.ENABLED_IF_BATTERY_LEVEL_LOW -&gt; indicator_on_condition_radioButton.id</span>
<span class="lineno"> 200 </span><span class="error">            AliveIndicatorSetting.DISABLED -&gt; indicator_disabled_radioButton.id</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/uisettings/GriffinUiSettingsComposerFragment.kt:205:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SoundSetting`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 202 </span>    }
<span class="lineno"> 203 </span>
<span class="lineno"> 204 </span>    private fun SoundSetting.toButtonId(): Int {
<span class="lineno"> 205 </span>        return <span class="error">when (this) {</span>
<span class="lineno"> 206 </span><span class="error">            SoundSetting.SOUND_OFF -&gt; sound_off_radioButton.id</span>
<span class="lineno"> 207 </span><span class="error">            SoundSetting.SOUND_LOW -&gt; sound_low_radioButton.id</span>
<span class="lineno"> 208 </span><span class="error">            SoundSetting.SOUND_MEDIUM -&gt; sound_medium_radioButton.id</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/uisettings/GriffinUiSettingsComposerFragment.kt:215:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `B2CSetting`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 212 </span>    }
<span class="lineno"> 213 </span>
<span class="lineno"> 214 </span>    private fun B2CSetting.toButtonId(): Int {
<span class="lineno"> 215 </span>        return <span class="error">when (this) {</span>
<span class="lineno"> 216 </span><span class="error">            B2CSetting.ENABLED -&gt; b2c_on_radioButton.id</span>
<span class="lineno"> 217 </span><span class="error">            B2CSetting.DISABLED -&gt; b2c_off_radioButton.id</span>
<span class="lineno"> 218 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/uisettings/MerlinUiSettingsComposerFragment.kt:48:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `WaveSetting`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  45 </span>    }
<span class="lineno">  46 </span>
<span class="lineno">  47 </span>    private fun WaveSetting.toButtonId(): Int {
<span class="lineno">  48 </span>        return <span class="error">when (this) {</span>
<span class="lineno">  49 </span><span class="error">            WaveSetting.ENABLED -&gt; wave_on_radioButton.id</span>
<span class="lineno">  50 </span><span class="error">            WaveSetting.DISABLED -&gt; wave_off_radioButton.id</span>
<span class="lineno">  51 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/uisettings/MerlinUiSettingsComposerFragment.kt:55:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `B2CSetting`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  52 </span>    }
<span class="lineno">  53 </span>
<span class="lineno">  54 </span>    private fun B2CSetting.toButtonId(): Int {
<span class="lineno">  55 </span>        return <span class="error">when (this) {</span>
<span class="lineno">  56 </span><span class="error">            B2CSetting.ENABLED -&gt; b2c_on_radioButton.id</span>
<span class="lineno">  57 </span><span class="error">            B2CSetting.DISABLED -&gt; b2c_off_radioButton.id</span>
<span class="lineno">  58 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/activities/BaseActivity.kt:266:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `BannerState`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 263 </span>
<span class="lineno"> 264 </span>    @Suppress(&quot;ComplexMethod&quot;)
<span class="lineno"> 265 </span>    protected fun BannerState.toBannerMode(): BannerMode {
<span class="lineno"> 266 </span>        return <span class="error">when (this) {</span>
<span class="lineno"> 267 </span><span class="error">            BannerState.OFFLINE -&gt; AlertMode(getString(R.string.connectivity_status_no_internet))</span>
<span class="lineno"> 268 </span><span class="error">            BannerState.BLE_OFF -&gt; AlertWithActionMode(</span>
<span class="lineno"> 269 </span><span class="error">                getString(R.string.connectivity_status_no_ble),</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/activities/about/AboutMenuFragment.kt:63:25</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `StateAppError`, `ApiAppError`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  60 </span>        val progressDialog = ProgressDialog(requireContext())
<span class="lineno">  61 </span>        progressDialog.setTitle(R.string.about_log_update_please_wait)
<span class="lineno">  62 </span>        progressDialog.show()
<span class="lineno">  63 </span>        val toastText = <span class="error">when (val error = viewModel.uploadDiagnosticLog().appError) {</span>
<span class="lineno">  64 </span><span class="error">            is ApiAppError -&gt; getString(</span>
<span class="lineno">  65 </span><span class="error">                R.string.about_menu_log_upload_failed,</span>
<span class="lineno">  66 </span><span class="error">                error.errorCode.toString()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/MeasurementUnit.kt:21:44</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `MeasurementUnit`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  18 </span>        fun fromDesc(desc: String) = values().find { it.desc == desc } ?: error(&quot;$desc not found&quot;)
<span class="lineno">  19 </span>    }
<span class="lineno">  20 </span>
<span class="lineno">  21 </span>    fun toPreferredUnit(): PreferredUnit = <span class="error">when (this) {</span>
<span class="lineno">  22 </span><span class="error">        METRIC -&gt; PreferredUnit.METRIC</span>
<span class="lineno">  23 </span><span class="error">        US -&gt; PreferredUnit.US</span>
<span class="lineno">  24 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/data/UserDeviceData.kt:108:20</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Model?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 105 </span>        fun fromIndex(index: Int?) = values().find { it.index == index } ?: error(&quot;Invalid index $index&quot;)
<span class="lineno"> 106 </span>
<span class="lineno"> 107 </span>        fun fromSerial(serial: String): UserDeviceType {
<span class="lineno"> 108 </span>            return <span class="error">when (AirthingsDevice.Model.fromSerial(serial)) {</span>
<span class="lineno"> 109 </span><span class="error">                AirthingsDevice.Model.Wave1 -&gt; WAVE_CLASSIC_GEN_1</span>
<span class="lineno"> 110 </span><span class="error">                AirthingsDevice.Model.Wave2 -&gt; WAVE_CLASSIC_GEN_2</span>
<span class="lineno"> 111 </span><span class="error">                AirthingsDevice.Model.WavePlus -&gt; WAVE_PLUS_GEN_1</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/Assessor.kt:14:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SensorType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  11 </span>    }
<span class="lineno">  12 </span>
<span class="lineno">  13 </span>    fun getAssessment(sensorType: SensorType, sensorValue: Float?): Assessment&lt;Float&gt; {
<span class="lineno">  14 </span>        return <span class="error">when (sensorType) {</span>
<span class="lineno">  15 </span><span class="error">            SensorType.RADON_24H_AVG -&gt; Assessment(getRadonAssessment(sensorValue), sensorValue)</span>
<span class="lineno">  16 </span><span class="error">            SensorType.TEMPERATURE -&gt; Assessment(getTemperatureAssessment(sensorValue), sensorValue)</span>
<span class="lineno">  17 </span><span class="error">            SensorType.HUMIDITY -&gt; Assessment(getHumidityAssessment(sensorValue), sensorValue)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/ConnectedUserDevice.kt:133:25</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 130 </span>            val firmwareVersions = suspendCoroutine&lt;Map&lt;FirmwareImageType, String&gt;&gt; { cont -&gt;
<span class="lineno"> 131 </span>                btDevice.getFirmwareVersion { result -&gt;
<span class="lineno"> 132 </span>                    cont.resumeWith(
<span class="lineno"> 133 </span>                        <span class="error">when (result) {</span>
<span class="lineno"> 134 </span><span class="error">                            is Failure -&gt; Result.failure(result.e)</span>
<span class="lineno"> 135 </span><span class="error">                            is Success -&gt; Result.success(result.value)</span>
<span class="lineno"> 136 </span><span class="error">                        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/ConnectedUserDevice.kt:681:68</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SensorType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 678 </span>    // internal extensions
<span class="lineno"> 679 </span>
<span class="lineno"> 680 </span>    @Suppress(&quot;ComplexMethod&quot;)
<span class="lineno"> 681 </span>    private fun RecordData.getSensor(sensor: SensorType): Float? = <span class="error">when (sensor) {</span>
<span class="lineno"> 682 </span><span class="error">        SensorType.RADON_24H_AVG -&gt; this.radonShortTermAvg?.toFloat()</span>
<span class="lineno"> 683 </span><span class="error">        SensorType.TEMPERATURE -&gt; this.temp</span>
<span class="lineno"> 684 </span><span class="error">        SensorType.HUMIDITY -&gt; this.humidity</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/ConnectivityStatusMediator.kt:92:65</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `UserDeviceSignalQuality?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  89 </span>        this.value = status
<span class="lineno">  90 </span>    }
<span class="lineno">  91 </span>
<span class="lineno">  92 </span>    private fun UserDeviceSignalQuality?.connectivityStatus() = <span class="error">when (this) {</span>
<span class="lineno">  93 </span><span class="error">        UserDeviceSignalQuality.POOR -&gt; ConnectedUserDevice.ConnectivityStatus.HUB_SIGNAL_POOR</span>
<span class="lineno">  94 </span><span class="error">        UserDeviceSignalQuality.FAIR -&gt; ConnectedUserDevice.ConnectivityStatus.HUB_SIGNAL_FAIR</span>
<span class="lineno">  95 </span><span class="error">        UserDeviceSignalQuality.GOOD -&gt; ConnectedUserDevice.ConnectivityStatus.HUB_SIGNAL_GOOD</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/WaveMiniUserDevice.kt:77:17</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  74 </span>            )
<span class="lineno">  75 </span>        ) { result -&gt;
<span class="lineno">  76 </span>            cont.resumeWith(
<span class="lineno">  77 </span>                <span class="error">when (result) {</span>
<span class="lineno">  78 </span><span class="error">                    is Failure -&gt; Result.failure(result.e)</span>
<span class="lineno">  79 </span><span class="error">                    is Success -&gt; Result.success(Unit)</span>
<span class="lineno">  80 </span><span class="error">                }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/WavePlusUserDevice.kt:73:17</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  70 </span>            )
<span class="lineno">  71 </span>        ) { result -&gt;
<span class="lineno">  72 </span>            cont.resumeWith(
<span class="lineno">  73 </span>                <span class="error">when (result) {</span>
<span class="lineno">  74 </span><span class="error">                    is Failure -&gt; Result.failure(result.e)</span>
<span class="lineno">  75 </span><span class="error">                    is Success -&gt; Result.success(Unit)</span>
<span class="lineno">  76 </span><span class="error">                }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/CustomerSupportRepository.kt:42:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `HubUserDevice`, `WaveMiniUserDevice`, `WavePlusUserDevice`, `WaveClassicGen2UserDevice`, `WaveClassicGen1UserDevice`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  39 </span>        )
<span class="lineno">  40 </span>
<span class="lineno">  41 </span>        userDevices.forEach { device -&gt;
<span class="lineno">  42 </span>            <span class="error">when (device) {</span>
<span class="lineno">  43 </span><span class="error">                is WaveClassicGen1UserDevice -&gt; attributes[CustomerSupportProduct.ATTR_PRODUCT_WAVE1.key] = true</span>
<span class="lineno">  44 </span><span class="error">                is WaveClassicGen2UserDevice -&gt; attributes[CustomerSupportProduct.ATTR_PRODUCT_WAVE2.key] = true</span>
<span class="lineno">  45 </span><span class="error">                is WavePlusUserDevice -&gt; attributes[CustomerSupportProduct.ATTR_PRODUCT_WAVE_PLUS.key] = true</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/DeviceRepository.kt:643:13</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ScanStatus`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 640 </span>        bluetoothServiceRepository.scanDevices(devicesToDiscover) { status, _, scannerError -&gt;
<span class="lineno"> 641 </span>            Log.d(TAG, &quot;Scan status $status&quot;)
<span class="lineno"> 642 </span>
<span class="lineno"> 643 </span>            <span class="error">when (status) {</span>
<span class="lineno"> 644 </span><span class="error">                ScanStatus.DONE -&gt; cont.resumeWith(Result.success(Unit))</span>
<span class="lineno"> 645 </span><span class="error">                ScanStatus.ERROR -&gt; cont.resumeWith(</span>
<span class="lineno"> 646 </span><span class="error">                    Result.failure(scannerError ?: error(&quot;ERROR mode with null scannerError&quot;))</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/bluetooth/BluetoothScannerService.kt:35:13</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ScanStatus`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  32 </span>
<span class="lineno">  33 </span>        internalScanListener = { status, foundDevice, err -&gt;
<span class="lineno">  34 </span>            externalListeners.forEach { it.invoke(status, foundDevice, err) }
<span class="lineno">  35 </span>            <span class="error">when (status) {</span>
<span class="lineno">  36 </span><span class="error">                ScanStatus.ONGOING -&gt; foundDevice?.let { device -&gt;</span>
<span class="lineno">  37 </span><span class="error">                    cache.value?.let { deviceCache -&gt;</span>
<span class="lineno">  38 </span><span class="error">                        val deviceLiveData =</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/addnewdevice/PairingCompletedViewModel.kt:59:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `WavePlusUserDevice`, `WaveClassicGen2UserDevice`, `WaveClassicGen1UserDevice`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  56 </span>    }
<span class="lineno">  57 </span>
<span class="lineno">  58 </span>    private fun typeToImageResource(userDevice: ConnectedUserDevice): Int {
<span class="lineno">  59 </span>        return <span class="error">when (userDevice) {</span>
<span class="lineno">  60 </span><span class="error">            is WaveClassicGen1UserDevice -&gt; R.drawable.ic_wave</span>
<span class="lineno">  61 </span><span class="error">            is WaveClassicGen2UserDevice -&gt; R.drawable.ic_wave</span>
<span class="lineno">  62 </span><span class="error">            is WavePlusUserDevice -&gt; R.drawable.ic_wave_plus</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/confirmaccount/ConfirmAccountActivity.kt:178:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `StateAppError`, `ApiAppError`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 175 </span>    }
<span class="lineno"> 176 </span>
<span class="lineno"> 177 </span>    private fun handleCodeError(error: AppError) {
<span class="lineno"> 178 </span>        <span class="error">when (error) {</span>
<span class="lineno"> 179 </span><span class="error">            is ApiAppError -&gt; when (error.errorCode) {</span>
<span class="lineno"> 180 </span><span class="error">                ApiAppError.Companion.ResendConfCode.ALREADY_CONFIRMED -&gt; showDialogMessage(</span>
<span class="lineno"> 181 </span><span class="error">                    getString(R.string.confirm_code_already_confirmed_title),</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/confirmaccount/ConfirmAccountActivity.kt:201:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `StateAppError`, `ApiAppError`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 198 </span>    }
<span class="lineno"> 199 </span>
<span class="lineno"> 200 </span>    private fun handleConfirmError(error: AppError) {
<span class="lineno"> 201 </span>        <span class="error">when (error) {</span>
<span class="lineno"> 202 </span><span class="error">            is ApiAppError -&gt; {</span>
<span class="lineno"> 203 </span><span class="error">                when (error.errorCode) {</span>
<span class="lineno"> 204 </span><span class="error">                    ApiAppError.Companion.ConfirmAccount.ALREADY_CONFIRMED,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/confirmaccount/ConfirmAccountActivity.kt:239:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `StateAppError`, `ApiAppError`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 236 </span>    }
<span class="lineno"> 237 </span>
<span class="lineno"> 238 </span>    private fun handleLoginError(error: AppError) {
<span class="lineno"> 239 </span>        <span class="error">when (error) {</span>
<span class="lineno"> 240 </span><span class="error">            is ApiAppError -&gt; when (error.errorCode) {</span>
<span class="lineno"> 241 </span><span class="error">                ApiAppError.Companion.Login.INVALID_EMAIL_OR_PASSWORD -&gt; showDialogMessage(</span>
<span class="lineno"> 242 </span><span class="error">                    getString(R.string.log_in_incorrect_credentials_title),</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/controlsync/SyncControlDialogFragment.kt:198:79</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ConnectivityStatus`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 195 </span>    } ?: getString(R.string.placeholder)
<span class="lineno"> 196 </span>
<span class="lineno"> 197 </span>    @Suppress(&quot;ComplexMethod&quot;) // Detekt, this is a really simple method...
<span class="lineno"> 198 </span>    private fun ConnectivityStatus.toConfigurationType(): ConfigurationType = <span class="error">when (this) {</span>
<span class="lineno"> 199 </span><span class="error">        ConnectivityStatus.BLE_CONNECTING -&gt; ConfigurationType.SCANNING_AND_CONNECTION</span>
<span class="lineno"> 200 </span><span class="error">        ConnectivityStatus.BLE_CONNECTED -&gt; ConfigurationType.CONNECTED</span>
<span class="lineno"> 201 </span><span class="error">        ConnectivityStatus.BLE_DISABLED -&gt; ConfigurationType.BLUETOOTH_DISABLED</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/controlsync/SyncControlDialogFragment.kt:214:64</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ConnectivityStatus`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 211 </span>        ConnectivityStatus.BLE_AVAILABLE -&gt; ConfigurationType.IDLE
<span class="lineno"> 212 </span>    }
<span class="lineno"> 213 </span>
<span class="lineno"> 214 </span>    private fun ConnectivityStatus.toBleStatusText(): String = <span class="error">when (this) {</span>
<span class="lineno"> 215 </span><span class="error">        ConnectivityStatus.BLE_UNAVAILABLE -&gt; getString(R.string.device_summary_not_in_range)</span>
<span class="lineno"> 216 </span><span class="error">        ConnectivityStatus.BLE_SCANNING -&gt; getString(R.string.device_summary_scanning)</span>
<span class="lineno"> 217 </span><span class="error">        ConnectivityStatus.BLE_AVAILABLE -&gt; getString(R.string.device_summary_available)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/controlsync/SyncControlDialogFragment.kt:229:79</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SyncIndicatorState`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 226 </span>        ConnectivityStatus.HUB_SIGNAL_EXCELLENT -&gt; getString(R.string.device_summary_smart_link)
<span class="lineno"> 227 </span>    }
<span class="lineno"> 228 </span>
<span class="lineno"> 229 </span>    private fun SyncIndicatorState.toConfigurationType(): ConfigurationType = <span class="error">when (this) {</span>
<span class="lineno"> 230 </span><span class="error">        SyncIndicatorState.IDLE -&gt; ConfigurationType.IDLE</span>
<span class="lineno"> 231 </span><span class="error">        SyncIndicatorState.CLOUD_DOWNLOAD -&gt; ConfigurationType.DOWNLOADING</span>
<span class="lineno"> 232 </span><span class="error">        SyncIndicatorState.BLE_READOUT -&gt; ConfigurationType.READING_FROM_INSTRUMENT</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/controlsync/SyncControlDialogFragment.kt:238:65</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SyncIndicatorState`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 235 </span>        SyncIndicatorState.BATTERY_ALERT -&gt; ConfigurationType.BATTERY_ALERT
<span class="lineno"> 236 </span>    }
<span class="lineno"> 237 </span>
<span class="lineno"> 238 </span>    private fun SyncIndicatorState.toSyncStatusText(): String = <span class="error">when (this) {</span>
<span class="lineno"> 239 </span><span class="error">        SyncIndicatorState.IDLE -&gt; formulateLastUpdatedText()</span>
<span class="lineno"> 240 </span><span class="error">        SyncIndicatorState.CLOUD_DOWNLOAD -&gt; getString(R.string.sync_status_cloud_download)</span>
<span class="lineno"> 241 </span><span class="error">        SyncIndicatorState.BLE_READOUT -&gt; getString(R.string.sync_status_ble_download)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/controlsync/SyncControlViewModel.kt:101:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SyncStatus?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  98 </span>        internetIsAvailable: Boolean?
<span class="lineno">  99 </span>    ): SyncControlViewModel.SyncIndicatorState {
<span class="lineno"> 100 </span>
<span class="lineno"> 101 </span>        return <span class="error">when (syncState) {</span>
<span class="lineno"> 102 </span><span class="error">            ConnectedUserDevice.SyncStatus.CLOUD_DOWNLOAD -&gt; SyncControlViewModel.SyncIndicatorState.CLOUD_DOWNLOAD</span>
<span class="lineno"> 103 </span><span class="error">            ConnectedUserDevice.SyncStatus.CLOUD_UPLOAD -&gt; SyncControlViewModel.SyncIndicatorState.CLOUD_UPLOAD</span>
<span class="lineno"> 104 </span><span class="error">            ConnectedUserDevice.SyncStatus.BLE_DOWNLOAD -&gt; SyncControlViewModel.SyncIndicatorState.BLE_READOUT</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/createaccount/CreateAccountActivity.kt:84:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `StateAppError`, `ApiAppError`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  81 </span>    }
<span class="lineno">  82 </span>
<span class="lineno">  83 </span>    private fun handleError(createAccountError: AppError) {
<span class="lineno">  84 </span>        <span class="error">when (createAccountError) {</span>
<span class="lineno">  85 </span><span class="error">            is ApiAppError -&gt; when (createAccountError.errorCode) {</span>
<span class="lineno">  86 </span><span class="error">                ApiAppError.NETWORK_ERROR -&gt; createAccountDialogFactory!!.createAndShowDialog(</span>
<span class="lineno">  87 </span><span class="error">                    CreateAccountDialogFactory.Type.NO_INTERNET</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/createaccount/CreateAccountDialogFactory.kt:23:9</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Type`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  20 </span>
<span class="lineno">  21 </span>    private fun createGenericDialog(type: CreateAccountDialogFactory.Type): AlertDialog {
<span class="lineno">  22 </span>        val b = AlertDialog.Builder(activity)
<span class="lineno">  23 </span>        <span class="error">when (type) {</span>
<span class="lineno">  24 </span><span class="error">            CreateAccountDialogFactory.Type.NO_INTERNET -&gt; buildNoInternetDialog(b)</span>
<span class="lineno">  25 </span><span class="error">            CreateAccountDialogFactory.Type.USER_ALREADY_EXISTS -&gt; buildUserAlreadyExistDialog(b)</span>
<span class="lineno">  26 </span><span class="error">            else -&gt; buildUnknownErrorDialog(b, &quot;&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/dashboard/AirQualityStatusMediator.kt:100:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Quality?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  97 </span>    }
<span class="lineno">  98 </span>
<span class="lineno">  99 </span>    private fun makeAirQualityStatus(latestAssessment: Assessment&lt;out Map&lt;SensorType, Assessment&lt;Number&gt;&gt;&gt;?): AirQualityStatus {
<span class="lineno"> 100 </span>        return <span class="error">when (latestAssessment?.quality) {</span>
<span class="lineno"> 101 </span><span class="error">            Quality.GOOD -&gt; AirQualityStatus(</span>
<span class="lineno"> 102 </span><span class="error">                R.string.dashboard_air_quality_good,</span>
<span class="lineno"> 103 </span><span class="error">                R.color.darkMint,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/dashboard/DeviceSummaryActivity.kt:163:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `WaveMiniUserDevice`, `WavePlusUserDevice`, `WaveClassicGen2UserDevice`, `WaveClassicGen1UserDevice`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 160 </span>            return
<span class="lineno"> 161 </span>        }
<span class="lineno"> 162 </span>
<span class="lineno"> 163 </span>        <span class="error">when (userDevice) {</span>
<span class="lineno"> 164 </span><span class="error">            is WaveClassicGen1UserDevice -&gt; sensor_view.configureLayout(SensorViewLayout.Config.WAVE)</span>
<span class="lineno"> 165 </span><span class="error">            is WaveClassicGen2UserDevice -&gt; sensor_view.configureLayout(SensorViewLayout.Config.WAVE)</span>
<span class="lineno"> 166 </span><span class="error">            is WavePlusUserDevice -&gt; sensor_view.configureLayout(SensorViewLayout.Config.WAVE_PLUS)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/dashboard/DeviceSummaryActivity.kt:196:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SyncAndDiagnosticsState?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 193 </span>    }
<span class="lineno"> 194 </span>
<span class="lineno"> 195 </span>    private fun SyncAndDiagnosticsState?.toSyncIndicatorConfig(): ConfigurationType {
<span class="lineno"> 196 </span>        return <span class="error">when (this) {</span>
<span class="lineno"> 197 </span><span class="error">            SyncAndDiagnosticsState.OFFLINE -&gt; ConfigurationType.CLOUD_OFFLINE</span>
<span class="lineno"> 198 </span><span class="error">            SyncAndDiagnosticsState.BLE_OFF -&gt; ConfigurationType.BLUETOOTH_DISABLED</span>
<span class="lineno"> 199 </span><span class="error">            SyncAndDiagnosticsState.OFFLINE_AND_BLE_OFF -&gt; ConfigurationType.CLOUD_OFFLINE</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/dashboard/DeviceSummaryActivity.kt:271:13</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SensorType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 268 </span>            &quot;--&quot;
<span class="lineno"> 269 </span>        } else {
<span class="lineno"> 270 </span>            val sensorValue: Float = data.toFloat()
<span class="lineno"> 271 </span>            <span class="error">when (sensorType) {</span>
<span class="lineno"> 272 </span><span class="error">                SensorType.RADON_24H_AVG -&gt; valueFormatter.formatRadonValueWithLowerThanSign(sensorValue)</span>
<span class="lineno"> 273 </span><span class="error">                SensorType.TEMPERATURE -&gt; valueFormatter.formatTemperatureValue(sensorValue)</span>
<span class="lineno"> 274 </span><span class="error">                SensorType.HUMIDITY -&gt; valueFormatter.formatHumidityValue(sensorValue)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/dashboard/DeviceSummaryActivity.kt:282:73</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Quality`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 279 </span>            }
<span class="lineno"> 280 </span>        }
<span class="lineno"> 281 </span>        return SensorStatus(
<span class="lineno"> 282 </span>            formattedValue, if (this == null) QualityLevel.UNKNOWN else <span class="error">when (this.quality) {</span>
<span class="lineno"> 283 </span><span class="error">                Quality.GOOD -&gt; QualityLevel.GOOD</span>
<span class="lineno"> 284 </span><span class="error">                Quality.AVERAGE -&gt; QualityLevel.WARNING</span>
<span class="lineno"> 285 </span><span class="error">                Quality.POOR -&gt; QualityLevel.POOR</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/dashboard/DeviceSummaryViewModel.kt:103:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SyncStatus?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 100 </span>        lowOnStorage: Boolean?,
<span class="lineno"> 101 </span>        updateAvailableFlag: Boolean?
<span class="lineno"> 102 </span>    ): BannerState {
<span class="lineno"> 103 </span>        return <span class="error">when (syncStatus) {</span>
<span class="lineno"> 104 </span><span class="error">            ConnectedUserDevice.SyncStatus.IDLE -&gt; resolveForIdleState(</span>
<span class="lineno"> 105 </span><span class="error">                isOnline, bleIsOn, lowOnStorage, updateAvailableFlag</span>
<span class="lineno"> 106 </span><span class="error">            )</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/dashboard/DeviceSummaryViewModel.kt:204:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SyncStatus?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 201 </span>        internetAvailable: Boolean?,
<span class="lineno"> 202 </span>        bleEnabled: Boolean?
<span class="lineno"> 203 </span>    ): SyncAndDiagnosticsState {
<span class="lineno"> 204 </span>        return <span class="error">when (syncStatus) {</span>
<span class="lineno"> 205 </span><span class="error">            ConnectedUserDevice.SyncStatus.IDLE -&gt; resolveForIdleState(</span>
<span class="lineno"> 206 </span><span class="error">                batteryLevel,</span>
<span class="lineno"> 207 </span><span class="error">                connectivityStatus,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/DetailDashboardViewModel.kt:165:84</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SensorType?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 162 </span>        return Pair(toFormattedString(average, sensor), Assessor().getAssessment(sensor, average))
<span class="lineno"> 163 </span>    }
<span class="lineno"> 164 </span>
<span class="lineno"> 165 </span>    private fun toFormattedString(value: Float, sensorType: SensorType?): String = <span class="error">when (sensorType) {</span>
<span class="lineno"> 166 </span><span class="error">        SensorType.RADON_24H_AVG -&gt; valueFormatter.formatRadonValueWithLowerThanSign(value)</span>
<span class="lineno"> 167 </span><span class="error">        SensorType.TEMPERATURE -&gt; valueFormatter.formatTemperatureValue(value)</span>
<span class="lineno"> 168 </span><span class="error">        SensorType.HUMIDITY -&gt; valueFormatter.formatHumidityValue(value)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/DetailedDashboardContainerActivity.kt:156:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SensorType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 153 </span>
<span class="lineno"> 154 </span>    // helper extensions
<span class="lineno"> 155 </span>    private fun SensorType.toTabConfiguration(): TabConfiguration {
<span class="lineno"> 156 </span>        return <span class="error">when (this) {</span>
<span class="lineno"> 157 </span><span class="error">            SensorType.RADON_24H_AVG -&gt; TabConfiguration(</span>
<span class="lineno"> 158 </span><span class="error">                SensorType.RADON_24H_AVG,</span>
<span class="lineno"> 159 </span><span class="error">                R.drawable.radon_dark,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/DetailedDashboardContainerActivity.kt:213:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SyncAndDiagnosticsState?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 210 </span>    }
<span class="lineno"> 211 </span>
<span class="lineno"> 212 </span>    private fun SyncAndDiagnosticsState?.toSyncIndicatorConfig(): ConfigurationType {
<span class="lineno"> 213 </span>        return <span class="error">when (this) {</span>
<span class="lineno"> 214 </span><span class="error">            SyncAndDiagnosticsState.OFFLINE -&gt; ConfigurationType.CLOUD_OFFLINE</span>
<span class="lineno"> 215 </span><span class="error">            SyncAndDiagnosticsState.BLE_OFF -&gt; ConfigurationType.BLUETOOTH_DISABLED</span>
<span class="lineno"> 216 </span><span class="error">            SyncAndDiagnosticsState.OFFLINE_AND_BLE_OFF -&gt; ConfigurationType.CLOUD_OFFLINE</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/view/SensorHistoryFragment.kt:62:39</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SensorType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  59 </span>        this.sensorType = (arguments?.getString(ARG_SENSOR_TYPE)
<span class="lineno">  60 </span>            ?: error(&quot;$ARG_SENSOR_TYPE not provided&quot;)).let { SensorType.valueOf(it) }
<span class="lineno">  61 </span>
<span class="lineno">  62 </span>        val (yellowLevel, redLevel) = <span class="error">when (this.sensorType) {</span>
<span class="lineno">  63 </span><span class="error">            SensorType.RADON_24H_AVG -&gt; Assessor.Q_RN_AVERAGE_THRESH_BQM3 to Assessor.Q_RN_POOR_THRESH_BQM3</span>
<span class="lineno">  64 </span><span class="error">            SensorType.CO2 -&gt; Assessor.Q_CO2_AVERAGE_THRESH_PPM to Assessor.Q_CO2_POOR_THRESH_PPM</span>
<span class="lineno">  65 </span><span class="error">            SensorType.VOC -&gt; Assessor.Q_VOC_AVERAGE_THRESH_PPB to Assessor.Q_VOC_POOR_THRESH_PPB</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/view/SensorHistoryFragment.kt:110:45</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SensorType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 107 </span>            dateRangeSelected(GraphDefines.YEARLY_HORIZON)
<span class="lineno"> 108 </span>        }
<span class="lineno"> 109 </span>
<span class="lineno"> 110 </span>        detailed_circle_view.valueInFocus = <span class="error">when (sensorType) {</span>
<span class="lineno"> 111 </span><span class="error">            SensorType.RADON_24H_AVG -&gt; CircleViewResources.Sensor.RADON</span>
<span class="lineno"> 112 </span><span class="error">            SensorType.TEMPERATURE -&gt; CircleViewResources.Sensor.TEMPERATURE</span>
<span class="lineno"> 113 </span><span class="error">            SensorType.HUMIDITY -&gt; CircleViewResources.Sensor.HUMIDITY</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/view/SensorHistoryFragment.kt:207:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SensorType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 204 </span>    }
<span class="lineno"> 205 </span>
<span class="lineno"> 206 </span>    private fun SensorType.toValueInFocus(): Int {
<span class="lineno"> 207 </span>        return <span class="error">when (this) {</span>
<span class="lineno"> 208 </span><span class="error">            SensorType.RADON_24H_AVG -&gt; GraphDefines.RADON</span>
<span class="lineno"> 209 </span><span class="error">            SensorType.TEMPERATURE -&gt; GraphDefines.TEMPERATURE</span>
<span class="lineno"> 210 </span><span class="error">            SensorType.HUMIDITY -&gt; GraphDefines.HUMIDITY</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/forgotpassword/ForgotPasswordBaseFragment.kt:39:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `StateAppError`, `ApiAppError`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  36 </span>    }
<span class="lineno">  37 </span>
<span class="lineno">  38 </span>    fun presentError(apiError: AppError?) {
<span class="lineno">  39 </span>        <span class="error">when (apiError) {</span>
<span class="lineno">  40 </span><span class="error">            is ApiAppError -&gt; presentAppApiError(apiError)</span>
<span class="lineno">  41 </span><span class="error">            is StateAppError -&gt; showDialogMessage(</span>
<span class="lineno">  42 </span><span class="error">                getString(R.string.unexpected_app_error_title),</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/login/LoginActivity.kt:168:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `StateAppError`, `ApiAppError`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 165 </span>
<span class="lineno"> 166 </span>    private fun showError(apiError: AppError) {
<span class="lineno"> 167 </span>        Log.d(TAG, &quot;Login failure: $apiError&quot;)
<span class="lineno"> 168 </span>        <span class="error">when (apiError) {</span>
<span class="lineno"> 169 </span><span class="error">            is ApiAppError -&gt; when (apiError.errorCode) {</span>
<span class="lineno"> 170 </span><span class="error">                ApiAppError.Companion.Login.INVALID_EMAIL_OR_PASSWORD -&gt; showDialogMessage(</span>
<span class="lineno"> 171 </span><span class="error">                    getString(R.string.log_in_incorrect_credentials_title),</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageaccount/AccountActivity.kt:72:35</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `StateAppError`, `ApiAppError`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  69 </span>    }
<span class="lineno">  70 </span>
<span class="lineno">  71 </span>    private fun showLogoutFailure(error: AppError) {
<span class="lineno">  72 </span>        val additionalErrorInfo = <span class="error">when (error) {</span>
<span class="lineno">  73 </span><span class="error">            is ApiAppError -&gt; &quot;[${error.errorCode}]&quot;</span>
<span class="lineno">  74 </span><span class="error">            is StateAppError -&gt; &quot;[${error.errorCode}]&quot;</span>
<span class="lineno">  75 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageinstrument/ManageDeviceActivity.kt:71:42</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `SetLocationProcess.ChangeRequest.LocationAndRoomChangeReq`, `SetLocationProcess.ChangeRequest.RoomChangeRequest`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  68 </span>            val progressDialog = ProgressDialog(this@ManageDeviceActivity)
<span class="lineno">  69 </span>            progressDialog.setTitle(R.string.manage_device_please_wait)
<span class="lineno">  70 </span>            progressDialog.show()
<span class="lineno">  71 </span>            val (result, backStackTag) = <span class="error">when (changeRequest) {</span>
<span class="lineno">  72 </span><span class="error">                is SetLocationProcess.ChangeRequest.RoomChangeRequest -&gt;</span>
<span class="lineno">  73 </span><span class="error">                    viewModel.changeRoom(changeRequest.roomName) to SET_ROOM_FRAG_TAG</span>
<span class="lineno">  74 </span><span class="error">                is SetLocationProcess.ChangeRequest.LocationAndRoomChangeReq -&gt; viewModel.changeLocation(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageinstrument/ManageDeviceActivity.kt:173:20</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `StateAppError`, `ApiAppError`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 170 </span>
<span class="lineno"> 171 </span>    private fun showUnPairFailure(err: AppError) {
<span class="lineno"> 172 </span>        val title = getString(R.string.manage_device_unpair_failure_title)
<span class="lineno"> 173 </span>        val body = <span class="error">when (err) {</span>
<span class="lineno"> 174 </span><span class="error">            is ApiAppError -&gt; {</span>
<span class="lineno"> 175 </span><span class="error">                when (err.errorCode) {</span>
<span class="lineno"> 176 </span><span class="error">                    ApiAppError.NETWORK_ERROR -&gt; getString(R.string.manage_device_unpair_failure_body_no_internet)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageinstrument/ManageDeviceActivity.kt:195:20</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `StateAppError`, `ApiAppError`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 192 </span>
<span class="lineno"> 193 </span>    private fun showLocationChangeFailure(err: AppError) {
<span class="lineno"> 194 </span>        val title = getString(R.string.manage_device_edit_location_failure_title)
<span class="lineno"> 195 </span>        val body = <span class="error">when (err) {</span>
<span class="lineno"> 196 </span><span class="error">            is ApiAppError -&gt; handleApiError(err)</span>
<span class="lineno"> 197 </span><span class="error">            is StateAppError -&gt; getString(</span>
<span class="lineno"> 198 </span><span class="error">                R.string.manage_device_unpair_failure_body_cloud_error,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/selectinstrument/UserDevicesAdapter.kt:195:12</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Quality`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 192 </span>}
<span class="lineno"> 193 </span>
<span class="lineno"> 194 </span>fun Quality.toColorCircleValue(): CircleViewResources.Level {
<span class="lineno"> 195 </span>    return <span class="error">when (this) {</span>
<span class="lineno"> 196 </span><span class="error">        Quality.UNKNOWN -&gt; CircleViewResources.Level.NO_VALUE</span>
<span class="lineno"> 197 </span><span class="error">        Quality.GOOD -&gt; CircleViewResources.Level.LOW</span>
<span class="lineno"> 198 </span><span class="error">        Quality.AVERAGE -&gt; CircleViewResources.Level.MEDIUM</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/settingsmenu/SettingsActivity.kt:38:9</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `MeasurementUnit`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  35 </span>    }
<span class="lineno">  36 </span>
<span class="lineno">  37 </span>    private fun showMeasurementUnit() {
<span class="lineno">  38 </span>        <span class="error">when (this.viewModel.getMeasurementUnit()) {</span>
<span class="lineno">  39 </span><span class="error">            MeasurementUnit.METRIC -&gt; {</span>
<span class="lineno">  40 </span><span class="error">                settings_metric_unit_check.visibility = View.VISIBLE</span>
<span class="lineno">  41 </span><span class="error">                settings_us_unit_check.visibility = View.GONE</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/updatefw/FirmwareUpdateViewModel.kt:110:34</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `FwUpdateState`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 107 </span>    suspend fun updateDevice() {
<span class="lineno"> 108 </span>        val device = this.currentDevice.suspendGetValue() ?: error(&quot;Device not found&quot;)
<span class="lineno"> 109 </span>        device.updateFirmware(this.fwImages) { status: FwUpdateState, progress: Int, throwable: BleException? -&gt;
<span class="lineno"> 110 </span>            _updateState.value = <span class="error">when (status) {</span>
<span class="lineno"> 111 </span><span class="error">                FwUpdateState.FW_UPDATE_IN_PROGRESS -&gt; Updating(progress, false)</span>
<span class="lineno"> 112 </span><span class="error">                FwUpdateState.FW_UPDATE_COMPLETE -&gt; UpdateSuccessful</span>
<span class="lineno"> 113 </span><span class="error">                FwUpdateState.FW_UPDATE_REBOOTING -&gt; Updating(progress, true)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/utils/AppUtil.kt:31:20</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `MeasurementUnit?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  28 </span>class MeasurementUnitMapper {
<span class="lineno">  29 </span>    companion object {
<span class="lineno">  30 </span>        fun mapToPreferredUnit(atUser: AirthingsUser): PreferredUnit {
<span class="lineno">  31 </span>            return <span class="error">when (atUser.measurementUnit) {</span>
<span class="lineno">  32 </span><span class="error">                MeasurementUnit.US -&gt; PreferredUnit.US</span>
<span class="lineno">  33 </span><span class="error">                else -&gt; PreferredUnit.METRIC</span>
<span class="lineno">  34 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/utils/Funcs.kt:206:48</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Fragment`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 203 </span>}
<span class="lineno"> 204 </span>
<span class="lineno"> 205 </span>fun &lt;T, K : LiveData&lt;T&gt;&gt; LifecycleOwner.observe(ld: K, fn: (T) -&gt; Unit) {
<span class="lineno"> 206 </span>    ld.observe(@Suppress(&quot;UseIfInsteadOfWhen&quot;) <span class="error">when (this) {</span>
<span class="lineno"> 207 </span><span class="error">        is Fragment -&gt; this.viewLifecycleOwner</span>
<span class="lineno"> 208 </span><span class="error">        else -&gt; this</span>
<span class="lineno"> 209 </span><span class="error">    }</span>, Observer { fn.invoke(it) })
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/viewbinding/ImageViewBindingAdapter.kt:19:31</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Model?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  16 </span>    @BindingAdapter(&quot;android:src&quot;)
<span class="lineno">  17 </span>    fun setSrc(view: ImageView, device: AirthingsDevice?) {
<span class="lineno">  18 </span>        @DrawableRes
<span class="lineno">  19 </span>        val resourceId: Int = <span class="error">when (device?.model) {</span>
<span class="lineno">  20 </span><span class="error">            AirthingsDevice.Model.Hub -&gt; R.drawable.ic_device_hub</span>
<span class="lineno">  21 </span><span class="error">            AirthingsDevice.Model.WavePlus -&gt; R.drawable.ic_device_wave_plus</span>
<span class="lineno">  22 </span><span class="error">            AirthingsDevice.Model.WaveMini -&gt; R.drawable.ic_device_wave_mini</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/widget/AboutContaminantsView.kt:44:21</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Config`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  41 </span>    }
<span class="lineno">  42 </span>
<span class="lineno">  43 </span>    private fun getMoreInfoUri(): Uri {
<span class="lineno">  44 </span>        val resId = <span class="error">when (config) {</span>
<span class="lineno">  45 </span><span class="error">            Config.RADON -&gt; R.string.link_radon_info</span>
<span class="lineno">  46 </span><span class="error">            Config.VOC -&gt; R.string.link_tvoc_info</span>
<span class="lineno">  47 </span><span class="error">            Config.CO2 -&gt; R.string.link_co2_info</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/widget/AboutContaminantsView.kt:71:21</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Config`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  68 </span>    }
<span class="lineno">  69 </span>
<span class="lineno">  70 </span>    private fun resolveSensorLabel(): String? {
<span class="lineno">  71 </span>        val resId = <span class="error">when (config) {</span>
<span class="lineno">  72 </span><span class="error">            Config.RADON -&gt; R.string.term_radon</span>
<span class="lineno">  73 </span><span class="error">            Config.VOC -&gt; R.string.term_voc</span>
<span class="lineno">  74 </span><span class="error">            Config.CO2 -&gt; R.string.term_co2</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/widget/AboutContaminantsView.kt:81:9</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Config`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  78 </span>    }
<span class="lineno">  79 </span>
<span class="lineno">  80 </span>    private fun update() {
<span class="lineno">  81 </span>        <span class="error">when (config) {</span>
<span class="lineno">  82 </span><span class="error">            Config.INVISIBLE -&gt; this.visibility = View.GONE</span>
<span class="lineno">  83 </span><span class="error">            Config.CONTAMINANTS -&gt; configureForContaminants()</span>
<span class="lineno">  84 </span><span class="error">            else -&gt; configureForSpecificContaminant()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/widget/AboutContaminantsView.kt:94:12</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `SensorType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  91 </span>}
<span class="lineno">  92 </span>
<span class="lineno">  93 </span>fun SensorType.toContaminantConfig(): AboutContaminantsView.Config {
<span class="lineno">  94 </span>    return <span class="error">when (this) {</span>
<span class="lineno">  95 </span><span class="error">        SensorType.RADON_24H_AVG -&gt; AboutContaminantsView.Config.RADON</span>
<span class="lineno">  96 </span><span class="error">        SensorType.VOC -&gt; AboutContaminantsView.Config.VOC</span>
<span class="lineno">  97 </span><span class="error">        SensorType.CO2 -&gt; AboutContaminantsView.Config.CO2</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/widget/circleview/CircleViewResources.kt:66:40</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Level`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  63 </span>    }
<span class="lineno">  64 </span>
<span class="lineno">  65 </span>    fun getColorCircleColor(valueLevel: Level): IntArray {
<span class="lineno">  66 </span>        val (upperColor, lowerColor) = <span class="error">when (valueLevel) {</span>
<span class="lineno">  67 </span><span class="error">            Level.LOW -&gt; lowCircleGradient</span>
<span class="lineno">  68 </span><span class="error">            Level.MEDIUM -&gt; mediumCircleGradient</span>
<span class="lineno">  69 </span><span class="error">            Level.HIGH -&gt; highCircleGradient</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/widget/circleview/CircleViewResources.kt:78:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Level`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  75 </span>    }
<span class="lineno">  76 </span>
<span class="lineno">  77 </span>    fun getGlowGradient(valueLevel: Level): IntArray {
<span class="lineno">  78 </span>        return <span class="error">when (valueLevel) {</span>
<span class="lineno">  79 </span><span class="error">            Level.LOW -&gt; lowGlowGradient</span>
<span class="lineno">  80 </span><span class="error">            Level.MEDIUM -&gt; mediumGlowGradient</span>
<span class="lineno">  81 </span><span class="error">            Level.HIGH -&gt; highGlowGradient</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/widget/circleview/DetailedColorCircleView.kt:125:9</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Sensor`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 122 </span>
<span class="lineno"> 123 </span>    override fun updatePaint() {
<span class="lineno"> 124 </span>        super.updatePaint()
<span class="lineno"> 125 </span>        <span class="error">when (valueInFocus) {</span>
<span class="lineno"> 126 </span><span class="error">            CircleViewResources.Sensor.RADON -&gt; {</span>
<span class="lineno"> 127 </span><span class="error">                measurementDescription1 = context.getString(R.string.detailed_dashboard_radon_avg)</span>
<span class="lineno"> 128 </span><span class="error">                if (measurementUnit == MeasurementUnit.METRIC) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/DeviceViewModel.kt:284:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 281 </span>
<span class="lineno"> 282 </span>    suspend fun readFirmwareVersions() = suspendCoroutine&lt;Unit&gt; { cont -&gt;
<span class="lineno"> 283 </span>        device.value?.getFirmwareVersion { result -&gt;
<span class="lineno"> 284 </span>            <span class="error">when (result) {</span>
<span class="lineno"> 285 </span><span class="error">                is Failure -&gt; cont.resumeWith(Result.failure(result.e))</span>
<span class="lineno"> 286 </span><span class="error">                is Success -&gt; {</span>
<span class="lineno"> 287 </span><span class="error">                    firmwareVersions.clear()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/DeviceViewModel.kt:320:17</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `FwUpdateState`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 317 </span>        fun updateFirmwareImpl(device: AirthingsDevice) {
<span class="lineno"> 318 </span>            device.updateFirmware(firmwareUpdates, isLinking) { state, progress, err -&gt;
<span class="lineno"> 319 </span>                fn.invoke(state, progress, err)
<span class="lineno"> 320 </span>                <span class="error">when (state) {</span>
<span class="lineno"> 321 </span><span class="error">                    FwUpdateState.FW_UPDATE_IN_PROGRESS -&gt; {</span>
<span class="lineno"> 322 </span><span class="error">                        // NO-OP</span>
<span class="lineno"> 323 </span><span class="error">                    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/BaseDeviceSelectionPage.kt:94:13</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ScanStatus`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  91 </span>    protected fun scanDevices() {
<span class="lineno">  92 </span>        viewModel.working.value = true
<span class="lineno">  93 </span>        viewModel.scanDevices { status, device, _ -&gt;
<span class="lineno">  94 </span>            <span class="error">when (status) {</span>
<span class="lineno">  95 </span><span class="error">                ScanStatus.ONGOING -&gt; if (null != device &amp;&amp; isSuitable(device)) {</span>
<span class="lineno">  96 </span><span class="error">                    adapter.add(device)</span>
<span class="lineno">  97 </span><span class="error">                }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/SetRegionPage.kt:96:20</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Region`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  93 </span>
<span class="lineno">  94 </span>        fun of(context: Context, code: Region = Region.UNDEFINED): RegionItem {
<span class="lineno">  95 </span>            val resources = context.resources
<span class="lineno">  96 </span>            return <span class="error">when (code) {</span>
<span class="lineno">  97 </span><span class="error">                Region.EUROPE -&gt; RegionItem(</span>
<span class="lineno">  98 </span><span class="error">                    code = code,</span>
<span class="lineno">  99 </span><span class="error">                    label = resources.getString(R.string.device_wizard_region_europe)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/AwaitRebootProgressStep.kt:38:17</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ScanStatus`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  35 </span>            var isCancelled = false
<span class="lineno">  36 </span>            var isDone = false
<span class="lineno">  37 </span>            viewModel.scanDevices { status, device, e -&gt;
<span class="lineno">  38 </span>                <span class="error">when (status) {</span>
<span class="lineno">  39 </span><span class="error">                    ScanStatus.ONGOING -&gt; if (!isCancelled &amp;&amp; !isDone &amp;&amp; device == viewModel.device.value) {</span>
<span class="lineno">  40 </span><span class="error">                        isDone = true</span>
<span class="lineno">  41 </span><span class="error">                        handler.onDone(this)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/ProgressPage.kt:61:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `HubDevice`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  58 </span>        var hasHubDevices = false
<span class="lineno">  59 </span>        var hasLinkableDevices = false
<span class="lineno">  60 </span>        viewModel.devicesLiveData.value?.forEach {
<span class="lineno">  61 </span>            <span class="error">when {</span>
<span class="lineno">  62 </span><span class="error">                !hasHubDevices &amp;&amp; it is HubDevice -&gt; hasHubDevices = true</span>
<span class="lineno">  63 </span><span class="error">                !hasLinkableDevices &amp;&amp; it.isLinkable -&gt; hasLinkableDevices = true</span>
<span class="lineno">  64 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/UpdateFirmwareProgressStep.kt:56:9</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `FwUpdateState`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  53 </span>        progress: Int,
<span class="lineno">  54 </span>        err: BleException?
<span class="lineno">  55 </span>    ) {
<span class="lineno">  56 </span>        <span class="error">when (state) {</span>
<span class="lineno">  57 </span><span class="error">            AirthingsDevice.FwUpdateState.FW_UPDATE_IN_PROGRESS -&gt; currentOperation = progress</span>
<span class="lineno">  58 </span><span class="error">            AirthingsDevice.FwUpdateState.FW_UPDATE_REBOOTING,</span>
<span class="lineno">  59 </span><span class="error">            AirthingsDevice.FwUpdateState.FW_UPDATE_COMPLETE -&gt; currentOperation = operationsCount</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/AirthingsDevice.kt:180:33</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `OadStatus`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 177 </span>                        this.progress = progressPercent.roundToInt()
<span class="lineno"> 178 </span>                        ui {
<span class="lineno"> 179 </span>                            fn.invoke(
<span class="lineno"> 180 </span>                                <span class="error">when (status) {</span>
<span class="lineno"> 181 </span><span class="error">                                    OadProgressCB.OadStatus.PREPARING,</span>
<span class="lineno"> 182 </span><span class="error">                                    OadProgressCB.OadStatus.WRITING_HEADER,</span>
<span class="lineno"> 183 </span><span class="error">                                    OadProgressCB.OadStatus.TRX_IN_PROGRESS -&gt; FwUpdateState.FW_UPDATE_IN_PROGRESS</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/AirthingsDevice.kt:376:37</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Model?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 373 </span>        @Suppress(&quot;ComplexMethod&quot;)
<span class="lineno"> 374 </span>        @Synchronized
<span class="lineno"> 375 </span>        fun getDevice(serial: String, mac: String): AirthingsDevice? {
<span class="lineno"> 376 </span>            return cache[serial] ?: <span class="error">when (Model.fromSerial(serial)) {</span>
<span class="lineno"> 377 </span><span class="error">                Model.Wave1 -&gt; Wave1Device(serial, mac)</span>
<span class="lineno"> 378 </span><span class="error">                Model.Wave2 -&gt; Wave2Device(serial, mac)</span>
<span class="lineno"> 379 </span><span class="error">                Model.WavePlus -&gt; WavePlusDevice(serial, mac)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/AirthingsDevice.kt:480:24</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `InstrumentType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 477 </span>        companion object {
<span class="lineno"> 478 </span>            fun id(m: Model) = m.id
<span class="lineno"> 479 </span>            fun fromSerial(serial: String): Model? {
<span class="lineno"> 480 </span>                return <span class="error">when (InstrumentTypeInference.inferFromSerialNumber(serial)) {</span>
<span class="lineno"> 481 </span><span class="error">                    InstrumentType.WAVE -&gt; Wave1</span>
<span class="lineno"> 482 </span><span class="error">                    InstrumentType.WAVE2 -&gt; Wave2</span>
<span class="lineno"> 483 </span><span class="error">                    InstrumentType.WAVE_PLUS -&gt; WavePlus</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/AirthingsRadonDevice.kt:37:33</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  34 </span>                    ) {
<span class="lineno">  35 </span>                        ui {
<span class="lineno">  36 </span>                            fn(
<span class="lineno">  37 </span>                                <span class="error">when (it) {</span>
<span class="lineno">  38 </span><span class="error">                                    is Success -&gt; null</span>
<span class="lineno">  39 </span><span class="error">                                    is Failure -&gt; it.e</span>
<span class="lineno">  40 </span><span class="error">                                }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/GriffinDevice.kt:52:21</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  49 </span>            this.serial,
<span class="lineno">  50 </span>            ReadRfRegion(AirCurtain.appContext, this.serial) {
<span class="lineno">  51 </span>                cont.resumeWith(
<span class="lineno">  52 </span>                    <span class="error">when (it) {</span>
<span class="lineno">  53 </span><span class="error">                        is Success -&gt; Result.success(it.value)</span>
<span class="lineno">  54 </span><span class="error">                        is Failure -&gt; Result.failure(it.e)</span>
<span class="lineno">  55 </span><span class="error">                    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/GriffinDevice.kt:65:21</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  62 </span>            this.serial,
<span class="lineno">  63 </span>            WriteRfRegion(AirCurtain.appContext, this.serial, rfRegion) {
<span class="lineno">  64 </span>                cont.resumeWith(
<span class="lineno">  65 </span>                    <span class="error">when (it) {</span>
<span class="lineno">  66 </span><span class="error">                        is Success -&gt; Result.success(Unit)</span>
<span class="lineno">  67 </span><span class="error">                        is Failure -&gt; Result.failure(it.e)</span>
<span class="lineno">  68 </span><span class="error">                    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/MerlinDevice.kt:33:21</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  30 </span>            this.serial,
<span class="lineno">  31 </span>            ReadRfRegion(AirCurtain.appContext, this.serial) {
<span class="lineno">  32 </span>                cont.resumeWith(
<span class="lineno">  33 </span>                    <span class="error">when (it) {</span>
<span class="lineno">  34 </span><span class="error">                        is Success -&gt; Result.success(it.value)</span>
<span class="lineno">  35 </span><span class="error">                        is Failure -&gt; Result.failure(it.e)</span>
<span class="lineno">  36 </span><span class="error">                    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/MerlinDevice.kt:47:21</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  44 </span>            this.serial,
<span class="lineno">  45 </span>            WriteRfRegion(AirCurtain.appContext, this.serial, rfRegion) {
<span class="lineno">  46 </span>                cont.resumeWith(
<span class="lineno">  47 </span>                    <span class="error">when (it) {</span>
<span class="lineno">  48 </span><span class="error">                        is Success -&gt; Result.success(Unit)</span>
<span class="lineno">  49 </span><span class="error">                        is Failure -&gt; Result.failure(it.e)</span>
<span class="lineno">  50 </span><span class="error">                    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/Wave1Device.kt:71:33</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  68 </span>                    ) {
<span class="lineno">  69 </span>                        ui {
<span class="lineno">  70 </span>                            fn(
<span class="lineno">  71 </span>                                <span class="error">when (it) {</span>
<span class="lineno">  72 </span><span class="error">                                    is Success -&gt; null</span>
<span class="lineno">  73 </span><span class="error">                                    is Failure -&gt; it.e</span>
<span class="lineno">  74 </span><span class="error">                                }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/Wave1Device.kt:108:21</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 105 </span>            error(&quot;Wave 1 classic only supports writing MSP&quot;)
<span class="lineno"> 106 </span>        }
<span class="lineno"> 107 </span>
<span class="lineno"> 108 </span>        val image = <span class="error">when (val result = MspFwImageLoader(</span>
<span class="lineno"> 109 </span><span class="error">            AirCurtain.appContext, &quot;msp_firmware&quot;</span>
<span class="lineno"> 110 </span><span class="error">        ).tryLoad(mspImage.data)) {</span>
<span class="lineno"> 111 </span><span class="error">            is Success -&gt; result.value</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/Wave1Device.kt:130:79</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Error`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 127 </span>                object : MspFwUpdate.FwUpgradeCB {
<span class="lineno"> 128 </span>                    private var latestProgress = 0
<span class="lineno"> 129 </span>
<span class="lineno"> 130 </span>                    fun getBleError(error: MspFwUpdate.Error): BleException = <span class="error">when (error) {</span>
<span class="lineno"> 131 </span><span class="error">                        MspFwUpdate.Error.INSTRUMENT_NOT_AVAILABLE -&gt; ErrorDirectory.instrumentNotAvailable(serial)</span>
<span class="lineno"> 132 </span><span class="error">                        MspFwUpdate.Error.FW_IMAGE_FILE_NOT_FOUND -&gt; ErrorDirectory.firmImageIsNull(&quot;IMAGE_NOT_FOUND&quot;)</span>
<span class="lineno"> 133 </span><span class="error">                        MspFwUpdate.Error.ABORTED -&gt; ErrorDirectory.failedToTransferImage(&quot;ABORTED&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-core/src/main/java/com/airthings/core/entities/instrument/AirQualityAssessor.kt:25:13</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Type`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  22 </span>object AirQualityAssessor {
<span class="lineno">  23 </span>    fun getAssessment(sensorType: Sensor.Type, sensorValue: Float?, alwaysAssess: Boolean = false): AirQualityAssessment {
<span class="lineno">  24 </span>        sensorValue?.let {
<span class="lineno">  25 </span>            <span class="error">when (sensorType) {</span>
<span class="lineno">  26 </span><span class="error">                Sensor.Type.RADON_24H_AVG -&gt; return getRadonAssessment(it)</span>
<span class="lineno">  27 </span><span class="error">                Sensor.Type.TEMPERATURE -&gt; return getTemperatureAssessment(it, alwaysAssess)</span>
<span class="lineno">  28 </span><span class="error">                Sensor.Type.HUMIDITY -&gt; return getHumidityAssessment(it)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-core/src/main/java/com/airthings/core/entities/instrument/Instrument.kt:22:20</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Type`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  19 </span>
<span class="lineno">  20 </span>        @Suppress(&quot;unused&quot;)
<span class="lineno">  21 </span>        fun productName(): String {
<span class="lineno">  22 </span>            return <span class="error">when (this) {</span>
<span class="lineno">  23 </span><span class="error">                UNKNOWN_INSTRUMENT_TYPE -&gt; &quot;Unknown&quot;</span>
<span class="lineno">  24 </span><span class="error">                WAVE_CLASSIC_GEN_1, WAVE_CLASSIC_GEN_2 -&gt; &quot;Wave&quot;</span>
<span class="lineno">  25 </span><span class="error">                WAVE_PLUS_GEN_1 -&gt; &quot;Wave Plus&quot;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-deviceio/src/androidTest/java/com/airthings/deviceio/DeviceFirmwareUpgradeTests.kt:74:49</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `dfuStatus`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  71 </span>                    dfuStat = status
<span class="lineno">  72 </span>                    Log.d(
<span class="lineno">  73 </span>                        TAG,
<span class="lineno">  74 </span>                        &quot;DFU Status update: &quot; + <span class="error">when (status) {</span>
<span class="lineno">  75 </span><span class="error">                            DeviceFirmwareUpgradeProgressCallback.dfuStatus.dfuIdle -&gt; &quot;Idle&quot;</span>
<span class="lineno">  76 </span><span class="error">                            DeviceFirmwareUpgradeProgressCallback.dfuStatus.dfuStarted -&gt; &quot;Started&quot;</span>
<span class="lineno">  77 </span><span class="error">                            DeviceFirmwareUpgradeProgressCallback.dfuStatus.dfuUpgrading -&gt; &quot;Upgrading&quot;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-deviceio/src/androidTest/java/com/airthings/deviceio/DeviceFirmwareUpgradeTests.kt:96:73</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `dfuStatus`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  93 </span>                Thread.sleep(500)
<span class="lineno">  94 </span>                Log.d(
<span class="lineno">  95 </span>                    TAG,
<span class="lineno">  96 </span>                    &quot;Waiting for Firmware Upgrade, current status = &quot; + <span class="error">when (dfuStat) {</span>
<span class="lineno">  97 </span><span class="error">                        DeviceFirmwareUpgradeProgressCallback.dfuStatus.dfuIdle -&gt; &quot;Idle&quot;</span>
<span class="lineno">  98 </span><span class="error">                        DeviceFirmwareUpgradeProgressCallback.dfuStatus.dfuStarted -&gt; &quot;Started&quot;</span>
<span class="lineno">  99 </span><span class="error">                        DeviceFirmwareUpgradeProgressCallback.dfuStatus.dfuUpgrading -&gt; &quot;Upgrading&quot;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/androidTest/java/com/airthings/instrumentapi/fwutil/MspFwImageLoaderTest.kt:80:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, `FileNotFoundException`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  77 </span>
<span class="lineno">  78 </span>    @Test
<span class="lineno">  79 </span>    fun getDeviceName_failsWhenPathWrong() {
<span class="lineno">  80 </span>        <span class="error">when (val result = MspFwImageLoader(context, &quot;No path&quot;).getLatestVersionName()) {</span>
<span class="lineno">  81 </span><span class="error">            is Success -&gt; fail(&quot;Expected a Failure.&quot;)</span>
<span class="lineno">  82 </span><span class="error">            is Failure -&gt; assertTrue(result.e is FileNotFoundException)</span>
<span class="lineno">  83 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/androidTest/java/com/airthings/instrumentapi/fwutil/MspFwImageLoaderTest.kt:88:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  85 </span>
<span class="lineno">  86 </span>    @Test
<span class="lineno">  87 </span>    fun canGetDeviceName() {
<span class="lineno">  88 </span>        <span class="error">when (val result = MspFwImageLoader(context, &quot;test/msp_firmware/wave&quot;).getLatestVersionName()) {</span>
<span class="lineno">  89 </span><span class="error">            is Success -&gt; assertEquals(mspFwFileName, result.value)</span>
<span class="lineno">  90 </span><span class="error">            is Failure -&gt; fail()</span>
<span class="lineno">  91 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/fwutil/BleFwImage.kt:17:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  14 </span>    }
<span class="lineno">  15 </span>
<span class="lineno">  16 </span>    init {
<span class="lineno">  17 </span>        <span class="error">when (val result = fwImageLoader.tryLoadAndValidateImage()) {</span>
<span class="lineno">  18 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno">  19 </span><span class="error">                imageBinary = result.value.fwImageBinary</span>
<span class="lineno">  20 </span><span class="error">                imageName = result.value.fwImageName</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/fwutil/MspFwImageLoader.kt:18:30</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  15 </span>    private val startIdxKeyword = &quot;STARTIDX=&quot;
<span class="lineno">  16 </span>
<span class="lineno">  17 </span>    fun getLatestVersionName(): Try&lt;String&gt; {
<span class="lineno">  18 </span>        val validFileNames = <span class="error">when (val result = getValidFileNames()) {</span>
<span class="lineno">  19 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  20 </span><span class="error">            is Failure -&gt; return Failure(result.e)</span>
<span class="lineno">  21 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/fwutil/MspFwImageLoader.kt:33:30</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  30 </span>
<span class="lineno">  31 </span>    @Suppress(&quot;ReturnCount&quot;)
<span class="lineno">  32 </span>    override fun tryLoadAndValidateImage(): Try&lt;FwImageData&gt; {
<span class="lineno">  33 </span>        val validFileNames = <span class="error">when (val result = getValidFileNames()) {</span>
<span class="lineno">  34 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  35 </span><span class="error">            is Failure -&gt; return Failure(result.e)</span>
<span class="lineno">  36 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/fwutil/MspFwImageLoader.kt:48:30</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  45 </span>
<span class="lineno">  46 </span>    @Suppress(&quot;ReturnCount&quot;)
<span class="lineno">  47 </span>    override fun tryLoadAndValidateImage(fileName: String): Try&lt;FwImageData&gt; {
<span class="lineno">  48 </span>        val validFileNames = <span class="error">when (val result = getValidFileNames()) {</span>
<span class="lineno">  49 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  50 </span><span class="error">            is Failure -&gt; return Failure(result.e)</span>
<span class="lineno">  51 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/fwutil/MspFwImageLoader.kt:64:22</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  61 </span>        loadAndVerifyFwImageData(fileName, readFileLines(context.assets.open(&quot;$path/$fileName&quot;)))
<span class="lineno">  62 </span>
<span class="lineno">  63 </span>    private fun loadAndVerifyFwImageData(fileName: String, fileLines: ArrayList&lt;String&gt;): Try&lt;MspFwImageData&gt; {
<span class="lineno">  64 </span>        val header = <span class="error">when (val result = tryGetAndVerifyHeader(fileLines)) {</span>
<span class="lineno">  65 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  66 </span><span class="error">            is Failure -&gt; return Failure(result.e)</span>
<span class="lineno">  67 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/BtSampleMakerFactory.kt:18:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `WavePlusCommProtocol`, `Wave2CommProtocol`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  15 </span>        bleFwVersion: String,
<span class="lineno">  16 </span>        mspFwVersion: String
<span class="lineno">  17 </span>    ): BtSampleMaker {
<span class="lineno">  18 </span>        return <span class="error">when (atCommProtocol) {</span>
<span class="lineno">  19 </span><span class="error">            is Wave2CommProtocol -&gt; Wave2BtSampleMaker(dataSetInfo, bleFwVersion, mspFwVersion)</span>
<span class="lineno">  20 </span><span class="error">            is WavePlusCommProtocol -&gt; WavePlusBtSampleMaker(dataSetInfo, bleFwVersion, mspFwVersion)</span>
<span class="lineno">  21 </span><span class="error">            else -&gt; NullBtSampleMaker(dataSetInfo, bleFwVersion, mspFwVersion)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/conversion/SelfCheckSummaryParser.kt:27:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  24 </span>        val validationResult = validate(params)
<span class="lineno">  25 </span>        if (validationResult is Failure) return Failure(validationResult.e)
<span class="lineno">  26 </span>        val fwVersionResult = FwVersionInterpreter().interpret(byteArrayOf(params[9], params[8]), FirmwareImageType.MSP)
<span class="lineno">  27 </span>        return <span class="error">when (fwVersionResult) {</span>
<span class="lineno">  28 </span><span class="error">            is Failure -&gt; Failure(fwVersionResult.e)</span>
<span class="lineno">  29 </span><span class="error">            is Success -&gt; Success(</span>
<span class="lineno">  30 </span><span class="error">                SelfCheckSummary(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:31:29</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OnServicesDiscoveredListener`, `OnDescriptorReadListener`, `OnDescriptorWriteListener`, `OnCharacteristicWriteListener`, `OnCharacteristicReadListener`, `OnCharacteristicChangedListener`, `OnPhyUpdateListener`, `OnPhyReadListener`, `OnMtuChangedListener`, `ConnectionStateChangedListener`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  28 </span>    protected var latestConnectionState: Int = BluetoothGatt.STATE_DISCONNECTED
<span class="lineno">  29 </span>
<span class="lineno">  30 </span>    fun addGattObserver(gattObserver: GattObserver): Boolean {
<span class="lineno">  31 </span>        val addedObserver = <span class="error">when (gattObserver) {</span>
<span class="lineno">  32 </span><span class="error">            is ConnectionStateChangedListener -&gt; connectionStateChangedListeners.put(</span>
<span class="lineno">  33 </span><span class="error">                gattObserver.uuid,</span>
<span class="lineno">  34 </span><span class="error">                gattObserver</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:66:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `OnServicesDiscoveredListener`, `OnDescriptorReadListener`, `OnDescriptorWriteListener`, `OnCharacteristicWriteListener`, `OnCharacteristicReadListener`, `OnCharacteristicChangedListener`, `OnPhyUpdateListener`, `OnPhyReadListener`, `OnMtuChangedListener`, `ConnectionStateChangedListener`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  63 </span>    }
<span class="lineno">  64 </span>
<span class="lineno">  65 </span>    fun removeGattObserver(gattObserver: GattObserver): Boolean {
<span class="lineno">  66 </span>        return <span class="error">when (gattObserver) {</span>
<span class="lineno">  67 </span><span class="error">            is ConnectionStateChangedListener -&gt; connectionStateChangedListeners.remove(</span>
<span class="lineno">  68 </span><span class="error">                gattObserver.uuid,</span>
<span class="lineno">  69 </span><span class="error">                gattObserver</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/SetInstrumentClockSequence.kt:21:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  18 </span>
<span class="lineno">  19 </span>    fun invoke(): Try&lt;Unit&gt; {
<span class="lineno">  20 </span>        val readResult = commProtocol.readDeviceClock()
<span class="lineno">  21 </span>        return <span class="error">when (readResult) {</span>
<span class="lineno">  22 </span><span class="error">            is Failure -&gt; Failure(readResult.e)</span>
<span class="lineno">  23 </span><span class="error">            is Success -&gt; checkAndSetClockAndReturnResult(readResult)</span>
<span class="lineno">  24 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCommProtocol.kt:66:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  63 </span>            uiSettings.getByteArray()
<span class="lineno">  64 </span>        )
<span class="lineno">  65 </span>
<span class="lineno">  66 </span>        return <span class="error">when (val writeResult = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(txFrame)) {</span>
<span class="lineno">  67 </span><span class="error">            is Failure -&gt; Failure(writeResult.e)</span>
<span class="lineno">  68 </span><span class="error">            is Success -&gt; Success(Unit)</span>
<span class="lineno">  69 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCommProtocol.kt:74:34</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  71 </span>
<span class="lineno">  72 </span>    @Suppress(&quot;ReturnCount&quot;)
<span class="lineno">  73 </span>    override fun readFwVersions(): Try&lt;HashMap&lt;FirmwareImageType, String&gt;&gt; {
<span class="lineno">  74 </span>        val bleFwVersionString = <span class="error">when (</span>
<span class="lineno">  75 </span><span class="error">            val bleVersionReadResult =</span>
<span class="lineno">  76 </span><span class="error">                CharacteristicReader(gattClient).read(gattProfile.btSigDisFirmwareRevisionChar)</span>
<span class="lineno">  77 </span><span class="error">        ) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCommProtocol.kt:82:30</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  79 </span>            is Success -&gt; String(bleVersionReadResult.value)
<span class="lineno">  80 </span>        }
<span class="lineno">  81 </span>
<span class="lineno">  82 </span>        val nameAndVersion = <span class="error">when (val nameAndVersionResult = readNameAndVersion()) {</span>
<span class="lineno">  83 </span><span class="error">            is Failure -&gt; return Failure(nameAndVersionResult.e)</span>
<span class="lineno">  84 </span><span class="error">            is Success -&gt; nameAndVersionResult.value</span>
<span class="lineno">  85 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCommProtocol.kt:99:26</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  96 </span>            ByteArray(16)
<span class="lineno">  97 </span>        )
<span class="lineno">  98 </span>
<span class="lineno">  99 </span>        val indication = <span class="error">when (val readResult = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(txFrame)) {</span>
<span class="lineno"> 100 </span><span class="error">            is Failure -&gt; return Failure(readResult.e)</span>
<span class="lineno"> 101 </span><span class="error">            is Success -&gt; DeviceDataTypes.ASRACPIndication(readResult.value)</span>
<span class="lineno"> 102 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCommProtocol.kt:109:62</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 106 </span>
<span class="lineno"> 107 </span>    @Suppress(&quot;ComplexMethod&quot;, &quot;ReturnCount&quot;) // Why? Predictable logic in this method, not complex at all.
<span class="lineno"> 108 </span>    override fun readSensorRecords(from: Date, to: Date, progress: CommProtocolProgress?): Try&lt;List&lt;BtSample&gt;&gt; {
<span class="lineno"> 109 </span>        val fwVersions: HashMap&lt;FirmwareImageType, String&gt; = <span class="error">when (val readFwVersionsResult = readFwVersions()) {</span>
<span class="lineno"> 110 </span><span class="error">            is Failure -&gt; return Failure(readFwVersionsResult.e)</span>
<span class="lineno"> 111 </span><span class="error">            is Success -&gt; readFwVersionsResult.value</span>
<span class="lineno"> 112 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCommProtocol.kt:114:24</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 111 </span>            is Success -&gt; readFwVersionsResult.value
<span class="lineno"> 112 </span>        }
<span class="lineno"> 113 </span>
<span class="lineno"> 114 </span>        val baseTime = <span class="error">when (val baseTimeResult = readBaseTime()) {</span>
<span class="lineno"> 115 </span><span class="error">            is Failure -&gt; return Failure(baseTimeResult.e)</span>
<span class="lineno"> 116 </span><span class="error">            is Success -&gt; baseTimeResult.value</span>
<span class="lineno"> 117 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCommProtocol.kt:119:29</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 116 </span>            is Success -&gt; baseTimeResult.value
<span class="lineno"> 117 </span>        }
<span class="lineno"> 118 </span>
<span class="lineno"> 119 </span>        val batteryStatus = <span class="error">when (val readBatteryStatusResult = readBatteryInfo()) {</span>
<span class="lineno"> 120 </span><span class="error">            is Failure -&gt; return Failure(readBatteryStatusResult.e)</span>
<span class="lineno"> 121 </span><span class="error">            is Success -&gt; readBatteryStatusResult.value</span>
<span class="lineno"> 122 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCommProtocol.kt:124:30</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 121 </span>            is Success -&gt; readBatteryStatusResult.value
<span class="lineno"> 122 </span>        }
<span class="lineno"> 123 </span>
<span class="lineno"> 124 </span>        val nameAndVersion = <span class="error">when (val nameAndVersionResult = readNameAndVersion()) {</span>
<span class="lineno"> 125 </span><span class="error">            is Failure -&gt; return Failure(nameAndVersionResult.e)</span>
<span class="lineno"> 126 </span><span class="error">            is Success -&gt; nameAndVersionResult.value</span>
<span class="lineno"> 127 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCommProtocol.kt:155:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 152 </span>            ByteArray(16)
<span class="lineno"> 153 </span>        )
<span class="lineno"> 154 </span>
<span class="lineno"> 155 </span>        return <span class="error">when (val ind = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(txFrame)) {</span>
<span class="lineno"> 156 </span><span class="error">            is Failure -&gt; Failure(ind.e)</span>
<span class="lineno"> 157 </span><span class="error">            is Success -&gt; Success(DeviceDataTypes.BatteryInfo(ind.value))</span>
<span class="lineno"> 158 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCommProtocol.kt:167:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 164 </span>            ByteArray(16)
<span class="lineno"> 165 </span>        )
<span class="lineno"> 166 </span>
<span class="lineno"> 167 </span>        return <span class="error">when (val result = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(txFrame)) {</span>
<span class="lineno"> 168 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno"> 169 </span><span class="error">                val readBackResponseOffset = 4</span>
<span class="lineno"> 170 </span><span class="error">                val baseTime1904 = buildUInt32(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCommProtocol.kt:195:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 192 </span>
<span class="lineno"> 193 </span>    override fun sendUiCommand(operation: UICommand.Operation): Try&lt;Unit&gt; {
<span class="lineno"> 194 </span>        val command = WaveUiCommand(operation)
<span class="lineno"> 195 </span>        return <span class="error">when (val result = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(command.getByteArray())) {</span>
<span class="lineno"> 196 </span><span class="error">            is Success -&gt; Success(Unit)</span>
<span class="lineno"> 197 </span><span class="error">            is Failure -&gt; Failure(result.e)</span>
<span class="lineno"> 198 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCommProtocol.kt:227:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 224 </span>            params
<span class="lineno"> 225 </span>        )
<span class="lineno"> 226 </span>
<span class="lineno"> 227 </span>        return <span class="error">when (val result = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(txFrame)) {</span>
<span class="lineno"> 228 </span><span class="error">            is Failure -&gt; Failure(result.e)</span>
<span class="lineno"> 229 </span><span class="error">            is Success -&gt; Success(Unit)</span>
<span class="lineno"> 230 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCommProtocol.kt:235:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 232 </span>
<span class="lineno"> 233 </span>    override fun readDeviceClock(): Try&lt;Long&gt; {
<span class="lineno"> 234 </span>        gattProfile as WaveGattProfile
<span class="lineno"> 235 </span>        return <span class="error">when (val result = CharacteristicReader(gattClient).read(gattProfile.currentSensorTimeChar)) {</span>
<span class="lineno"> 236 </span><span class="error">            is Success -&gt; Success(InstrumentDateTime().toDate(result.value).time)</span>
<span class="lineno"> 237 </span><span class="error">            is Failure -&gt; Failure(result.e)</span>
<span class="lineno"> 238 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCurrentValueReader.kt:46:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  43 </span>    }
<span class="lineno">  44 </span>
<span class="lineno">  45 </span>    private fun readRadonLtAvg(valueMap: HashMap&lt;RecordType, Float?&gt;): Try&lt;Unit&gt; {
<span class="lineno">  46 </span>        return <span class="error">when (val readResult = CharacteristicReader(gattClient).read(gattProfile.currentSensorRadonLongTermChar)) {</span>
<span class="lineno">  47 </span><span class="error">            is Failure -&gt; Failure(readResult.e)</span>
<span class="lineno">  48 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno">  49 </span><span class="error">                val currentRadonLongTermAvg = DeviceDataTypes.radonInSIFromCurrentCharacteristic(readResult.value)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCurrentValueReader.kt:57:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  54 </span>    }
<span class="lineno">  55 </span>
<span class="lineno">  56 </span>    private fun readRadon24hAvg(valueMap: HashMap&lt;RecordType, Float?&gt;): Try&lt;Unit&gt; {
<span class="lineno">  57 </span>        return <span class="error">when (val readResult = CharacteristicReader(gattClient).read(gattProfile.currentSensorRadonOneDayChar)) {</span>
<span class="lineno">  58 </span><span class="error">            is Failure -&gt; Failure(readResult.e)</span>
<span class="lineno">  59 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno">  60 </span><span class="error">                val currentRadonOneDayAvg = DeviceDataTypes.radonInSIFromCurrentCharacteristic(readResult.value)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCurrentValueReader.kt:68:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  65 </span>    }
<span class="lineno">  66 </span>
<span class="lineno">  67 </span>    private fun readHumidity(valueMap: HashMap&lt;RecordType, Float?&gt;): Try&lt;Unit&gt; {
<span class="lineno">  68 </span>        return <span class="error">when (val readResult = CharacteristicReader(gattClient).read(gattProfile.currentSensorHumidityChar)) {</span>
<span class="lineno">  69 </span><span class="error">            is Failure -&gt; Failure(readResult.e)</span>
<span class="lineno">  70 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno">  71 </span><span class="error">                val currentSensorSIHumidity = DeviceDataTypes.humidityInSIFromCurrentCharacteristic(readResult.value)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCurrentValueReader.kt:79:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  76 </span>    }
<span class="lineno">  77 </span>
<span class="lineno">  78 </span>    private fun readTemperature(valueMap: HashMap&lt;RecordType, Float?&gt;): Try&lt;Unit&gt; {
<span class="lineno">  79 </span>        return <span class="error">when (val readResult = CharacteristicReader(gattClient).read(gattProfile.currentSensorTemperatureChar)) {</span>
<span class="lineno">  80 </span><span class="error">            is Failure -&gt; Failure(readResult.e)</span>
<span class="lineno">  81 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno">  82 </span><span class="error">                val currentSensorSIHumidity = DeviceDataTypes.humidityInSIFromCurrentCharacteristic(readResult.value)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCurrentValueReader.kt:90:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  87 </span>    }
<span class="lineno">  88 </span>
<span class="lineno">  89 </span>    private fun readCombinedSensorValues(valueMap: HashMap&lt;RecordType, Float?&gt;): Try&lt;Unit&gt; {
<span class="lineno">  90 </span>        return <span class="error">when (val readResult = CharacteristicReader(gattClient).read(gattProfile.currentCombinedSensorsChar)) {</span>
<span class="lineno">  91 </span><span class="error">            is Failure -&gt; Failure(readResult.e)</span>
<span class="lineno">  92 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno">  93 </span><span class="error">                if (readResult.value.size != 2) return Failure(IllegalStateException(&quot;Error when reading current values from Wave. Response has wrong size.&quot;))</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveGetSensorSamplesSequence.kt:151:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 148 </span>        )
<span class="lineno"> 149 </span>
<span class="lineno"> 150 </span>        val response = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(txFrame)
<span class="lineno"> 151 </span>        return <span class="error">when (response) {</span>
<span class="lineno"> 152 </span><span class="error">            is Failure -&gt; -1</span>
<span class="lineno"> 153 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno"> 154 </span><span class="error">                val ind = DeviceDataTypes.ASRACPIndication(response.value)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveGetSensorSamplesSequence.kt:175:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 172 </span>            0
<span class="lineno"> 173 </span>        )
<span class="lineno"> 174 </span>        val response = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(txFrame)
<span class="lineno"> 175 </span>        return <span class="error">when (response) {</span>
<span class="lineno"> 176 </span><span class="error">            is Failure -&gt; -1</span>
<span class="lineno"> 177 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno"> 178 </span><span class="error">                val ind = DeviceDataTypes.ASRACPIndication(response.value)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveInstrument.kt:36:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  33 </span>    override fun connect(): Try&lt;Unit&gt; {
<span class="lineno">  34 </span>        val connectionResult = WaveConnectionSequence()
<span class="lineno">  35 </span>            .execute(scanResult.device, serialNumber, context, this)
<span class="lineno">  36 </span>        return <span class="error">when (connectionResult) {</span>
<span class="lineno">  37 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno">  38 </span><span class="error">                commProtocol = connectionResult.value</span>
<span class="lineno">  39 </span><span class="error">                Success(Unit)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveInstrument.kt:84:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  81 </span>
<span class="lineno">  82 </span>        val commProtocol = WaveCommProtocol(gattProfile, gattClient, onDisconnectListener)
<span class="lineno">  83 </span>
<span class="lineno">  84 </span>        return <span class="error">when (val setClockResult = SetInstrumentClockSequence(commProtocol).invoke()) {</span>
<span class="lineno">  85 </span><span class="error">            is Failure -&gt; Failure(setClockResult.e)</span>
<span class="lineno">  86 </span><span class="error">            is Success -&gt; Success(commProtocol)</span>
<span class="lineno">  87 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave2/Wave2CommProtocol.kt:28:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  25 </span>    fwVersions: HashMap&lt;FirmwareImageType, String&gt;
<span class="lineno">  26 </span>) : WavePlusCommProtocol(gattProfile, gattClient, onDisconnectListener, fwVersions) {
<span class="lineno">  27 </span>    override fun readCurrentValues(): Try&lt;HashMap&lt;RecordType, Float?&gt;&gt; =
<span class="lineno">  28 </span>        <span class="error">when (</span>
<span class="lineno">  29 </span><span class="error">            val readResult = CharacteristicReader(gattClient)</span>
<span class="lineno">  30 </span><span class="error">                .read((gattProfile as Wave2GattProfile)</span>
<span class="lineno">  31 </span><span class="error">                .currentValuesChar)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave2/Wave2Instrument.kt:41:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  38 </span>    override var scanResultData: ScanResultData = WaveScanResultData(scanResult)
<span class="lineno">  39 </span>
<span class="lineno">  40 </span>    override fun connect(): Try&lt;Unit&gt; {
<span class="lineno">  41 </span>        return <span class="error">when (val connectionResult = Wave2ConnectionSequence()</span>
<span class="lineno">  42 </span><span class="error">            .execute(scanResult.device, serialNumber, context, this)) {</span>
<span class="lineno">  43 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno">  44 </span><span class="error">                commProtocol = connectionResult.value</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave2/Wave2Instrument.kt:72:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  69 </span>            return Failure(discoverServicesResult.e)
<span class="lineno">  70 </span>        }
<span class="lineno">  71 </span>
<span class="lineno">  72 </span>        <span class="error">when (val setMtuResult = SetMtuOperation(gattClient).setMtu(ConfigurationManager.griffinMTUSize)) {</span>
<span class="lineno">  73 </span><span class="error">            // on failure log and continue</span>
<span class="lineno">  74 </span><span class="error">            is Failure -&gt; Log.e(TAG, &quot;Failed to set MTU&quot;, setMtuResult.e)</span>
<span class="lineno">  75 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave2/Wave2Instrument.kt:85:26</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  82 </span>            return Failure(indNotResult.e)
<span class="lineno">  83 </span>        }
<span class="lineno">  84 </span>
<span class="lineno">  85 </span>        val fwVersions = <span class="error">when (val result = GriffinFwReader.readFwVersions(gattProfile, gattClient)) {</span>
<span class="lineno">  86 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  87 </span><span class="error">            is Failure -&gt; {</span>
<span class="lineno">  88 </span><span class="error">                SimpleDisconnect(gattClient).disconnect()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/Merlin.kt:56:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  53 </span>    }
<span class="lineno">  54 </span>
<span class="lineno">  55 </span>    fun handleACPResponse(command: Byte, response: Try&lt;ByteArray&gt;): Try&lt;ByteArray&gt; {
<span class="lineno">  56 </span>        return <span class="error">when (response) {</span>
<span class="lineno">  57 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno">  58 </span><span class="error">                val data = response.value</span>
<span class="lineno">  59 </span><span class="error">                return if (data.size &lt; 2) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinBtSampleMaker.kt:53:13</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `RecordType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  50 </span>    private fun parseLatestRecordsIntoRecordMap(sensorRecords: List&lt;SensorRecord&gt;): HashMap&lt;RecordType, Float?&gt; {
<span class="lineno">  51 </span>        val recordMap = HashMap&lt;RecordType, Float?&gt;()
<span class="lineno">  52 </span>        loop@ for (record in sensorRecords) {
<span class="lineno">  53 </span>            <span class="error">when (record.recordType) {</span>
<span class="lineno">  54 </span><span class="error">                RecordType.TEMPERATURE_CELSIUS -&gt; recordMap[RecordType.TEMPERATURE_CELSIUS] = record.value?.toFloat()</span>
<span class="lineno">  55 </span><span class="error">                RecordType.HUMIDITY -&gt; recordMap[RecordType.HUMIDITY] = record.value?.toFloat()</span>
<span class="lineno">  56 </span><span class="error">                RecordType.VOC_LEVEL -&gt; recordMap[RecordType.VOC_LEVEL] = record.value?.toFloat()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinDatasetInfoParser.kt:19:29</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  16 </span>        if (validationResult is Failure) return Failure(validationResult.e)
<span class="lineno">  17 </span>
<span class="lineno">  18 </span>        val sub1FwVersionResult = getSub1FwVersion(params)
<span class="lineno">  19 </span>        val sub1FwVersion = <span class="error">when (sub1FwVersionResult) {</span>
<span class="lineno">  20 </span><span class="error">            is Failure -&gt; return Failure(sub1FwVersionResult.e)</span>
<span class="lineno">  21 </span><span class="error">            is Success -&gt; sub1FwVersionResult.value</span>
<span class="lineno">  22 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinSensorRecordsReader.kt:123:31</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 120 </span>            currentOffset = nextOffset
<span class="lineno"> 121 </span>
<span class="lineno"> 122 </span>            val command = byteArrayOf(Merlin.Opcode.GET_DATASET_INFO, nextOffset++)
<span class="lineno"> 123 </span>            val datasetInfo = <span class="error">when (val readAndParseResult = readAndParseDatasetInfo(command)) {</span>
<span class="lineno"> 124 </span><span class="error">                is Success -&gt; readAndParseResult.value</span>
<span class="lineno"> 125 </span><span class="error">                is Failure -&gt; return dataSetOffsetsToReadFrom</span>
<span class="lineno"> 126 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinSensorRecordsReader.kt:147:26</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 144 </span>
<span class="lineno"> 145 </span>        val datasetInfoResponse = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(command)
<span class="lineno"> 146 </span>
<span class="lineno"> 147 </span>        rawDatasetInfo = <span class="error">when (datasetInfoResponse) {</span>
<span class="lineno"> 148 </span><span class="error">            is Success -&gt; datasetInfoResponse.value</span>
<span class="lineno"> 149 </span><span class="error">            is Failure -&gt; return Failure(datasetInfoResponse.e)</span>
<span class="lineno"> 150 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinSensorRecordsReader.kt:159:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 156 </span>
<span class="lineno"> 157 </span>    fun readCurrentRecord(): Try&lt;HashMap&lt;RecordType, Float?&gt;&gt; {
<span class="lineno"> 158 </span>
<span class="lineno"> 159 </span>        return <span class="error">when (val currentBlockResult = readBlocksFromDataset(MerlinGetSamplesCommandCreator().makeGetCurrentRecordCommand())) {</span>
<span class="lineno"> 160 </span><span class="error">            is Failure -&gt; Failure(currentBlockResult.e)</span>
<span class="lineno"> 161 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno"> 162 </span><span class="error">                val currentBlock = currentBlockResult.value.lastOrNull()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinSetClockSequence.kt:24:37</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  21 </span>
<span class="lineno">  22 </span>    fun invoke(): Try&lt;Unit&gt; {
<span class="lineno">  23 </span>        var selfCheckResult = SelfCheckSummaryReader(gattClient, gattProfile).invoke()
<span class="lineno">  24 </span>        var currentInstrumentTime = <span class="error">when (selfCheckResult) {</span>
<span class="lineno">  25 </span><span class="error">            is Failure -&gt; return Failure(selfCheckResult.e)</span>
<span class="lineno">  26 </span><span class="error">            is Success -&gt; selfCheckResult.value.systemTime</span>
<span class="lineno">  27 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinSetClockSequence.kt:38:33</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  35 </span>        if (setCLockResult is Failure) return Failure(setCLockResult.e)
<span class="lineno">  36 </span>
<span class="lineno">  37 </span>        selfCheckResult = SelfCheckSummaryReader(gattClient, gattProfile).invoke()
<span class="lineno">  38 </span>        currentInstrumentTime = <span class="error">when (selfCheckResult) {</span>
<span class="lineno">  39 </span><span class="error">            is Failure -&gt; return Failure(selfCheckResult.e)</span>
<span class="lineno">  40 </span><span class="error">            is Success -&gt; selfCheckResult.value.systemTime</span>
<span class="lineno">  41 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinSetClockSequence.kt:55:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  52 </span>            getSystemTimeAsByteArray(systemTimeInSeconds = System.currentTimeMillis() / 1000L)
<span class="lineno">  53 </span>        )
<span class="lineno">  54 </span>        val writeResult = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(params)
<span class="lineno">  55 </span>        return <span class="error">when (writeResult) {</span>
<span class="lineno">  56 </span><span class="error">            is Success -&gt; Success(Unit)</span>
<span class="lineno">  57 </span><span class="error">            is Failure -&gt; Failure(writeResult.e)</span>
<span class="lineno">  58 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinUISettingsReader.kt:17:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  14 </span>        val result = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(
<span class="lineno">  15 </span>            byteArrayOf(Merlin.Opcode.UI_SETTINGS, Merlin.UISettingsCommand.GET)
<span class="lineno">  16 </span>        )
<span class="lineno">  17 </span>        return <span class="error">when (result) {</span>
<span class="lineno">  18 </span><span class="error">            is Failure -&gt; Failure(result.e)</span>
<span class="lineno">  19 </span><span class="error">            is Success -&gt; MerlinUiSettingsBuilder().buildFromByteArray(result.value)</span>
<span class="lineno">  20 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinUISettingsWriter.kt:22:26</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  19 </span>    }
<span class="lineno">  20 </span>
<span class="lineno">  21 </span>    private fun checkAndWrite(uiSettings: UISettings): Try&lt;Unit&gt; {
<span class="lineno">  22 </span>        val isUpToDate = <span class="error">when (val isUpToDateCheck = isUpToDateCheck(uiSettings)) {</span>
<span class="lineno">  23 </span><span class="error">            is Failure -&gt; return Failure(isUpToDateCheck.e)</span>
<span class="lineno">  24 </span><span class="error">            is Success -&gt; isUpToDateCheck.value</span>
<span class="lineno">  25 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinUISettingsWriter.kt:36:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  33 </span>
<span class="lineno">  34 </span>    private fun performWriteOperation(uiSettings: UISettings): Try&lt;Unit&gt; {
<span class="lineno">  35 </span>        val writeUiSettingsCommand = makeCommandWithHeader(uiSettings.getByteArray())
<span class="lineno">  36 </span>        return <span class="error">when (val result = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(writeUiSettingsCommand)) {</span>
<span class="lineno">  37 </span><span class="error">            is Success -&gt; Success(Unit)</span>
<span class="lineno">  38 </span><span class="error">            is Failure -&gt; Failure(result.e)</span>
<span class="lineno">  39 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinUISettingsWriter.kt:49:33</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  46 </span>     * Ref. Unknown source.
<span class="lineno">  47 </span>     */
<span class="lineno">  48 </span>    private fun isUpToDateCheck(newUiSettings: UISettings): Try&lt;Boolean&gt; {
<span class="lineno">  49 </span>        val currentUiSettings = <span class="error">when (val result = MerlinUISettingsReader(gattClient, gattProfile).readUISettings()) {</span>
<span class="lineno">  50 </span><span class="error">            is Failure -&gt; return Failure(result.e)</span>
<span class="lineno">  51 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  52 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/RFRegion.kt:23:44</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Region`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  20 </span> */
<span class="lineno">  21 </span>internal val NO_REGION = byteArrayOf(0x02, 0x00)
<span class="lineno">  22 </span>
<span class="lineno">  23 </span>internal fun Region.getMerlinByteArray() = <span class="error">when (this) {</span>
<span class="lineno">  24 </span><span class="error">    Region.EUROPE -&gt; EUROPE_BYTES</span>
<span class="lineno">  25 </span><span class="error">    Region.NORTH_AMERICA -&gt; NORTH_AMERICA_BYTES</span>
<span class="lineno">  26 </span><span class="error">    Region.UNDEFINED -&gt; NO_REGION</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/SelfCheckSummaryReader.kt:15:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  12 </span>    fun invoke(): Try&lt;MerlinSelfCheckSummary&gt; {
<span class="lineno">  13 </span>        val result = ASRACP(gattClient, gattProfile)
<span class="lineno">  14 </span>            .writeBlockingUntilResponse(byteArrayOf(Merlin.Opcode.SELF_CHECK))
<span class="lineno">  15 </span>        return <span class="error">when (result) {</span>
<span class="lineno">  16 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno">  17 </span><span class="error">                val value = result.value</span>
<span class="lineno">  18 </span><span class="error">                MerlinSelfCheckSummaryParser().parseFromSelfCheckResult(value)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniCommProtocol.kt:59:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  56 </span>                command[0],
<span class="lineno">  57 </span>                ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(command)
<span class="lineno">  58 </span>            )
<span class="lineno">  59 </span>            <span class="error">when (result) {</span>
<span class="lineno">  60 </span><span class="error">                is Success -&gt; Success(Unit)</span>
<span class="lineno">  61 </span><span class="error">                is Failure -&gt; Failure(result.e)</span>
<span class="lineno">  62 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniCommProtocol.kt:72:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  69 </span>        Failure(RuntimeException(&quot;setColorRing has not yet been implemented.&quot;))
<span class="lineno">  70 </span>
<span class="lineno">  71 </span>    override fun readDeviceClock(): Try&lt;Long&gt; =
<span class="lineno">  72 </span>        <span class="error">when (val selfCheckResult = SelfCheckSummaryReader(gattClient, gattProfile).invoke()) {</span>
<span class="lineno">  73 </span><span class="error">            is Failure -&gt; Failure(selfCheckResult.e)</span>
<span class="lineno">  74 </span><span class="error">            is Success -&gt; Success(selfCheckResult.value.systemTime)</span>
<span class="lineno">  75 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniCommProtocol.kt:78:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  75 </span>        }
<span class="lineno">  76 </span>
<span class="lineno">  77 </span>    override fun readRfRegion(): Try&lt;Region&gt; =
<span class="lineno">  78 </span>        <span class="error">when (val selfCheckResult = SelfCheckSummaryReader(gattClient, gattProfile).invoke()) {</span>
<span class="lineno">  79 </span><span class="error">            is Success -&gt; selfCheckResult.value.getRegion()</span>
<span class="lineno">  80 </span><span class="error">            is Failure -&gt; Failure(selfCheckResult.e)</span>
<span class="lineno">  81 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniCommProtocol.kt:84:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  81 </span>        }
<span class="lineno">  82 </span>
<span class="lineno">  83 </span>    override fun writeRfRegion(region: Region): Try&lt;Region&gt; =
<span class="lineno">  84 </span>        <span class="error">when (val response = MerlinRegionWriter(gattClient, gattProfile).writeRegion(region)) {</span>
<span class="lineno">  85 </span><span class="error">            is Success -&gt; Success(region)</span>
<span class="lineno">  86 </span><span class="error">            is Failure -&gt; Failure(response.e)</span>
<span class="lineno">  87 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniFwVersionReader.kt:14:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  11 </span>internal class WaveMiniFwVersionReader(val gattClient: GattClient, val gattProfile: AtGattProfile) {
<span class="lineno">  12 </span>    fun readFwVersions(): Try&lt;HashMap&lt;FirmwareImageType, String&gt;&gt; {
<span class="lineno">  13 </span>        val summaryResult = SelfCheckSummaryReader(gattClient, gattProfile).invoke()
<span class="lineno">  14 </span>        return <span class="error">when (summaryResult) {</span>
<span class="lineno">  15 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno">  16 </span><span class="error">                val fwVersionMap = HashMap&lt;FirmwareImageType, String&gt;()</span>
<span class="lineno">  17 </span><span class="error">                fwVersionMap[FirmwareImageType.BLE] = summaryResult.value.fwVersion</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniGattProfile.kt:37:31</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  34 </span>    override var btSigDisFirmwareRevisionChar: BluetoothGattCharacteristic =
<span class="lineno">  35 </span>        deviceInfoService.getCharacteristic(UUID.fromString(DeviceDefines.BTSIGDISFWRevCharUUIDString))
<span class="lineno">  36 </span>
<span class="lineno">  37 </span>    val oad: OadGattProfile = <span class="error">when (val result = OadGattProfile.tryInit(gattClient)) {</span>
<span class="lineno">  38 </span><span class="error">        is Success -&gt; result.value</span>
<span class="lineno">  39 </span><span class="error">        is Failure -&gt; throw result.e</span>
<span class="lineno">  40 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniInstrument.kt:37:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  34 </span>    override fun connect(): Try&lt;Unit&gt; {
<span class="lineno">  35 </span>        val connectionResult =
<span class="lineno">  36 </span>            WaveMiniConnectionSequence().execute(scanResult.device, serialNumber, context, this)
<span class="lineno">  37 </span>        return <span class="error">when (connectionResult) {</span>
<span class="lineno">  38 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno">  39 </span><span class="error">                commProtocol = connectionResult.value</span>
<span class="lineno">  40 </span><span class="error">                Success(Unit)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniInstrument.kt:103:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 100 </span>            SimpleDisconnect(gattClient).disconnect()
<span class="lineno"> 101 </span>            return Failure(discoverServicesResult.e)
<span class="lineno"> 102 </span>        }
<span class="lineno"> 103 </span>        <span class="error">when (val setMtuResult = SetMtuOperation(gattClient).setMtu(255)) {</span>
<span class="lineno"> 104 </span><span class="error">            // on failure log and continue</span>
<span class="lineno"> 105 </span><span class="error">            is Failure -&gt; Log.e(TAG, &quot;Failed to set MTU&quot;, setMtuResult.e)</span>
<span class="lineno"> 106 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniInstrument.kt:108:42</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 105 </span>            is Failure -&gt; Log.e(TAG, &quot;Failed to set MTU&quot;, setMtuResult.e)
<span class="lineno"> 106 </span>        }
<span class="lineno"> 107 </span>
<span class="lineno"> 108 </span>        val gattProfile: AtGattProfile = <span class="error">when (val result = WaveMiniGattProfile.tryInit(gattClient)) {</span>
<span class="lineno"> 109 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno"> 110 </span><span class="error">            is Failure -&gt; {</span>
<span class="lineno"> 111 </span><span class="error">                SimpleDisconnect(gattClient).disconnect()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/CommandFactory.kt:20:35</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  17 </span>    override fun getCommand(fwVersions: HashMap&lt;FirmwareImageType, String&gt;, request: Any?): Try&lt;ByteArray&gt; {
<span class="lineno">  18 </span>        val instrumentVersion =
<span class="lineno">  19 </span>            fwVersions[FirmwareImageType.BLE] ?: return Failure(IllegalArgumentException(&quot;Image type BLE was null.&quot;))
<span class="lineno">  20 </span>        val requiresPassThrough = <span class="error">when (val result = requiresPassThrough(instrumentVersion)) {</span>
<span class="lineno">  21 </span><span class="error">            is Failure -&gt; return Failure(result.e)</span>
<span class="lineno">  22 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  23 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/CommandFactory.kt:39:35</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  36 </span>    override fun getCommand(fwVersions: HashMap&lt;FirmwareImageType, String&gt;, request: Request): Try&lt;ByteArray&gt; {
<span class="lineno">  37 </span>        val instrumentVersion =
<span class="lineno">  38 </span>            fwVersions[FirmwareImageType.BLE] ?: return Failure(IllegalArgumentException(&quot;Image type BLE was null.&quot;))
<span class="lineno">  39 </span>        val requiresPassThrough = <span class="error">when (val result = requiresPassThrough(instrumentVersion)) {</span>
<span class="lineno">  40 </span><span class="error">            is Failure -&gt; return Failure(result.e)</span>
<span class="lineno">  41 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  42 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/CommandFactory.kt:79:35</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  76 </span>    override fun getCommand(fwVersions: HashMap&lt;FirmwareImageType, String&gt;, request: Request): Try&lt;ByteArray&gt; {
<span class="lineno">  77 </span>        val ccFwVersion =
<span class="lineno">  78 </span>            fwVersions[FirmwareImageType.BLE] ?: return Failure(IllegalArgumentException(&quot;Image type BLE was null.&quot;))
<span class="lineno">  79 </span>        val requiresPassThrough = <span class="error">when (val result = requiresPassThrough(ccFwVersion)) {</span>
<span class="lineno">  80 </span><span class="error">            is Failure -&gt; return Failure(result.e)</span>
<span class="lineno">  81 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  82 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/DataSetInfo.kt:128:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 125 </span>    }
<span class="lineno"> 126 </span>
<span class="lineno"> 127 </span>    fun numberOfHoursInRange(from: Date, to: Date): Int {
<span class="lineno"> 128 </span>        return <span class="error">when (val getRangeResult = getIntersectingTimeRange(from, to)) {</span>
<span class="lineno"> 129 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno"> 130 </span><span class="error">                val duration = getRangeResult.value.endInclusive.time - getRangeResult.value.start.time</span>
<span class="lineno"> 131 </span><span class="error">                TimeUnit.MILLISECONDS.toHours(duration).toInt()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/GriffinClockReader.kt:24:23</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  21 </span>        gattProfile: AtGattProfile,
<span class="lineno">  22 </span>        fwVersions: HashMap&lt;FirmwareImageType, String&gt;
<span class="lineno">  23 </span>    ): Try&lt;Long&gt; {
<span class="lineno">  24 </span>        val command = <span class="error">when (val result = ReadInstrumentClockCmdFactory().getCommand(fwVersions, null)) {</span>
<span class="lineno">  25 </span><span class="error">            is Failure -&gt; return Failure(result.e)</span>
<span class="lineno">  26 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  27 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/GriffinClockReader.kt:29:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  26 </span>            is Success -&gt; result.value
<span class="lineno">  27 </span>        }
<span class="lineno">  28 </span>
<span class="lineno">  29 </span>        return <span class="error">when (val result = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(command)) {</span>
<span class="lineno">  30 </span><span class="error">            is Failure -&gt; Failure(IOException(&quot;ReadDeviceClock failed: ${result.e.message}&quot;, result.e))</span>
<span class="lineno">  31 </span><span class="error">            is Success -&gt; validateAndParse(result.value)</span>
<span class="lineno">  32 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/GriffinClockSetter.kt:32:23</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  29 </span>
<span class="lineno">  30 </span>        val setInstrumentClockCmdFactory = SetInstrumentClockCmdFactory()
<span class="lineno">  31 </span>        val request = SetInstrumentClockCmdFactory.Request(secondsSince1970)
<span class="lineno">  32 </span>        val command = <span class="error">when (val result = setInstrumentClockCmdFactory.getCommand(fwVersions, request)) {</span>
<span class="lineno">  33 </span><span class="error">            is Failure -&gt; return Failure(result.e)</span>
<span class="lineno">  34 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  35 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/GriffinClockSetter.kt:37:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  34 </span>            is Success -&gt; result.value
<span class="lineno">  35 </span>        }
<span class="lineno">  36 </span>
<span class="lineno">  37 </span>        return <span class="error">when (val result = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(command)) {</span>
<span class="lineno">  38 </span><span class="error">            is Success -&gt; Success(Unit)</span>
<span class="lineno">  39 </span><span class="error">            is Failure -&gt; Failure(result.e)</span>
<span class="lineno">  40 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/GriffinUISettingsReader.kt:15:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  12 </span>internal class GriffinUISettingsReader(val gattClient: GattClient, val gattProfile: AtGattProfile) {
<span class="lineno">  13 </span>    fun readUiSettings(): Try&lt;UISettings&gt; {
<span class="lineno">  14 </span>        val commandParams = byteArrayOf(GriffinCmd.UI_SETTINGS.code, Griffin.UISettingsCommand.GET.code)
<span class="lineno">  15 </span>        return <span class="error">when (val result = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(commandParams)) {</span>
<span class="lineno">  16 </span><span class="error">            is Failure -&gt; Failure(result.e)</span>
<span class="lineno">  17 </span><span class="error">            is Success -&gt; tryParseUiSettings(result)</span>
<span class="lineno">  18 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/GriffinUISettingsReader.kt:22:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  19 </span>    }
<span class="lineno">  20 </span>
<span class="lineno">  21 </span>    private fun tryParseUiSettings(result: Success&lt;ByteArray&gt;): Try&lt;UISettings&gt; {
<span class="lineno">  22 </span>        return <span class="error">when (val buildResult = WavePlusUiSettings.buildFromAsracpResponse(result.value)) {</span>
<span class="lineno">  23 </span><span class="error">            is Success -&gt; Success(buildResult.value)</span>
<span class="lineno">  24 </span><span class="error">            is Failure -&gt; Failure(buildResult.e)</span>
<span class="lineno">  25 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/GriffinUISettingsWriter.kt:25:26</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  22 </span>    }
<span class="lineno">  23 </span>
<span class="lineno">  24 </span>    private fun checkAndWrite(uiSettings: UISettings): Try&lt;Unit&gt; {
<span class="lineno">  25 </span>        val isUpToDate = <span class="error">when (val isUpToDateCheck = isUpToDateCheck(uiSettings)) {</span>
<span class="lineno">  26 </span><span class="error">            is Failure -&gt; return Failure(isUpToDateCheck.e)</span>
<span class="lineno">  27 </span><span class="error">            is Success -&gt; isUpToDateCheck.value</span>
<span class="lineno">  28 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/GriffinUISettingsWriter.kt:39:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  36 </span>
<span class="lineno">  37 </span>    private fun write(uiSettings: UISettings): Try&lt;Unit&gt; {
<span class="lineno">  38 </span>        val writeUiSettingsCommand = makeWriteUiSettingsCommand(uiSettings)
<span class="lineno">  39 </span>        return <span class="error">when (val result = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(writeUiSettingsCommand)) {</span>
<span class="lineno">  40 </span><span class="error">            is Success -&gt; Success(Unit)</span>
<span class="lineno">  41 </span><span class="error">            is Failure -&gt; Failure(result.e)</span>
<span class="lineno">  42 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/GriffinUISettingsWriter.kt:53:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  50 </span>     */
<span class="lineno">  51 </span>    private fun isUpToDateCheck(newUiSettings: UISettings): Try&lt;Boolean&gt; {
<span class="lineno">  52 </span>        val currentUiSettings =
<span class="lineno">  53 </span>            <span class="error">when (val readResult = GriffinUISettingsReader(gattClient, gattProfile).readUiSettings()) {</span>
<span class="lineno">  54 </span><span class="error">                is Failure -&gt; return Failure(readResult.e)</span>
<span class="lineno">  55 </span><span class="error">                is Success -&gt; readResult.value</span>
<span class="lineno">  56 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/ReadDataSetInfo.kt:27:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  24 </span>    ): Try&lt;DataSetInfo&gt; {
<span class="lineno">  25 </span>        val request = GetDatasetInfoCmdFactory.Request(dataSetOffset)
<span class="lineno">  26 </span>        val command: ByteArray =
<span class="lineno">  27 </span>            <span class="error">when (val result = GetDatasetInfoCmdFactory().getCommand(fwVersions, request)) {</span>
<span class="lineno">  28 </span><span class="error">                is Failure -&gt; return Failure(result.e)</span>
<span class="lineno">  29 </span><span class="error">                is Success -&gt; result.value</span>
<span class="lineno">  30 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/ReadDataSetInfo.kt:32:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  29 </span>                is Success -&gt; result.value
<span class="lineno">  30 </span>            }
<span class="lineno">  31 </span>
<span class="lineno">  32 </span>        return <span class="error">when (val datasetInfoResult =</span>
<span class="lineno">  33 </span><span class="error">            ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(command)) {</span>
<span class="lineno">  34 </span><span class="error">            is Failure -&gt; Failure(datasetInfoResult.e)</span>
<span class="lineno">  35 </span><span class="error">            is Success -&gt; ToDataSetInfo().invoke(datasetInfoResult.value)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/ReadSensorSampleSequence.kt:45:32</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  42 </span>        val setClockResult = SetClockSequence(gattClient, gattProfile, fwVersions).setAndCheckClockWasSet()
<span class="lineno">  43 </span>        if (setClockResult is Failure) return Failure(setClockResult.e)
<span class="lineno">  44 </span>        progress?.invoke(1, totalSteps)
<span class="lineno">  45 </span>        val selfCheckSummary = <span class="error">when (val selfCheckSummaryResult = getSelfCheckSummary()) {</span>
<span class="lineno">  46 </span><span class="error">            is Failure -&gt; return Failure(selfCheckSummaryResult.e)</span>
<span class="lineno">  47 </span><span class="error">            is Success -&gt; selfCheckSummaryResult.value</span>
<span class="lineno">  48 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/ReadSensorSampleSequence.kt:50:28</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  47 </span>            is Success -&gt; selfCheckSummaryResult.value
<span class="lineno">  48 </span>        }
<span class="lineno">  49 </span>        progress?.invoke(2, totalSteps)
<span class="lineno">  50 </span>        val bleFwVersion = <span class="error">when (val bleFwVersionResult = CCFwImageVersionReader(gattClient, gattProfile).invoke()) {</span>
<span class="lineno">  51 </span><span class="error">            is Failure -&gt; return Failure(bleFwVersionResult.e)</span>
<span class="lineno">  52 </span><span class="error">            is Success -&gt; bleFwVersionResult.value</span>
<span class="lineno">  53 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/ReadSensorSampleSequence.kt:69:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  66 </span>    private fun hasNoNewSamples(from: Long) = System.currentTimeMillis() - 1L.hoursToMilliseconds() &lt; from
<span class="lineno">  67 </span>
<span class="lineno">  68 </span>    private fun getSelfCheckSummary(): Try&lt;SelfCheckSummary&gt; {
<span class="lineno">  69 </span>        return <span class="error">when (val result =</span>
<span class="lineno">  70 </span><span class="error">            ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(byteArrayOf(SELF_CHECK_COMMAND))) {</span>
<span class="lineno">  71 </span><span class="error">            is Success -&gt; SelfCheckSummaryParser().parse(result.value)</span>
<span class="lineno">  72 </span><span class="error">            is Failure -&gt; Failure(result.e)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/ReadSensorSampleSequence.kt:121:31</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 118 </span>            currentOffset = nextOffset
<span class="lineno"> 119 </span>
<span class="lineno"> 120 </span>            val readRequest = ReadDataSetInfo.ReadRequest(nextOffset++, gattClient, gattProfile, fwVersions)
<span class="lineno"> 121 </span>            val dataSetInfo = <span class="error">when (val result = ReadDataSetInfo.read(readRequest)) {</span>
<span class="lineno"> 122 </span><span class="error">                is Success -&gt; result.value</span>
<span class="lineno"> 123 </span><span class="error">                is Failure -&gt; {</span>
<span class="lineno"> 124 </span><span class="error">                    reportError(nextOffset, earliestValidBaseTime, result)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/ReadSensorSampleSequence.kt:197:23</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 194 </span>            }
<span class="lineno"> 195 </span>        }
<span class="lineno"> 196 </span>
<span class="lineno"> 197 </span>        val command = <span class="error">when (val getCommandResult = getRecordsCommand(hoursToGet, dataSetOffset, dataSetInfo)) {</span>
<span class="lineno"> 198 </span><span class="error">            is Success -&gt; getCommandResult.value</span>
<span class="lineno"> 199 </span><span class="error">            is Failure -&gt; {</span>
<span class="lineno"> 200 </span><span class="error">                logError(getCommandResult.e)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/ReadSensorSampleSequence.kt:273:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `RangeCode`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 270 </span>    }
<span class="lineno"> 271 </span>
<span class="lineno"> 272 </span>    private fun rangeCode(rangeCode: RangeCode): Byte {
<span class="lineno"> 273 </span>        return <span class="error">when (rangeCode) {</span>
<span class="lineno"> 274 </span><span class="error">            RangeCode.ALL_RECORDS -&gt; 1</span>
<span class="lineno"> 275 </span><span class="error">            RangeCode.ALL_RECORDS_YOUNGER_THAN_N_HOURS -&gt; 2</span>
<span class="lineno"> 276 </span><span class="error">            RangeCode.ALL_RECORDS_ABOVE -&gt; 3</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/SetClockSequence.kt:29:27</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  26 </span>            return Failure(IOException(failedToSetClockMainMessage, setClockResult.e))
<span class="lineno">  27 </span>        }
<span class="lineno">  28 </span>
<span class="lineno">  29 </span>        val datasetInfo = <span class="error">when (val result = getDataSetInfoWithRetries()) {</span>
<span class="lineno">  30 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  31 </span><span class="error">            is Failure -&gt; return Failure(IOException(failedToSetClockMainMessage, result.e))</span>
<span class="lineno">  32 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/VersionComparator.kt:39:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  36 </span>    }
<span class="lineno">  37 </span>
<span class="lineno">  38 </span>    fun isBefore(versionStringB: String): Boolean {
<span class="lineno">  39 </span>        return <span class="error">when (val tryIsBeforeResult = tryIsBefore(versionStringB)) {</span>
<span class="lineno">  40 </span><span class="error">            is Success -&gt; tryIsBeforeResult.value</span>
<span class="lineno">  41 </span><span class="error">            is Failure -&gt; false</span>
<span class="lineno">  42 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/VersionComparator.kt:80:20</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `SemanticVersion`, `DateVersion`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  77 </span>        }
<span class="lineno">  78 </span>
<span class="lineno">  79 </span>        override fun isBefore(version: Version): Boolean {
<span class="lineno">  80 </span>            return <span class="error">when (version) {</span>
<span class="lineno">  81 </span><span class="error">                is DateVersion -&gt; false</span>
<span class="lineno">  82 </span><span class="error">                is SemanticVersion -&gt; compareSemanticVersions(version)</span>
<span class="lineno">  83 </span><span class="error">                else -&gt; false</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/VersionComparator.kt:100:20</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `SemanticVersion`, `DateVersion`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  97 </span>        val versionDate: Date? = simpleDateFormat.parse(versionString)
<span class="lineno">  98 </span>
<span class="lineno">  99 </span>        override fun isBefore(version: Version): Boolean {
<span class="lineno"> 100 </span>            return <span class="error">when (version) {</span>
<span class="lineno"> 101 </span><span class="error">                is DateVersion -&gt; versionDate?.before(version.versionDate) ?: false</span>
<span class="lineno"> 102 </span><span class="error">                is SemanticVersion -&gt; true</span>
<span class="lineno"> 103 </span><span class="error">                else -&gt; false</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/WavePlusCommProtocol.kt:43:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  40 </span>) : AtCommProtocol2(gattProfile, gattClient, onDisconnectListener) {
<span class="lineno">  41 </span>
<span class="lineno">  42 </span>    override fun readCurrentValues(): Try&lt;HashMap&lt;RecordType, Float?&gt;&gt; =
<span class="lineno">  43 </span>        <span class="error">when (val readResult =</span>
<span class="lineno">  44 </span><span class="error">            CharacteristicReader(gattClient).read((gattProfile as WavePlusGattProfile).currentValuesChar)) {</span>
<span class="lineno">  45 </span><span class="error">            is Failure -&gt; Failure(readResult.e)</span>
<span class="lineno">  46 </span><span class="error">            is Success -&gt; CurrentValuesParser().parseCurrentValuesIntoValueMap(readResult.value)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/WavePlusCommProtocol.kt:65:22</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  62 </span>        ).invoke(from, to, progress)
<span class="lineno">  63 </span>
<span class="lineno">  64 </span>    override fun readBaseTime(): Try&lt;Date&gt; {
<span class="lineno">  65 </span>        val uptime = <span class="error">when (val selfCheckSummaryResult = getSelfCheckSummary()) {</span>
<span class="lineno">  66 </span><span class="error">            is Success -&gt; selfCheckSummaryResult.value.uptime</span>
<span class="lineno">  67 </span><span class="error">            is Failure -&gt; return Failure(selfCheckSummaryResult.e)</span>
<span class="lineno">  68 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/WavePlusCommProtocol.kt:73:23</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  70 </span>        Thread.sleep(100) // Reading dataset info may fail without this delay.
<span class="lineno">  71 </span>
<span class="lineno">  72 </span>        val request = GetDatasetInfoCmdFactory.Request(0x00)
<span class="lineno">  73 </span>        val command = <span class="error">when (val getCommandResult = GetDatasetInfoCmdFactory().getCommand(fwVersions, request)) {</span>
<span class="lineno">  74 </span><span class="error">            is Success -&gt; getCommandResult.value</span>
<span class="lineno">  75 </span><span class="error">            is Failure -&gt; return Failure(getCommandResult.e)</span>
<span class="lineno">  76 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/WavePlusCommProtocol.kt:78:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  75 </span>            is Failure -&gt; return Failure(getCommandResult.e)
<span class="lineno">  76 </span>        }
<span class="lineno">  77 </span>
<span class="lineno">  78 </span>        return <span class="error">when (val result =</span>
<span class="lineno">  79 </span><span class="error">            ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(command)) {</span>
<span class="lineno">  80 </span><span class="error">            is Success -&gt; readDatasetInfoAndParseBaseTime(result, uptime)</span>
<span class="lineno">  81 </span><span class="error">            is Failure -&gt; Failure(result.e)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/WavePlusCommProtocol.kt:88:20</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  85 </span>    private fun readDatasetInfoAndParseBaseTime(
<span class="lineno">  86 </span>        result: Success&lt;ByteArray&gt;,
<span class="lineno">  87 </span>        uptime: Long
<span class="lineno">  88 </span>    ): Try&lt;Date&gt; = <span class="error">when (val toDataSetInfoResult = ToDataSetInfo().invoke(result.value)) {</span>
<span class="lineno">  89 </span><span class="error">        is Failure -&gt; Failure(toDataSetInfoResult.e)</span>
<span class="lineno">  90 </span><span class="error">        is Success -&gt; Success(Date(</span>
<span class="lineno">  91 </span><span class="error">            inferBaseTimeMillis(System.currentTimeMillis(), uptime, toDataSetInfoResult.value.recordCount)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/WavePlusCommProtocol.kt:98:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  95 </span>    private fun getSelfCheckSummary(): Try&lt;SelfCheckSummary&gt; {
<span class="lineno">  96 </span>        val result = ASRACP(gattClient, gattProfile)
<span class="lineno">  97 </span>            .writeBlockingUntilResponse(byteArrayOf(SELF_CHECK_COMMAND))
<span class="lineno">  98 </span>        return <span class="error">when (result) {</span>
<span class="lineno">  99 </span><span class="error">            is Success -&gt; SelfCheckSummaryParser().parse(result.value)</span>
<span class="lineno"> 100 </span><span class="error">            is Failure -&gt; Failure(result.e)</span>
<span class="lineno"> 101 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/WavePlusCommProtocol.kt:120:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 117 </span>
<span class="lineno"> 118 </span>    override fun sendUiCommand(operation: UICommand.Operation): Try&lt;Unit&gt; {
<span class="lineno"> 119 </span>        val uiCommand = WavePlusUiCommand(operation)
<span class="lineno"> 120 </span>        return <span class="error">when (val result =</span>
<span class="lineno"> 121 </span><span class="error">            ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(uiCommand.getByteArray())) {</span>
<span class="lineno"> 122 </span><span class="error">            is Success -&gt; Success(Unit)</span>
<span class="lineno"> 123 </span><span class="error">            is Failure -&gt; Failure(result.e)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/WavePlusInstrument.kt:40:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  37 </span>    override var scanResultData: ScanResultData = GriffinScanResultData(scanResult)
<span class="lineno">  38 </span>
<span class="lineno">  39 </span>    override fun connect(): Try&lt;Unit&gt; {
<span class="lineno">  40 </span>        return <span class="error">when (val connectionResult = WavePlus2ConnectionSequence()</span>
<span class="lineno">  41 </span><span class="error">            .execute(scanResult.device, serialNumber, context, this)) {</span>
<span class="lineno">  42 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno">  43 </span><span class="error">                commProtocol = connectionResult.value</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/WavePlusInstrument.kt:64:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  61 </span>        val connectionResult = SimpleConnect(context, bluetoothDevice, gattClient).connect()
<span class="lineno">  62 </span>        if (connectionResult is Failure) return Failure(connectionResult.e)
<span class="lineno">  63 </span>
<span class="lineno">  64 </span>        <span class="error">when (val setMtuResult = SetMtuOperation(gattClient).setMtu(ConfigurationManager.griffinMTUSize)) {</span>
<span class="lineno">  65 </span><span class="error">            // on failure log and continue</span>
<span class="lineno">  66 </span><span class="error">            is Failure -&gt; Log.e(TAG, &quot;Failed to set MTU&quot;, setMtuResult.e)</span>
<span class="lineno">  67 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/WavePlusInstrument.kt:76:42</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  73 </span>            return Failure(discoverServicesResult.e)
<span class="lineno">  74 </span>        }
<span class="lineno">  75 </span>
<span class="lineno">  76 </span>        val gattProfile: AtGattProfile = <span class="error">when (val result = WavePlusGattProfile.tryInit(gattClient)) {</span>
<span class="lineno">  77 </span><span class="error">            is Failure -&gt; return Failure(result.e)</span>
<span class="lineno">  78 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  79 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/WavePlusInstrument.kt:87:26</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  84 </span>            return Failure(indNotResult.e)
<span class="lineno">  85 </span>        }
<span class="lineno">  86 </span>
<span class="lineno">  87 </span>        val fwVersions = <span class="error">when (val result = GriffinFwReader.readFwVersions(gattProfile, gattClient)) {</span>
<span class="lineno">  88 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  89 </span><span class="error">            is Failure -&gt; {</span>
<span class="lineno">  90 </span><span class="error">                SimpleDisconnect(gattClient).disconnect()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/oad/OADControlPointOperations.kt:177:20</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Result`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 174 </span>                    if (value[1] != OAD_SUCCESS.toByte()) return@writeCharacteristic
<span class="lineno"> 175 </span>                    block = buildUInt32(value[5], value[4], value[3], value[2])
<span class="lineno"> 176 </span>                })
<span class="lineno"> 177 </span>            return <span class="error">when (r) {</span>
<span class="lineno"> 178 </span><span class="error">                Result.SUCCESS -&gt; Success(block)</span>
<span class="lineno"> 179 </span><span class="error">                else -&gt; Failure(ErrorDirectory.failedStartOadCommand(&quot;[OAD] Send start OAD process cmd failed, return value from gatt ${returnChar?.map { it.toString() }}&quot;))</span>
<span class="lineno"> 180 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/oad/OadPrepareSequence.kt:46:50</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  43 </span>        try {
<span class="lineno">  44 </span>            Log.d(TAG, &quot;[OAD] GATT PROFILE INITIALING&quot;)
<span class="lineno">  45 </span>
<span class="lineno">  46 </span>            val oadGattProfile: OadGattProfile = <span class="error">when (val gattProfileResult = initGattProfile()) {</span>
<span class="lineno">  47 </span><span class="error">                is Failure -&gt; return Failure(gattProfileResult.e)</span>
<span class="lineno">  48 </span><span class="error">                is Success -&gt; gattProfileResult.value</span>
<span class="lineno">  49 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/oad/WavePlusFwUpgradeClient.kt:52:25</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  49 </span>        }
<span class="lineno">  50 </span>
<span class="lineno">  51 </span>        val blockSizeResult = oadControlPointOperations.readBlockSize()
<span class="lineno">  52 </span>        val blockSize = <span class="error">when (blockSizeResult) {</span>
<span class="lineno">  53 </span><span class="error">            is Success -&gt; blockSizeResult.value</span>
<span class="lineno">  54 </span><span class="error">            is Failure -&gt; {</span>
<span class="lineno">  55 </span><span class="error">                val error = blockSizeResult.e</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/oad/WavePlusFwUpgradeClient.kt:62:24</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  59 </span>        }
<span class="lineno">  60 </span>        Log.d(TAG, &quot;S/N: $serialNumber | [OAD] Block size:$blockSize&quot;)
<span class="lineno">  61 </span>
<span class="lineno">  62 </span>        val deviceId = <span class="error">when (val deviceIdResult = oadControlPointOperations.readDeviceId()) {</span>
<span class="lineno">  63 </span><span class="error">            is Success -&gt; deviceIdResult.value</span>
<span class="lineno">  64 </span><span class="error">            is Failure -&gt; {</span>
<span class="lineno">  65 </span><span class="error">                val error = deviceIdResult.e</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/oad/WavePlusFwUpgradeClient.kt:89:26</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  86 </span>        val startBlockResult = oadControlPointOperations.sendStartOadProcessCmd()
<span class="lineno">  87 </span>        Log.d(TAG, &quot;S/N: $serialNumber | [OAD] start command result: $startBlockResult&quot;)
<span class="lineno">  88 </span>
<span class="lineno">  89 </span>        val startBlock = <span class="error">when (startBlockResult) {</span>
<span class="lineno">  90 </span><span class="error">            is Success -&gt; startBlockResult.value</span>
<span class="lineno">  91 </span><span class="error">            is Failure -&gt; {</span>
<span class="lineno">  92 </span><span class="error">                val error = (blockSizeResult as Failure).e</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/readfw/CCFwImageVersionReader.kt:14:42</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  11 </span>internal class CCFwImageVersionReader(val gattClient: GattClient, val gattProfile: AtGattProfile) {
<span class="lineno">  12 </span>    fun invoke(): Try&lt;String&gt; {
<span class="lineno">  13 </span>        val readResult = CharacteristicReader(gattClient).read(gattProfile.btSigDisFirmwareRevisionChar)
<span class="lineno">  14 </span>        val bleFwVersionInterpretation = <span class="error">when (readResult) {</span>
<span class="lineno">  15 </span><span class="error">            is Failure -&gt; return Failure(readResult.e)</span>
<span class="lineno">  16 </span><span class="error">            is Success -&gt; FwVersionInterpreter().interpret(readResult.value, FirmwareImageType.BLE)</span>
<span class="lineno">  17 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/readfw/CCFwImageVersionReader.kt:19:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  16 </span>            is Success -&gt; FwVersionInterpreter().interpret(readResult.value, FirmwareImageType.BLE)
<span class="lineno">  17 </span>        }
<span class="lineno">  18 </span>
<span class="lineno">  19 </span>        return <span class="error">when (bleFwVersionInterpretation) {</span>
<span class="lineno">  20 </span><span class="error">            is Failure -&gt; Failure(bleFwVersionInterpretation.e)</span>
<span class="lineno">  21 </span><span class="error">            is Success -&gt; Success(bleFwVersionInterpretation.value)</span>
<span class="lineno">  22 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/readfw/ExternalFlashImageVersionReader.kt:18:35</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  15 </span>    val gattProfile: AtGattProfile
<span class="lineno">  16 </span>) {
<span class="lineno">  17 </span>    fun invoke(): Try&lt;String&gt; {
<span class="lineno">  18 </span>        val featureNotAvailable = <span class="error">when (val result = checkIfFeatureIsNotAvailable()) {</span>
<span class="lineno">  19 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  20 </span><span class="error">            is Failure -&gt; return Failure(result.e)</span>
<span class="lineno">  21 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/readfw/ExternalFlashImageVersionReader.kt:27:13</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  24 </span>            Failure(getWrongVersionError(bleFwVersion))
<span class="lineno">  25 </span>        } else {
<span class="lineno">  26 </span>            val commandParams = byteArrayOf(GriffinCmd.READ_EXTERNAL_FLASH_IMAGE_VERSION.code)
<span class="lineno">  27 </span>            <span class="error">when (val result = ASRACP(gattClient, gattProfile).writeBlockingUntilResponse(commandParams)) {</span>
<span class="lineno">  28 </span><span class="error">                is Failure -&gt; Failure(result.e)</span>
<span class="lineno">  29 </span><span class="error">                is Success -&gt; tryParseImageVersion(result.value)</span>
<span class="lineno">  30 </span><span class="error">            }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/readfw/GriffinFwReader.kt:25:28</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  22 </span>        gattProfile: AtGattProfile,
<span class="lineno">  23 </span>        gattClient: GattClient
<span class="lineno">  24 </span>    ): Try&lt;HashMap&lt;FirmwareImageType, String&gt;&gt; {
<span class="lineno">  25 </span>        val bleFwVersion = <span class="error">when (val bleFwVersionResult = CCFwImageVersionReader(gattClient, gattProfile).invoke()) {</span>
<span class="lineno">  26 </span><span class="error">            is Failure -&gt; return Failure(bleFwVersionResult.e)</span>
<span class="lineno">  27 </span><span class="error">            is Success -&gt; bleFwVersionResult.value</span>
<span class="lineno">  28 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/readfw/GriffinFwReader.kt:42:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  39 </span>
<span class="lineno">  40 </span>        val sub1FwVersion: String? = null
<span class="lineno">  41 </span>
<span class="lineno">  42 </span>        return <span class="error">when (val summaryResult = getSelfCheckSummary(ASRACP(gattClient, gattProfile))) {</span>
<span class="lineno">  43 </span><span class="error">            is Success -&gt; Success(</span>
<span class="lineno">  44 </span><span class="error">                makeFwVersionMap(</span>
<span class="lineno">  45 </span><span class="error">                    summaryResult,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/readfw/GriffinFwReader.kt:67:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  64 </span>    }
<span class="lineno">  65 </span>
<span class="lineno">  66 </span>    private fun getSelfCheckSummary(asracp: ASRACP): Try&lt;SelfCheckSummary&gt; {
<span class="lineno">  67 </span>        return <span class="error">when (val result = asracp.writeBlockingUntilResponse(byteArrayOf(SELF_CHECK_COMMAND))) {</span>
<span class="lineno">  68 </span><span class="error">            is Success -&gt; SelfCheckSummaryParser().parse(result.value)</span>
<span class="lineno">  69 </span><span class="error">            is Failure -&gt; Failure(result.e)</span>
<span class="lineno">  70 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/RFRegion.kt:37:46</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Region`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  34 </span>    else -&gt; error(&quot;Un supported region byte $byte&quot;)
<span class="lineno">  35 </span>}
<span class="lineno">  36 </span>
<span class="lineno">  37 </span>internal fun Region.getGriffinByte(): Byte = <span class="error">when (this) {</span>
<span class="lineno">  38 </span><span class="error">    Region.EUROPE -&gt; EUROPE_BYTE</span>
<span class="lineno">  39 </span><span class="error">    Region.NORTH_AMERICA -&gt; NORTH_AMERICA_BYTE</span>
<span class="lineno">  40 </span><span class="error">    Region.UNDEFINED -&gt; UNDEFINED_BYTE</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/ReadRFRegionCommandFactory.kt:28:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  25 </span>    }
<span class="lineno">  26 </span>
<span class="lineno">  27 </span>    override fun getCommand(fwVersions: HashMap&lt;FirmwareImageType, String&gt;, request: Any?): Try&lt;ByteArray&gt; {
<span class="lineno">  28 </span>        return <span class="error">when (val passThroughNeeded = requiresPassThrough(</span>
<span class="lineno">  29 </span><span class="error">            fwVersions[FirmwareImageType.BLE] ?: return</span>
<span class="lineno">  30 </span><span class="error">            Failure(IllegalArgumentException(&quot;Image type BLE was null.&quot;))</span>
<span class="lineno">  31 </span><span class="error">        )) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/ReadRfRegionCommand.kt:32:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  29 </span>    )
<span class="lineno">  30 </span>
<span class="lineno">  31 </span>    fun readRFRegion(): Try&lt;Region&gt; {
<span class="lineno">  32 </span>        return <span class="error">when (val command = commandFactory.getCommand(firmwareVersions, null)) {</span>
<span class="lineno">  33 </span><span class="error">            is Success -&gt;</span>
<span class="lineno">  34 </span><span class="error">                when (val response = asracp.writeBlockingUntilResponse(command.value)) {</span>
<span class="lineno">  35 </span><span class="error">                    is Failure -&gt; Failure(response.e)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/ReadRfRegionCommand.kt:34:17</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  31 </span>    fun readRFRegion(): Try&lt;Region&gt; {
<span class="lineno">  32 </span>        return when (val command = commandFactory.getCommand(firmwareVersions, null)) {
<span class="lineno">  33 </span>            is Success -&gt;
<span class="lineno">  34 </span>                <span class="error">when (val response = asracp.writeBlockingUntilResponse(command.value)) {</span>
<span class="lineno">  35 </span><span class="error">                    is Failure -&gt; Failure(response.e)</span>
<span class="lineno">  36 </span><span class="error">                    is Success -&gt; parser.parseResponse(firmwareVersions, response.value)</span>
<span class="lineno">  37 </span><span class="error">                }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/RfRegionResponseParser.kt:17:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  14 </span>
<span class="lineno">  15 </span>    override fun parseResponse(fwVersions: Map&lt;FirmwareImageType, String&gt;, rawResponse: ByteArray): Try&lt;Region&gt; {
<span class="lineno">  16 </span>        val ccFwVersion = fwVersions[FirmwareImageType.BLE] ?: error(&quot;Image type BLE was null.&quot;)
<span class="lineno">  17 </span>        return <span class="error">when (val interpretAsPassThrough = requiresPassThrough(ccFwVersion)) {</span>
<span class="lineno">  18 </span><span class="error">            is Success -&gt; if (interpretAsPassThrough.value) {</span>
<span class="lineno">  19 </span><span class="error">                interpretAsPassThrough(rawResponse)</span>
<span class="lineno">  20 </span><span class="error">            } else {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/WriteRFRegionCommandFactory.kt:17:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  14 </span>internal class WriteRFRegionCommandFactory : CmdFactory&lt;Region&gt;() {
<span class="lineno">  15 </span>
<span class="lineno">  16 </span>    override fun getCommand(fwVersions: HashMap&lt;FirmwareImageType, String&gt;, request: Region): Try&lt;ByteArray&gt; {
<span class="lineno">  17 </span>        return <span class="error">when (val passThroughNeeded = requiresPassThrough(</span>
<span class="lineno">  18 </span><span class="error">            fwVersions[FirmwareImageType.BLE] ?: return</span>
<span class="lineno">  19 </span><span class="error">            Failure(IllegalArgumentException(&quot;Image type BLE was null.&quot;))</span>
<span class="lineno">  20 </span><span class="error">        )) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/WriteRFRegionCommandFactory.kt:42:17</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Region`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  39 </span>            )
<span class="lineno">  40 </span>        } else {
<span class="lineno">  41 </span>            byteArrayOf(
<span class="lineno">  42 </span>                <span class="error">when (rfRegion) {</span>
<span class="lineno">  43 </span><span class="error">                    Region.EUROPE -&gt; OPCODE_SET_REGION_EU</span>
<span class="lineno">  44 </span><span class="error">                    Region.NORTH_AMERICA -&gt; OPCODE_SET_REGION_NORTH_AMERICA</span>
<span class="lineno">  45 </span><span class="error">                    else -&gt; OPCODE_SET_REGION_NULL</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/WriteRfRegionCommand.kt:32:23</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  29 </span>    )
<span class="lineno">  30 </span>
<span class="lineno">  31 </span>    fun write(rfRegion: Region): Try&lt;Region&gt; {
<span class="lineno">  32 </span>        val command = <span class="error">when (val res = createWriteByteSequence(rfRegion)) {</span>
<span class="lineno">  33 </span><span class="error">            is Success -&gt; res.value</span>
<span class="lineno">  34 </span><span class="error">            is Failure -&gt; return Failure(res.e)</span>
<span class="lineno">  35 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/WriteRfRegionCommand.kt:37:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  34 </span>            is Failure -&gt; return Failure(res.e)
<span class="lineno">  35 </span>        }
<span class="lineno">  36 </span>
<span class="lineno">  37 </span>        return <span class="error">when (val resp = asracp.writeBlockingUntilResponse(command)) {</span>
<span class="lineno">  38 </span><span class="error">            is Failure -&gt; Failure(resp.e)</span>
<span class="lineno">  39 </span><span class="error">            is Success -&gt; {</span>
<span class="lineno">  40 </span><span class="error">                val responsePayload = resp.value</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/WriteRfRegionCommand.kt:50:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  47 </span>        responsePayload: ByteArray,
<span class="lineno">  48 </span>        expectedRegion: Region
<span class="lineno">  49 </span>    ): Try&lt;Region&gt; {
<span class="lineno">  50 </span>        return <span class="error">when (val response = parser.parseResponse(firmwareVersions, responsePayload)) {</span>
<span class="lineno">  51 </span><span class="error">            is Success -&gt; if (response.value != expectedRegion) {</span>
<span class="lineno">  52 </span><span class="error">                Failure(IllegalStateException(&quot;Expected $expectedRegion but device responded with ${response.value}&quot;))</span>
<span class="lineno">  53 </span><span class="error">            } else {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/WriteRfRegionResponseParser.kt:15:16</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  12 </span>
<span class="lineno">  13 </span>    override fun parseResponse(fwVersions: Map&lt;FirmwareImageType, String&gt;, rawResponse: ByteArray): Try&lt;Region&gt; {
<span class="lineno">  14 </span>        val ccFwVersion = fwVersions[FirmwareImageType.BLE] ?: error(&quot;Image type BLE was null.&quot;)
<span class="lineno">  15 </span>        return <span class="error">when (val interpretAsPassThrough = requiresPassThrough(ccFwVersion)) {</span>
<span class="lineno">  16 </span><span class="error">            is Success -&gt; if (interpretAsPassThrough.value) {</span>
<span class="lineno">  17 </span><span class="error">                interpretAsPassThrough(rawResponse)</span>
<span class="lineno">  18 </span><span class="error">            } else {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/BreatheColorRing.kt:27:28</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Color`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  24 </span>        if (instrument == null || !instrument.isConnected()) return
<span class="lineno">  25 </span>        val commProtocol = instrument.commProtocol as? WaveCommProtocol ?: return
<span class="lineno">  26 </span>
<span class="lineno">  27 </span>        val definedColor = <span class="error">when (color) {</span>
<span class="lineno">  28 </span><span class="error">            Color.RED -&gt; DeviceDefines.UICommandBreatheRedRing</span>
<span class="lineno">  29 </span><span class="error">            Color.GREEN -&gt; DeviceDefines.UICommandBreatheGreenRing</span>
<span class="lineno">  30 </span><span class="error">            Color.BLUE -&gt; DeviceDefines.UICommandBreatheBlueRing</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/BreatheColorRing.kt:47:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  44 </span>                txFrame
<span class="lineno">  45 </span>        )
<span class="lineno">  46 </span>        Thread.sleep(1000)
<span class="lineno">  47 </span>        <span class="error">when (result) {</span>
<span class="lineno">  48 </span><span class="error">            is Success -&gt; fn?.invoke(null)</span>
<span class="lineno">  49 </span><span class="error">            is Failure -&gt; fn?.invoke(result.e)</span>
<span class="lineno">  50 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/ReadBaseTime.kt:19:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  16 </span>
<span class="lineno">  17 </span>        val readBaseTimeResult = instrument.commProtocol?.readBaseTime()
<span class="lineno">  18 </span>
<span class="lineno">  19 </span>        <span class="error">when (readBaseTimeResult) {</span>
<span class="lineno">  20 </span><span class="error">            is Success -&gt; callback.readSuccess(readBaseTimeResult.value)</span>
<span class="lineno">  21 </span><span class="error">            is Failure -&gt; callback.readError(&quot;Failed to read base time. Error description: ${readBaseTimeResult.e.message}&quot;)</span>
<span class="lineno">  22 </span><span class="error">            null -&gt; callback.readError(&quot;Base time was null&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/ReadCurrentValues.kt:23:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  20 </span>
<span class="lineno">  21 </span>        val result = instrument.commProtocol?.readCurrentValues()
<span class="lineno">  22 </span>            ?: Failure(IllegalStateException(&quot;Instrument is not properly initialized.&quot;))
<span class="lineno">  23 </span>        <span class="error">when (result) {</span>
<span class="lineno">  24 </span><span class="error">            is Success -&gt; callback.success(Calendar.getInstance().timeInMillis, result.value)</span>
<span class="lineno">  25 </span><span class="error">            is Failure -&gt; callback.failed(Exception(result.e))</span>
<span class="lineno">  26 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/ReadFwVersions.kt:45:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  42 </span>            return
<span class="lineno">  43 </span>        }
<span class="lineno">  44 </span>
<span class="lineno">  45 </span>        <span class="error">when (fwVersions) {</span>
<span class="lineno">  46 </span><span class="error">            null -&gt; {</span>
<span class="lineno">  47 </span><span class="error">                Log.i(TAG, &quot;Gatt profile is not configured $serialNumber&quot;)</span>
<span class="lineno">  48 </span><span class="error">                readFwVersionsCB.readError(ErrorDirectory.gattProfileIsNotConfigured(serialNumber))</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/ReadInstrumentClock.kt:23:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  20 </span>    }
<span class="lineno">  21 </span>
<span class="lineno">  22 </span>    private fun reportResult(instrument: Instrument) {
<span class="lineno">  23 </span>        <span class="error">when (val result = instrument.commProtocol?.readDeviceClock()) {</span>
<span class="lineno">  24 </span><span class="error">            is Success -&gt; callback.success(result.value)</span>
<span class="lineno">  25 </span><span class="error">            is Failure -&gt; {</span>
<span class="lineno">  26 </span><span class="error">                Log.e(TAG, &quot;Failed to read clock&quot;, result.e)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/SendUICommand.kt:28:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  25 </span>        Log.d(SendUICommand::class.java.simpleName, &quot;UI command was sent.&quot;)
<span class="lineno">  26 </span>        Thread.sleep(2000)
<span class="lineno">  27 </span>
<span class="lineno">  28 </span>        <span class="error">when (result) {</span>
<span class="lineno">  29 </span><span class="error">            is Success -&gt; fn?.invoke(null)</span>
<span class="lineno">  30 </span><span class="error">            is Failure -&gt; fn?.invoke(result.e)</span>
<span class="lineno">  31 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/SendUICommand.kt:50:29</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Operation`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  47 </span>
<span class="lineno">  48 </span>class WavePlusUiCommand(operation: Operation) : UICommand(operation) {
<span class="lineno">  49 </span>    override fun getByteArray(): ByteArray {
<span class="lineno">  50 </span>        val commandParams = <span class="error">when (operation) {</span>
<span class="lineno">  51 </span><span class="error">            Operation.WELCOME -&gt; byteArrayOf(UI_COMMAND, 1)</span>
<span class="lineno">  52 </span><span class="error">            Operation.LOW_BATTERY -&gt; byteArrayOf(UI_COMMAND, 2)</span>
<span class="lineno">  53 </span><span class="error">            Operation.PAIRED -&gt; byteArrayOf(UI_COMMAND, 3)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/SendUICommand.kt:73:29</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Operation`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  70 </span>
<span class="lineno">  71 </span>class WaveUiCommand(operation: Operation) : UICommand(operation) {
<span class="lineno">  72 </span>    override fun getByteArray(): ByteArray {
<span class="lineno">  73 </span>        val commandParams = <span class="error">when (operation) {</span>
<span class="lineno">  74 </span><span class="error">            Operation.WELCOME -&gt; byteArrayOf(248.toByte(), UI_COMMAND, 0, 1, 0)</span>
<span class="lineno">  75 </span><span class="error">            Operation.LOW_BATTERY -&gt; byteArrayOf(248.toByte(), UI_COMMAND, 0, 2, 0)</span>
<span class="lineno">  76 </span><span class="error">            Operation.PAIRED -&gt; byteArrayOf(248.toByte(), UI_COMMAND, 0, 3, 0)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/SendUICommand.kt:97:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Operation`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  94 </span>
<span class="lineno">  95 </span>class WaveMiniUiCommand(operation: UICommand.Operation) : UICommand(operation) {
<span class="lineno">  96 </span>    override fun getByteArray(): ByteArray {
<span class="lineno">  97 </span>        return <span class="error">when (operation) {</span>
<span class="lineno">  98 </span><span class="error">            Operation.BREATHE_RED -&gt; byteArrayOf(Merlin.Opcode.UI_COMMAND, 0x00, 0x00)</span>
<span class="lineno">  99 </span><span class="error">            Operation.BREATHE_GREEN -&gt; byteArrayOf(Merlin.Opcode.UI_COMMAND, 0x00, 0x01)</span>
<span class="lineno"> 100 </span><span class="error">            Operation.BREATHE_BLUE -&gt; byteArrayOf(Merlin.Opcode.UI_COMMAND, 0x00, 0x02)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/WavePlusFwUpgrade2.kt:558:54</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 555 </span>                    &quot;[OAD] ImageTransfer, prepare ${image.type} status:${prepResult.isSuccess()}&quot;
<span class="lineno"> 556 </span>                )
<span class="lineno"> 557 </span>
<span class="lineno"> 558 </span>                val oadGattProfile: OadGattProfile = <span class="error">when (prepResult) {</span>
<span class="lineno"> 559 </span><span class="error">                    is Failure -&gt; return@runBlocking Failure&lt;Unit&gt;(prepResult.e)</span>
<span class="lineno"> 560 </span><span class="error">                    is Success -&gt; prepResult.value</span>
<span class="lineno"> 561 </span><span class="error">                }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/getsensorvalues/GetSensorValues.kt:34:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  31 </span>            callback.progress((current * 100) / total)
<span class="lineno">  32 </span>        }
<span class="lineno">  33 </span>
<span class="lineno">  34 </span>        <span class="error">when (recordReadResult) {</span>
<span class="lineno">  35 </span><span class="error">            is Success -&gt; callback.success(recordReadResult.value)</span>
<span class="lineno">  36 </span><span class="error">            is Failure -&gt; {</span>
<span class="lineno">  37 </span><span class="error">                Log.e(GetSensorValues::class.java.simpleName, &quot;Read samples failed: ${recordReadResult.e.message}&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/scanner/ScannerClient.kt:82:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `WaveMiniInstrument`, `WavePlusInstrument`, `WaveInstrument`, `HubInstrument`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  79 </span>    }
<span class="lineno">  80 </span>
<span class="lineno">  81 </span>    private fun addToResults(device: Instrument, sn: String, address: String, rssi: Int) {
<span class="lineno">  82 </span>        <span class="error">when (device) {</span>
<span class="lineno">  83 </span><span class="error">            is HubInstrument -&gt; results.add(InstrumentScanResult(sn, InstrumentType.HUB, address, rssi, false))</span>
<span class="lineno">  84 </span><span class="error">            is WaveInstrument -&gt; results.add(</span>
<span class="lineno">  85 </span><span class="error">                InstrumentScanResult(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/scanner/ScannerClient.kt:143:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ScanPurpose`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 140 </span>        serialNumbersToFind.isEmpty() || serialNumbersToFind.contains(serialNumber)
<span class="lineno"> 141 </span>
<span class="lineno"> 142 </span>    private fun matchOnPurpose(purpose: ScanPurpose, i: Instrument): Boolean {
<span class="lineno"> 143 </span>        return <span class="error">when (purpose) {</span>
<span class="lineno"> 144 </span><span class="error">            ScanPurpose.ANY -&gt; !i.scanResultData.isHubConnected</span>
<span class="lineno"> 145 </span><span class="error">            ScanPurpose.PAIRING -&gt; i.isConfiguredForPairing()</span>
<span class="lineno"> 146 </span><span class="error">            ScanPurpose.DEBUG -&gt; true</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/scanner/ScannerException.kt:18:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Type`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  15 </span>    }
<span class="lineno">  16 </span>
<span class="lineno">  17 </span>    fun getScannerError(type: ScannerException.Type): ScannerException {
<span class="lineno">  18 </span>        return <span class="error">when (type) {</span>
<span class="lineno">  19 </span><span class="error">            ScannerException.Type.SCAN_FAILED_ALREADY_STARTED -&gt; scanAlreadyStarted()</span>
<span class="lineno">  20 </span><span class="error">            ScannerException.Type.SCAN_FAILED_APPLICATION_REGISTRATION_FAILED -&gt; appRegistrationFailed()</span>
<span class="lineno">  21 </span><span class="error">            ScannerException.Type.SCAN_FAILED_FEATURE_UNSUPPORTED -&gt; featureUnsupported()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/wavemini/MerlinHourBlockBuilderTest.kt:83:42</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  80 </span>    fun buildValidHourBlock() {
<span class="lineno">  81 </span>        val builder = MerlinHourBlockBuilder()
<span class="lineno">  82 </span>        builder.appendAndCountMissingBytes(rawHourBlock.toCollection(ArrayList()))
<span class="lineno">  83 </span>        val hourBlock: MerlinHourBlock = <span class="error">when (val result = builder.build()) {</span>
<span class="lineno">  84 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno">  85 </span><span class="error">            else -&gt; {</span>
<span class="lineno">  86 </span><span class="error">                fail()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/wavemini/MerlinHourBlockBuilderTest.kt:107:42</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno"> 104 </span>
<span class="lineno"> 105 </span>        val builder = MerlinHourBlockBuilder()
<span class="lineno"> 106 </span>        builder.appendAndCountMissingBytes(rawHourBlock.toCollection(ArrayList()))
<span class="lineno"> 107 </span>        val hourBlock: MerlinHourBlock = <span class="error">when (val result = builder.build()) {</span>
<span class="lineno"> 108 </span><span class="error">            is Success -&gt; result.value</span>
<span class="lineno"> 109 </span><span class="error">            else -&gt; {</span>
<span class="lineno"> 110 </span><span class="error">                fail()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/VersionComparatorTest.kt:24:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Success`, `Failure`, `IllegalArgumentException`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  21 </span>class VersionComparatorTest {
<span class="lineno">  22 </span>
<span class="lineno">  23 </span>    private fun assertIsIllegalArgumentException(result: Try&lt;Boolean&gt;) {
<span class="lineno">  24 </span>        <span class="error">when (result) {</span>
<span class="lineno">  25 </span><span class="error">            is Failure -&gt; assertTrue(result.e is IllegalArgumentException)</span>
<span class="lineno">  26 </span><span class="error">            is Success -&gt; fail()</span>
<span class="lineno">  27 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/readfw/ExternalFlashImageVersionParserTest.kt:23:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, `IllegalArgumentException`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  20 </span>    }
<span class="lineno">  21 </span>
<span class="lineno">  22 </span>    private fun assertFailure(bytes: ByteArray) {
<span class="lineno">  23 </span>        <span class="error">when (val result = ExternalFlashImageVersionParser(&quot;&quot;).tryParse(bytes)) {</span>
<span class="lineno">  24 </span><span class="error">            is Success -&gt; fail()</span>
<span class="lineno">  25 </span><span class="error">            is Failure -&gt; result.e is IllegalArgumentException</span>
<span class="lineno">  26 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/readfw/ExternalFlashImageVersionParserTest.kt:39:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  36 </span>    @Test
<span class="lineno">  37 </span>    fun `Valid response data is parsed into a fw image version`() {
<span class="lineno">  38 </span>        val rawData = makeRawTestData(major = 1, minor = 2, patch = 3)
<span class="lineno">  39 </span>        <span class="error">when (val result = ExternalFlashImageVersionParser(&quot;&quot;).tryParse(rawData)) {</span>
<span class="lineno">  40 </span><span class="error">            is Success -&gt; assertEquals(&quot;1.2.3&quot;, result.value)</span>
<span class="lineno">  41 </span><span class="error">            is Failure -&gt; fail()</span>
<span class="lineno">  42 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/readfw/ExternalFlashImageVersionParserTest.kt:48:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `Failure`, `Success`, `IllegalStateException`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  45 </span>    @Test
<span class="lineno">  46 </span>    fun `A version before version info change is indicated`() {
<span class="lineno">  47 </span>        val rawData = makeRawTestData(major = 0x30, minor = 0x30, patch = 0x30, versionInfo = 0x31)
<span class="lineno">  48 </span>        <span class="error">when (val result = ExternalFlashImageVersionParser(&quot;&quot;).tryParse(rawData)) {</span>
<span class="lineno">  49 </span><span class="error">            is Success -&gt; fail()</span>
<span class="lineno">  50 </span><span class="error">            is Failure -&gt; assertTrue(result.e is IllegalStateException)</span>
<span class="lineno">  51 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/androidTest/java/com/airthings/uicomponents/view/sensor/SensorViewLayoutTest.kt:61:9</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Config`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  58 </span>    @Test
<span class="lineno">  59 </span>    fun exampleOfUse() {
<span class="lineno">  60 </span>        val r = SensorStatus(&quot;10&quot;, QualityLevel.GOOD)
<span class="lineno">  61 </span>        <span class="error">when (sensorViewLayout!!.configState) {</span>
<span class="lineno">  62 </span><span class="error"></span>
<span class="lineno">  63 </span><span class="error">            SensorViewLayout.Config.WAVE -&gt; sensorViewLayout!!.update(WaveSensorData(r, r, r))</span>
<span class="lineno">  64 </span><span class="error">            SensorViewLayout.Config.WAVE_PLUS -&gt; sensorViewLayout!!.update(WavePlusSensorData(r, r, r, r, r, r))</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/format/ValueFormatter.kt:82:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `PreferredUnit?`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  79 </span>    }
<span class="lineno">  80 </span>
<span class="lineno">  81 </span>    private fun formatRadonValueByPreferredUnit(radonValue: Float, withLowerThanSign: Boolean): String {
<span class="lineno">  82 </span>        return <span class="error">when (preferredUnit) {</span>
<span class="lineno">  83 </span><span class="error">            PreferredUnit.US -&gt; formatRadonValueToUsUnits(radonValue, withLowerThanSign)</span>
<span class="lineno">  84 </span><span class="error">            else -&gt; formatRadonValueForMetricUnits(radonValue, withLowerThanSign)</span>
<span class="lineno">  85 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/ConnectivityStateImageView.kt:28:28</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `State`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  25 </span>        }
<span class="lineno">  26 </span>
<span class="lineno">  27 </span>    @Suppress(&quot;ComplexMethod&quot;)
<span class="lineno">  28 </span>    private fun update() = <span class="error">when (this.state) {</span>
<span class="lineno">  29 </span><span class="error">        State.BT_SCANNING -&gt; {</span>
<span class="lineno">  30 </span><span class="error">            this.setImageResource(R.drawable.ic_bluetooth_searching_stronghold_24dp)</span>
<span class="lineno">  31 </span><span class="error">            this.setColorFilter(ResourcesCompat.getColor(resources, R.color.atmosphere, context.theme))</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/calibrationcounter/CalibrationCounterViewModel.kt:25:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `DayState`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  22 </span>    private val calibrationCounter = CalibrationCounter()
<span class="lineno">  23 </span>
<span class="lineno">  24 </span>    fun getBackgroundForDay(dayNumber: Int): Drawable? {
<span class="lineno">  25 </span>        return <span class="error">when (days[dayNumber - 1]) {</span>
<span class="lineno">  26 </span><span class="error">            DayState.PAST -&gt; context.getDrawable(R.drawable.calibration_day_marker_complete)</span>
<span class="lineno">  27 </span><span class="error">            DayState.CURRENT -&gt; context.getDrawable(R.drawable.calibration_day_marker_in_progress)</span>
<span class="lineno">  28 </span><span class="error">            DayState.FUTURE -&gt; context.getDrawable(R.drawable.calibration_day_marker_waiting)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/sensor/SensorView.kt:111:9</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `UnitPosition`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 108 </span>    }
<span class="lineno"> 109 </span>
<span class="lineno"> 110 </span>    private fun setSensorUnitView() {
<span class="lineno"> 111 </span>        <span class="error">when (unitPosition) {</span>
<span class="lineno"> 112 </span><span class="error">            UnitPosition.ABOVE -&gt; {</span>
<span class="lineno"> 113 </span><span class="error">                sensorUnitView.visibility = GONE</span>
<span class="lineno"> 114 </span><span class="error">                topSensorUnitView.visibility = View.VISIBLE</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/sensor/SensorView.kt:130:9</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `QualityLevel`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 127 </span>    }
<span class="lineno"> 128 </span>
<span class="lineno"> 129 </span>    private fun setQualityIndicator() {
<span class="lineno"> 130 </span>        <span class="error">when (qualityLevel) {</span>
<span class="lineno"> 131 </span><span class="error">            QualityLevel.GOOD -&gt; qualityIndicator.setBackgroundColor(</span>
<span class="lineno"> 132 </span><span class="error">                ContextCompat.getColor(</span>
<span class="lineno"> 133 </span><span class="error">                    context,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/sensor/SensorViewConfig.kt:15:68</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `PreferredUnit`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  12 </span>        override val sensorTitle: Int
<span class="lineno">  13 </span>            get() = R.string.dashboard_sensor_view_radon
<span class="lineno">  14 </span>
<span class="lineno">  15 </span>        override fun getSensorUnit(preferredUnit: PreferredUnit) = <span class="error">when (preferredUnit) {</span>
<span class="lineno">  16 </span><span class="error">            PreferredUnit.METRIC -&gt; &quot;Bq/m&quot;</span>
<span class="lineno">  17 </span><span class="error">            PreferredUnit.US -&gt; &quot;pCi/L&quot;</span>
<span class="lineno">  18 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/sensor/SensorViewLayout.kt:52:25</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Config`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  49 </span>
<span class="lineno">  50 </span>    fun configureLayout(config: Config) {
<span class="lineno">  51 </span>        this.configState = config
<span class="lineno">  52 </span>        configuration = <span class="error">when (config) {</span>
<span class="lineno">  53 </span><span class="error">            Config.WAVE -&gt; WaveConfiguration(context, this)</span>
<span class="lineno">  54 </span><span class="error">            Config.WAVE_PLUS -&gt; WavePlusConfiguration(context, this)</span>
<span class="lineno">  55 </span><span class="error">            Config.WAVE_MINI -&gt; WaveMiniConfiguration(context, this)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/dashboarddevicelist/DashboardInstrumentListAdapter.kt:137:13</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `AirQuality`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 134 </span>        }
<span class="lineno"> 135 </span>
<span class="lineno"> 136 </span>        internal fun setAirQuality(airQuality: InstrumentListItem.AirQuality) {
<span class="lineno"> 137 </span>            <span class="error">when (airQuality) {</span>
<span class="lineno"> 138 </span><span class="error">                InstrumentListItem.AirQuality.GOOD -&gt; airQualityImage.setImageResource(R.drawable.radon_green)</span>
<span class="lineno"> 139 </span><span class="error">                InstrumentListItem.AirQuality.WARNING -&gt; airQualityImage.setImageResource(R.drawable.radon_yellow)</span>
<span class="lineno"> 140 </span><span class="error">                InstrumentListItem.AirQuality.POOR -&gt; airQualityImage.setImageResource(R.drawable.radon_red)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/dashboarddevicelist/InstrumentListItem.kt:25:20</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Type`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno">  22 </span>        WAVE_MIST;
<span class="lineno">  23 </span>
<span class="lineno">  24 </span>        fun productName(): String {
<span class="lineno">  25 </span>            return <span class="error">when (this) {</span>
<span class="lineno">  26 </span><span class="error">                UNKNOWN_INSTRUMENT_TYPE -&gt; &quot;Unknown&quot;</span>
<span class="lineno">  27 </span><span class="error">                WAVE_CLASSIC -&gt; &quot;Wave&quot;</span>
<span class="lineno">  28 </span><span class="error">                WAVE_PLUS -&gt; &quot;Wave Plus&quot;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:136:16</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `ConfigurationType`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 133 </span>    private val dpToPx: DpToPx
<span class="lineno"> 134 </span>) {
<span class="lineno"> 135 </span>    fun getConfiguration(configurationType: ConfigurationType): IndicatorConfiguration {
<span class="lineno"> 136 </span>        return <span class="error">when (configurationType) {</span>
<span class="lineno"> 137 </span><span class="error">            ConfigurationType.IDLE -&gt; IdleConfiguration(context, idleIcon)</span>
<span class="lineno"> 138 </span><span class="error">            ConfigurationType.BATTERY_ALERT -&gt; BatteryAlertConfiguration(context, dpToPx)</span>
<span class="lineno"> 139 </span><span class="error">            ConfigurationType.SCANNING_AND_CONNECTION -&gt; ScanningConfiguration(context, dpToPx)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:177:24</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `IdleIcon`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 174 </span>
<span class="lineno"> 175 </span>    init {
<span class="lineno"> 176 </span>        colorCirclePaint.color = Color.TRANSPARENT
<span class="lineno"> 177 </span>        iconResource = <span class="error">when (idleIcon) {</span>
<span class="lineno"> 178 </span><span class="error">            IdleIcon.DEVICE -&gt; R.drawable.ic_airthings_device_24px</span>
<span class="lineno"> 179 </span><span class="error">            IdleIcon.COG -&gt; R.drawable.ic_settings_stronghold_24dp</span>
<span class="lineno"> 180 </span><span class="error">            IdleIcon.CLOUD -&gt; R.drawable.ic_cloud_idle_stronghold_24dp</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/viewbinding/ViewBindingAdapter.kt:74:9</span><span class="message">Type checking is a sign of violating the Open-Closed Principle. Consider introducing an abstraction (interface) for `android.app.ActionBar.LayoutParams`, `androidx.appcompat.app.ActionBar.LayoutParams`, `DrawerLayout.LayoutParams`, `FrameLayout.LayoutParams`, with new implementations of the interface for every class.</span>
        <pre><code><span class="lineno">  71 </span>    @BindingAdapter(&quot;android:layout_gravity&quot;)
<span class="lineno">  72 </span>    fun setLayoutGravity(view: View, gravity: Int) {
<span class="lineno">  73 </span>        val layoutParams = view.layoutParams
<span class="lineno">  74 </span>        <span class="error">when (layoutParams) {</span>
<span class="lineno">  75 </span><span class="error">            is FrameLayout.LayoutParams -&gt; layoutParams.gravity = gravity</span>
<span class="lineno">  76 </span><span class="error">            is DrawerLayout.LayoutParams -&gt; layoutParams.gravity = gravity</span>
<span class="lineno">  77 </span><span class="error">            is androidx.appcompat.app.ActionBar.LayoutParams -&gt; layoutParams.gravity = gravity</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-utilities/src/main/java/com/airthings/utilities/Log.kt:125:9</span><span class="message">Switching on enum values is a common sign of violation the Open-Closed Principle. Consider introducing an abstraction (interface) for `Priority`, with new implementations of the interface for every value.</span>
        <pre><code><span class="lineno"> 122 </span>    }
<span class="lineno"> 123 </span>
<span class="lineno"> 124 </span>    private fun logWithAndroid(priority: Priority, tag: String, message: String, e: Throwable) {
<span class="lineno"> 125 </span>        <span class="error">when (priority) {</span>
<span class="lineno"> 126 </span><span class="error">            Priority.VERBOSE -&gt; android.util.Log.v(tag, message, e)</span>
<span class="lineno"> 127 </span><span class="error">            Priority.INFO -&gt; android.util.Log.i(tag, message, e)</span>
<span class="lineno"> 128 </span><span class="error">            Priority.DEBUG -&gt; android.util.Log.d(tag, message, e)</span>
</code></pre>
      </li>
    </ul>
  </details>
  <details id="UseCompositionInsteadOfInheritance" open="open">
    <summary class="rule-container"><span class="rule">UseCompositionInsteadOfInheritance: 321 </span><span class="description">This rule reports a file using inheritance.</span></summary>
    <ul>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/uisettings/GriffinUiSettingsComposerFragment.kt:20:1</span><span class="message">The class `GriffinUiSettingsComposerFragment` is using inheritance, consider using composition instead.

Does `GriffinUiSettingsComposerFragment` want to expose the complete interface (`empty public interface`) of `UiSettingsComposerFragment` such that `GriffinUiSettingsComposerFragment` can be used where `UiSettingsComposerFragment` is expected? Indicates __inheritance__.

Does `GriffinUiSettingsComposerFragment` want only some/part of the behavior exposed by `UiSettingsComposerFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  17 </span>import com.google.android.material.textfield.TextInputEditText
<span class="lineno">  18 </span>import kotlinx.android.synthetic.main.ui_settings_griffin.*
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">@Suppress(&quot;TooManyFunctions&quot;)</span>
<span class="lineno">  21 </span><span class="error">class GriffinUiSettingsComposerFragment : UiSettingsComposerFragment() {</span>
<span class="lineno">  22 </span><span class="error"></span>
<span class="lineno">  23 </span><span class="error">    private lateinit var onWriteClick: ((uiSettings: UISettings) -&gt; Unit)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/uisettings/MerlinUiSettingsComposerFragment.kt:14:1</span><span class="message">The class `MerlinUiSettingsComposerFragment` is using inheritance, consider using composition instead.

Does `MerlinUiSettingsComposerFragment` want to expose the complete interface (`empty public interface`) of `UiSettingsComposerFragment` such that `MerlinUiSettingsComposerFragment` can be used where `UiSettingsComposerFragment` is expected? Indicates __inheritance__.

Does `MerlinUiSettingsComposerFragment` want only some/part of the behavior exposed by `UiSettingsComposerFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.waver.R
<span class="lineno">  12 </span>import kotlinx.android.synthetic.main.ui_settings_merlin.*
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">class MerlinUiSettingsComposerFragment : UiSettingsComposerFragment() {</span>
<span class="lineno">  15 </span><span class="error">    override fun onCreateView(</span>
<span class="lineno">  16 </span><span class="error">        inflater: LayoutInflater,</span>
<span class="lineno">  17 </span><span class="error">        container: ViewGroup?,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-waver/src/main/java/com/airthings/waver/uisettings/UiSettingsComposerDialog.kt:107:1</span><span class="message">The class `PlaceholderUiSettingsComposerFragment` is using inheritance, consider using composition instead.

Does `PlaceholderUiSettingsComposerFragment` want to expose the complete interface (`empty public interface`) of `UiSettingsComposerFragment` such that `PlaceholderUiSettingsComposerFragment` can be used where `UiSettingsComposerFragment` is expected? Indicates __inheritance__.

Does `PlaceholderUiSettingsComposerFragment` want only some/part of the behavior exposed by `UiSettingsComposerFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 104 </span>    abstract val onUpdate: ((uiSettings: UISettings) -&gt; Unit)
<span class="lineno"> 105 </span>}
<span class="lineno"> 106 </span>
<span class="lineno"> 107 </span><span class="error">class PlaceholderUiSettingsComposerFragment : UiSettingsComposerFragment() {</span>
<span class="lineno"> 108 </span><span class="error">    override val onUpdate: ((uiSettings: UISettings) -&gt; Unit) = {</span>
<span class="lineno"> 109 </span><span class="error">        // NO-OP</span>
<span class="lineno"> 110 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-wizarddemo/src/main/java/com/airthings/wizarddemo/DemoActivity.kt:57:1</span><span class="message">The class `DemoWizard` is using inheritance, consider using composition instead.

Does `DemoWizard` want to expose the complete interface (`onRestoreInstanceState, onSaveInstanceState, onDestroy, onCreate, replace, remove, add, add, goBackwardIfAllowed, goBackward, goForward, goto`) of `Wizard` such that `DemoWizard` can be used where `Wizard` is expected? Indicates __inheritance__.

Does `DemoWizard` want only some/part of the behavior exposed by `Wizard`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  54 </span>    }
<span class="lineno">  55 </span>}
<span class="lineno">  56 </span>
<span class="lineno">  57 </span><span class="error">class DemoWizard(</span>
<span class="lineno">  58 </span><span class="error">    activity: DemoActivity</span>
<span class="lineno">  59 </span><span class="error">) : Wizard(activity, activity.navigator, activity.pagerAdapter), WizardStateHandler {</span>
<span class="lineno">  60 </span><span class="error">    override fun exportViewModelState(): Bundle? = null</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-wizarddemo/src/main/java/com/airthings/wizarddemo/DemoActivity.kt:89:1</span><span class="message">The class `MyWizardPagerAdapter` is using inheritance, consider using composition instead.

Does `MyWizardPagerAdapter` want to expose the complete interface (`onPageScrollStateChanged, onPageSelected, onPageScrolled, containsItem, getItemId, getItemCount, createFragment, createFragment`) of `WizardPagerAdapter` such that `MyWizardPagerAdapter` can be used where `WizardPagerAdapter` is expected? Indicates __inheritance__.

Does `MyWizardPagerAdapter` want only some/part of the behavior exposed by `WizardPagerAdapter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  86 </span>    }
<span class="lineno">  87 </span>}
<span class="lineno">  88 </span>
<span class="lineno">  89 </span><span class="error">class MyWizardPagerAdapter(activity: AppCompatActivity, navigator: WizardNavigatorConfig) :</span>
<span class="lineno">  90 </span><span class="error">    WizardPagerAdapter(activity, navigator) {</span>
<span class="lineno">  91 </span><span class="error">    override fun createFragment(page: WizardPage): WizardPageFragment&lt;out WizardPage, out ViewDataBinding&gt; =</span>
<span class="lineno">  92 </span><span class="error">        PageFragment(page as DemoPage)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app-wizarddemo/src/main/java/com/airthings/wizarddemo/DemoActivity.kt:133:1</span><span class="message">The class `PageFragment` is using inheritance, consider using composition instead.

Does `PageFragment` want to expose the complete interface (`onHidden, onShown, onCreateView, bind`) of `WizardPageFragment` such that `PageFragment` can be used where `WizardPageFragment` is expected? Indicates __inheritance__.

Does `PageFragment` want only some/part of the behavior exposed by `WizardPageFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 130 </span>    override fun toString() = identifier
<span class="lineno"> 131 </span>}
<span class="lineno"> 132 </span>
<span class="lineno"> 133 </span><span class="error">class PageFragment(</span>
<span class="lineno"> 134 </span><span class="error">    page: DemoPage</span>
<span class="lineno"> 135 </span><span class="error">) : WizardPageFragment&lt;DemoPage, WizardDemoPageBinding&gt;() {</span>
<span class="lineno"> 136 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/DeviceViewModel.kt:24:1</span><span class="message">The class `DeviceViewModel` is using inheritance, consider using composition instead.

Does `DeviceViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `DeviceViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `DeviceViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  21 </span>import com.airthings.instrumentapi.scanner.ScannerException
<span class="lineno">  22 </span>import com.airthings.utilities.Log
<span class="lineno">  23 </span>
<span class="lineno">  24 </span><span class="error">abstract class DeviceViewModel(</span>
<span class="lineno">  25 </span><span class="error">    protected val deviceRepository: DeviceRepository,</span>
<span class="lineno">  26 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  27 </span><span class="error">    userRepository: UserRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/activities/about/AboutMenuActivity.kt:11:1</span><span class="message">The class `AboutMenuActivity` is using inheritance, consider using composition instead.

Does `AboutMenuActivity` want to expose the complete interface (`requestBluetoothEnable, requestLocationPermission, requestBluetoothAdminPermission, requestBluetoothPermission, onRequestPermissionsResult, onNewIntent, onResume, onDestroy, injectViewModelFactory, onCreate`) of `BaseActivity` such that `AboutMenuActivity` can be used where `BaseActivity` is expected? Indicates __inheritance__.

Does `AboutMenuActivity` want only some/part of the behavior exposed by `BaseActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.airthings.activities.BaseActivity
<span class="lineno">   9 </span>import kotlinx.android.synthetic.main.activity_about_menu.*
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">class AboutMenuActivity : BaseActivity&lt;AboutMenuViewModel&gt;() {</span>
<span class="lineno">  12 </span><span class="error">    override val viewModelClass = AboutMenuViewModel::class.java</span>
<span class="lineno">  13 </span><span class="error"></span>
<span class="lineno">  14 </span><span class="error">    override fun onCreate(savedInstanceState: Bundle?) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/activities/about/AboutMenuViewModel.kt:12:1</span><span class="message">The class `AboutMenuViewModel` is using inheritance, consider using composition instead.

Does `AboutMenuViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `AboutMenuViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `AboutMenuViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.airthings.repository.storage.StorageServiceRepository
<span class="lineno">  10 </span>import javax.inject.Inject
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class AboutMenuViewModel @Inject constructor(</span>
<span class="lineno">  13 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  14 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  15 </span><span class="error">    internetServiceRepository: InternetServiceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/activities/about/AboutViewModel.kt:12:1</span><span class="message">The class `AboutViewModel` is using inheritance, consider using composition instead.

Does `AboutViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `AboutViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `AboutViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.airthings.repository.storage.StorageServiceRepository
<span class="lineno">  10 </span>import javax.inject.Inject
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class AboutViewModel @Inject constructor(</span>
<span class="lineno">  13 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  14 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  15 </span><span class="error">    internetServiceRepository: InternetServiceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/AppError.kt:5:1</span><span class="message">The class `ApiAppError` is using inheritance, consider using composition instead.

Does `ApiAppError` want to expose the complete interface (`empty public interface`) of `AppError` such that `ApiAppError` can be used where `AppError` is expected? Indicates __inheritance__.

Does `ApiAppError` want only some/part of the behavior exposed by `AppError`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   2 </span>
<span class="lineno">   3 </span>sealed class AppError
<span class="lineno">   4 </span>
<span class="lineno">   5 </span><span class="error">@Suppress(&quot;unused&quot;)</span>
<span class="lineno">   6 </span><span class="error">data class ApiAppError(val error: String = &quot;N/A&quot;, val errorCode: Int = -1) : AppError() {</span>
<span class="lineno">   7 </span><span class="error">    override fun toString(): String = &quot;$error ($errorCode)&quot;</span>
<span class="lineno">   8 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/AppError.kt:54:1</span><span class="message">The class `StateAppError` is using inheritance, consider using composition instead.

Does `StateAppError` want to expose the complete interface (`empty public interface`) of `AppError` such that `StateAppError` can be used where `AppError` is expected? Indicates __inheritance__.

Does `StateAppError` want only some/part of the behavior exposed by `AppError`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  51 </span>    }
<span class="lineno">  52 </span>}
<span class="lineno">  53 </span>
<span class="lineno">  54 </span><span class="error">data class StateAppError(val error: String, val errorCode: Int) : AppError() {</span>
<span class="lineno">  55 </span><span class="error">    companion object {</span>
<span class="lineno">  56 </span><span class="error">        private const val STATE_ERROR = 0</span>
<span class="lineno">  57 </span><span class="error">        fun stateError() = StateAppError(&quot;State appError&quot;, STATE_ERROR)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/ConnectedUserDevice.kt:34:1</span><span class="message">The class `ConnectedUserDevice` is using inheritance, consider using composition instead.

Does `ConnectedUserDevice` want to expose the complete interface (`destroy`) of `UserDevice` such that `ConnectedUserDevice` can be used where `UserDevice` is expected? Indicates __inheritance__.

Does `ConnectedUserDevice` want only some/part of the behavior exposed by `UserDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  31 </span>import java.util.TreeMap
<span class="lineno">  32 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  33 </span>
<span class="lineno">  34 </span><span class="error">@Suppress(&quot;TooManyFunctions&quot;, &quot;LargeClass&quot;)</span>
<span class="lineno">  35 </span><span class="error">abstract class ConnectedUserDevice constructor(</span>
<span class="lineno">  36 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  37 </span><span class="error">    protected val deviceRepository: DeviceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/GriffinUserDevice.kt:17:1</span><span class="message">The class `GriffinUserDevice` is using inheritance, consider using composition instead.

Does `GriffinUserDevice` want to expose the complete interface (`setRadonAlarm, radonAlarmEnabled`) of `RadonSensingUserDevice` such that `GriffinUserDevice` can be used where `RadonSensingUserDevice` is expected? Indicates __inheritance__.

Does `GriffinUserDevice` want only some/part of the behavior exposed by `RadonSensingUserDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  14 </span>import com.airthings.instrumentapi.instrumentops.uisettings.griffin.B2CSetting
<span class="lineno">  15 </span>import com.airthings.instrumentapi.instrumentops.uisettings.griffin.SoundSetting
<span class="lineno">  16 </span>
<span class="lineno">  17 </span><span class="error">abstract class GriffinUserDevice(</span>
<span class="lineno">  18 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  19 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  20 </span><span class="error">    credentialRepository: CredentialRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/HubUserDevice.kt:6:1</span><span class="message">The class `HubUserDevice` is using inheritance, consider using composition instead.

Does `HubUserDevice` want to expose the complete interface (`destroy`) of `UserDevice` such that `HubUserDevice` can be used where `UserDevice` is expected? Indicates __inheritance__.

Does `HubUserDevice` want only some/part of the behavior exposed by `UserDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   3 </span>import com.airthings.airthings.models.data.UserDeviceData
<span class="lineno">   4 </span>import com.airthings.airthings.models.data.UserDeviceType
<span class="lineno">   5 </span>
<span class="lineno">   6 </span><span class="error">class HubUserDevice(userDeviceData: UserDeviceData) : UserDevice(userDeviceData) {</span>
<span class="lineno">   7 </span><span class="error">    override val modelName: String = &quot;Hub&quot;</span>
<span class="lineno">   8 </span><span class="error">    override val shortModelName = SHORT_MODEL_NAME</span>
<span class="lineno">   9 </span><span class="error">    override var isLinkable = false</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/RadonSensingUserDevice.kt:13:1</span><span class="message">The class `RadonSensingUserDevice` is using inheritance, consider using composition instead.

Does `RadonSensingUserDevice` want to expose the complete interface (`toString, segmentStartTime, sensorStorageSizeBytes, latestBatteryVoltage, lastSyncedTime, samplesSynced, getLastBleConnectionTime, clearData, getValuesAsSensorMap, getValues, triggerLightRing, connect, disconnect, writeDefaultUiSettings, getLastError, shouldUpdateDevice, bluetoothSync, cloudUpSync, cloudDownSync, sync, isInSync, findBluetoothDevice, updateFirmware, getFwVersionsFromBluetooth, getFwVersionsFromCache, writeDefaultSettings, userDeviceDataUpdated`) of `ConnectedUserDevice` such that `RadonSensingUserDevice` can be used where `ConnectedUserDevice` is expected? Indicates __inheritance__.

Does `RadonSensingUserDevice` want only some/part of the behavior exposed by `ConnectedUserDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import com.airthings.instrumentapi.BleException
<span class="lineno">  11 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">abstract class RadonSensingUserDevice(</span>
<span class="lineno">  14 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  15 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  16 </span><span class="error">    credentialRepository: CredentialRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/Units.kt:23:1</span><span class="message">The class `Pascal` is using inheritance, consider using composition instead.

Does `Pascal` want to expose the complete interface (`toShort, toLong, toInt, toFloat, toDouble, toChar, toByte`) of `Measurement` such that `Pascal` can be used where `Measurement` is expected? Indicates __inheritance__.

Does `Pascal` want only some/part of the behavior exposed by `Measurement`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  20 </span>    override fun toShort() = this.value.toShort()
<span class="lineno">  21 </span>}
<span class="lineno">  22 </span>
<span class="lineno">  23 </span><span class="error">class Pascal(value: Float) : Measurement&lt;Float&gt;(value)</span>
<span class="lineno">  24 </span>class Celsius(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  25 </span>class Ppm(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  26 </span>class Ppb(value: Float) : Measurement&lt;Float&gt;(value)
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/Units.kt:24:1</span><span class="message">The class `Celsius` is using inheritance, consider using composition instead.

Does `Celsius` want to expose the complete interface (`toShort, toLong, toInt, toFloat, toDouble, toChar, toByte`) of `Measurement` such that `Celsius` can be used where `Measurement` is expected? Indicates __inheritance__.

Does `Celsius` want only some/part of the behavior exposed by `Measurement`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  21 </span>}
<span class="lineno">  22 </span>
<span class="lineno">  23 </span>class Pascal(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  24 </span><span class="error">class Celsius(value: Float) : Measurement&lt;Float&gt;(value)</span>
<span class="lineno">  25 </span>class Ppm(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  26 </span>class Ppb(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  27 </span>class Bqm(value: Float) : Measurement&lt;Float&gt;(value)
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/Units.kt:25:1</span><span class="message">The class `Ppm` is using inheritance, consider using composition instead.

Does `Ppm` want to expose the complete interface (`toShort, toLong, toInt, toFloat, toDouble, toChar, toByte`) of `Measurement` such that `Ppm` can be used where `Measurement` is expected? Indicates __inheritance__.

Does `Ppm` want only some/part of the behavior exposed by `Measurement`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  22 </span>
<span class="lineno">  23 </span>class Pascal(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  24 </span>class Celsius(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  25 </span><span class="error">class Ppm(value: Float) : Measurement&lt;Float&gt;(value)</span>
<span class="lineno">  26 </span>class Ppb(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  27 </span>class Bqm(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  28 </span>class Rh(value: Float) : Measurement&lt;Float&gt;(value)
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/Units.kt:26:1</span><span class="message">The class `Ppb` is using inheritance, consider using composition instead.

Does `Ppb` want to expose the complete interface (`toShort, toLong, toInt, toFloat, toDouble, toChar, toByte`) of `Measurement` such that `Ppb` can be used where `Measurement` is expected? Indicates __inheritance__.

Does `Ppb` want only some/part of the behavior exposed by `Measurement`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  23 </span>class Pascal(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  24 </span>class Celsius(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  25 </span>class Ppm(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  26 </span><span class="error">class Ppb(value: Float) : Measurement&lt;Float&gt;(value)</span>
<span class="lineno">  27 </span>class Bqm(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  28 </span>class Rh(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  29 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/Units.kt:27:1</span><span class="message">The class `Bqm` is using inheritance, consider using composition instead.

Does `Bqm` want to expose the complete interface (`toShort, toLong, toInt, toFloat, toDouble, toChar, toByte`) of `Measurement` such that `Bqm` can be used where `Measurement` is expected? Indicates __inheritance__.

Does `Bqm` want only some/part of the behavior exposed by `Measurement`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  24 </span>class Celsius(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  25 </span>class Ppm(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  26 </span>class Ppb(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  27 </span><span class="error">class Bqm(value: Float) : Measurement&lt;Float&gt;(value)</span>
<span class="lineno">  28 </span>class Rh(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  29 </span>
<span class="lineno">  30 </span>enum class Quality(val index: Int) {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/Units.kt:28:1</span><span class="message">The class `Rh` is using inheritance, consider using composition instead.

Does `Rh` want to expose the complete interface (`toShort, toLong, toInt, toFloat, toDouble, toChar, toByte`) of `Measurement` such that `Rh` can be used where `Measurement` is expected? Indicates __inheritance__.

Does `Rh` want only some/part of the behavior exposed by `Measurement`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  25 </span>class Ppm(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  26 </span>class Ppb(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  27 </span>class Bqm(value: Float) : Measurement&lt;Float&gt;(value)
<span class="lineno">  28 </span><span class="error">class Rh(value: Float) : Measurement&lt;Float&gt;(value)</span>
<span class="lineno">  29 </span>
<span class="lineno">  30 </span>enum class Quality(val index: Int) {
<span class="lineno">  31 </span>    GOOD(3),
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/WaveClassicAssessor.kt:3:1</span><span class="message">The class `WaveClassicAssessor` is using inheritance, consider using composition instead.

Does `WaveClassicAssessor` want to expose the complete interface (`detailedAssessment, getAssessment, overallAssessment`) of `Assessor` such that `WaveClassicAssessor` can be used where `Assessor` is expected? Indicates __inheritance__.

Does `WaveClassicAssessor` want only some/part of the behavior exposed by `Assessor`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   1 </span>package com.airthings.airthings.models.device
<span class="lineno">   2 </span>
<span class="lineno">   3 </span><span class="error">class WaveClassicAssessor : Assessor() {</span>
<span class="lineno">   4 </span><span class="error">    override fun overallAssessment(dataPoint: DataPoint): Assessment&lt;DataPoint&gt; {</span>
<span class="lineno">   5 </span><span class="error">        return dataPoint</span>
<span class="lineno">   6 </span><span class="error">            .values[SensorType.RADON_24H_AVG]</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/WaveClassicGen1UserDevice.kt:19:1</span><span class="message">The class `WaveClassicGen1UserDevice` is using inheritance, consider using composition instead.

Does `WaveClassicGen1UserDevice` want to expose the complete interface (`setRadonAlarm, radonAlarmEnabled`) of `RadonSensingUserDevice` such that `WaveClassicGen1UserDevice` can be used where `RadonSensingUserDevice` is expected? Indicates __inheritance__.

Does `WaveClassicGen1UserDevice` want only some/part of the behavior exposed by `RadonSensingUserDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>import com.airthings.instrumentapi.BleException
<span class="lineno">  17 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">class WaveClassicGen1UserDevice(</span>
<span class="lineno">  20 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  21 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  22 </span><span class="error">    credentialRepository: CredentialRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/WaveClassicGen2UserDevice.kt:12:1</span><span class="message">The class `WaveClassicGen2UserDevice` is using inheritance, consider using composition instead.

Does `WaveClassicGen2UserDevice` want to expose the complete interface (`shouldUpdateDevice`) of `GriffinUserDevice` such that `WaveClassicGen2UserDevice` can be used where `GriffinUserDevice` is expected? Indicates __inheritance__.

Does `WaveClassicGen2UserDevice` want only some/part of the behavior exposed by `GriffinUserDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.airthings.repository.RecordRepository
<span class="lineno">  10 </span>import com.airthings.airthings.repository.bluetooth.BluetoothServiceRepository
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class WaveClassicGen2UserDevice(</span>
<span class="lineno">  13 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  14 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  15 </span><span class="error">    credentialRepository: CredentialRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/WaveMiniUserDevice.kt:22:1</span><span class="message">The class `WaveMiniUserDevice` is using inheritance, consider using composition instead.

Does `WaveMiniUserDevice` want to expose the complete interface (`toString, segmentStartTime, sensorStorageSizeBytes, latestBatteryVoltage, lastSyncedTime, samplesSynced, getLastBleConnectionTime, clearData, getValuesAsSensorMap, getValues, triggerLightRing, connect, disconnect, writeDefaultUiSettings, getLastError, shouldUpdateDevice, bluetoothSync, cloudUpSync, cloudDownSync, sync, isInSync, findBluetoothDevice, updateFirmware, getFwVersionsFromBluetooth, getFwVersionsFromCache, writeDefaultSettings, userDeviceDataUpdated`) of `ConnectedUserDevice` such that `WaveMiniUserDevice` can be used where `ConnectedUserDevice` is expected? Indicates __inheritance__.

Does `WaveMiniUserDevice` want only some/part of the behavior exposed by `ConnectedUserDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  19 </span>import com.airthings.utilities.Success
<span class="lineno">  20 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">class WaveMiniUserDevice(</span>
<span class="lineno">  23 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  24 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  25 </span><span class="error">    credentialRepository: CredentialRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/models/device/WavePlusUserDevice.kt:18:1</span><span class="message">The class `WavePlusUserDevice` is using inheritance, consider using composition instead.

Does `WavePlusUserDevice` want to expose the complete interface (`shouldUpdateDevice`) of `GriffinUserDevice` such that `WavePlusUserDevice` can be used where `GriffinUserDevice` is expected? Indicates __inheritance__.

Does `WavePlusUserDevice` want only some/part of the behavior exposed by `GriffinUserDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>import com.airthings.utilities.Success
<span class="lineno">  16 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">class WavePlusUserDevice(</span>
<span class="lineno">  19 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  20 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  21 </span><span class="error">    credentialRepository: CredentialRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/BluetoothRecordRepository.kt:13:1</span><span class="message">The class `BluetoothRecordRepository` is using inheritance, consider using composition instead.

Does `BluetoothRecordRepository` want to expose the complete interface (`syncFrom, markRecordsAsSynced, deleteAllRecords, getRecords, getUnsyncedRecords, storeRecords, getLatestSyncedRecords`) of `RecordRepository` such that `BluetoothRecordRepository` can be used where `RecordRepository` is expected? Indicates __inheritance__.

Does `BluetoothRecordRepository` want only some/part of the behavior exposed by `RecordRepository`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import java.util.Date
<span class="lineno">  11 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class BluetoothRecordRepository(</span>
<span class="lineno">  14 </span><span class="error">    private var atDevice: AirthingsDevice?,</span>
<span class="lineno">  15 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  16 </span><span class="error">    serial: String</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/CloudRecordRepository.kt:16:1</span><span class="message">The class `CloudRecordRepository` is using inheritance, consider using composition instead.

Does `CloudRecordRepository` want to expose the complete interface (`syncFrom, markRecordsAsSynced, deleteAllRecords, getRecords, getUnsyncedRecords, storeRecords, getLatestSyncedRecords`) of `RecordRepository` such that `CloudRecordRepository` can be used where `RecordRepository` is expected? Indicates __inheritance__.

Does `CloudRecordRepository` want only some/part of the behavior exposed by `RecordRepository`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import com.airthings.airthings.utils.cloudError
<span class="lineno">  14 </span>import com.airthings.utilities.Log
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">class CloudRecordRepository constructor(</span>
<span class="lineno">  17 </span><span class="error">    val rest: AirthingsApi,</span>
<span class="lineno">  18 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  19 </span><span class="error">    serial: String</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/repository/RealmRecordRepository.kt:12:1</span><span class="message">The class `RealmRecordRepository` is using inheritance, consider using composition instead.

Does `RealmRecordRepository` want to expose the complete interface (`syncFrom, markRecordsAsSynced, deleteAllRecords, getRecords, getUnsyncedRecords, storeRecords, getLatestSyncedRecords`) of `RecordRepository` such that `RealmRecordRepository` can be used where `RecordRepository` is expected? Indicates __inheritance__.

Does `RealmRecordRepository` want only some/part of the behavior exposed by `RecordRepository`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import io.realm.Sort
<span class="lineno">  10 </span>import java.io.File
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class RealmRecordRepository(</span>
<span class="lineno">  13 </span><span class="error">    private val realmManager: RealmConfigManager,</span>
<span class="lineno">  14 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  15 </span><span class="error">    serial: String</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/addnewdevice/PairingCompletedViewModel.kt:25:1</span><span class="message">The class `PairingCompletedViewModel` is using inheritance, consider using composition instead.

Does `PairingCompletedViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `PairingCompletedViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `PairingCompletedViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  22 </span>
<span class="lineno">  23 </span>data class PairedInstrument(val serialNumber: String, val room: String, val imageR: Int)
<span class="lineno">  24 </span>
<span class="lineno">  25 </span><span class="error">class PairingCompletedViewModel @Inject constructor(</span>
<span class="lineno">  26 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  27 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  28 </span><span class="error">    deviceRepository: DeviceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/addnewdevice/pairing3/ScannerViewModel.kt:14:1</span><span class="message">The class `ScannerViewModel` is using inheritance, consider using composition instead.

Does `ScannerViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `ScannerViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `ScannerViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.airthings.utils.map
<span class="lineno">  12 </span>import javax.inject.Inject
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">class ScannerViewModel @Inject constructor(</span>
<span class="lineno">  15 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  16 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  17 </span><span class="error">    deviceRepository: DeviceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/confirmaccount/ConfirmAccountActivity.kt:29:1</span><span class="message">The class `ConfirmAccountActivity` is using inheritance, consider using composition instead.

Does `ConfirmAccountActivity` want to expose the complete interface (`onUnAuthenticated, onCreate`) of `BaseAccountActivity` such that `ConfirmAccountActivity` can be used where `BaseAccountActivity` is expected? Indicates __inheritance__.

Does `ConfirmAccountActivity` want only some/part of the behavior exposed by `BaseAccountActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  26 </span>import java.util.ArrayList
<span class="lineno">  27 </span>import java.util.Locale
<span class="lineno">  28 </span>
<span class="lineno">  29 </span><span class="error">class ConfirmAccountActivity : BaseAccountActivity&lt;ConfirmAccountViewModel&gt;(),</span>
<span class="lineno">  30 </span><span class="error">    InputValidatorListener {</span>
<span class="lineno">  31 </span><span class="error">    companion object {</span>
<span class="lineno">  32 </span><span class="error">        private const val TAG = &quot;ConfirmAccountActivity&quot;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/confirmaccount/ConfirmAccountViewModel.kt:12:1</span><span class="message">The class `ConfirmAccountViewModel` is using inheritance, consider using composition instead.

Does `ConfirmAccountViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `ConfirmAccountViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `ConfirmAccountViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.airthings.repository.storage.StorageServiceRepository
<span class="lineno">  10 </span>import javax.inject.Inject
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class ConfirmAccountViewModel @Inject constructor(</span>
<span class="lineno">  13 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  14 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  15 </span><span class="error">    internetServiceRepository: InternetServiceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/controlsync/SyncControlViewModel.kt:21:1</span><span class="message">The class `SyncControlViewModel` is using inheritance, consider using composition instead.

Does `SyncControlViewModel` want to expose the complete interface (`loadDevice, discoverOwnDevices`) of `DeviceViewModel` such that `SyncControlViewModel` can be used where `DeviceViewModel` is expected? Indicates __inheritance__.

Does `SyncControlViewModel` want only some/part of the behavior exposed by `DeviceViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  18 </span>import com.airthings.airthings.utils.suspendGetValue
<span class="lineno">  19 </span>import javax.inject.Inject
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">class SyncControlViewModel @Inject constructor(</span>
<span class="lineno">  22 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  23 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  24 </span><span class="error">    userRepository: UserRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/createaccount/CreateAccountActivity.kt:27:1</span><span class="message">The class `CreateAccountActivity` is using inheritance, consider using composition instead.

Does `CreateAccountActivity` want to expose the complete interface (`onUnAuthenticated, onCreate`) of `BaseAccountActivity` such that `CreateAccountActivity` can be used where `BaseAccountActivity` is expected? Indicates __inheritance__.

Does `CreateAccountActivity` want only some/part of the behavior exposed by `BaseAccountActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  24 </span>import com.airthings.uicomponents.view.inputcontainerlayout.PasswordInputContainerLayout
<span class="lineno">  25 </span>import java.util.ArrayList
<span class="lineno">  26 </span>
<span class="lineno">  27 </span><span class="error">class CreateAccountActivity : BaseAccountActivity&lt;CreateAccountViewModel&gt;(), InputValidatorListener {</span>
<span class="lineno">  28 </span><span class="error">    override val viewModelClass = CreateAccountViewModel::class.java</span>
<span class="lineno">  29 </span><span class="error"></span>
<span class="lineno">  30 </span><span class="error">    private lateinit var layoutName: NameInputContainerLayout</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/createaccount/CreateAccountViewModel.kt:12:1</span><span class="message">The class `CreateAccountViewModel` is using inheritance, consider using composition instead.

Does `CreateAccountViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `CreateAccountViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `CreateAccountViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.airthings.repository.storage.StorageServiceRepository
<span class="lineno">  10 </span>import javax.inject.Inject
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class CreateAccountViewModel @Inject constructor(</span>
<span class="lineno">  13 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  14 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  15 </span><span class="error">    internetServiceRepository: InternetServiceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/dashboard/DeviceSummaryActivity.kt:45:1</span><span class="message">The class `DeviceSummaryActivity` is using inheritance, consider using composition instead.

Does `DeviceSummaryActivity` want to expose the complete interface (`requestBluetoothEnable, requestLocationPermission, requestBluetoothAdminPermission, requestBluetoothPermission, onRequestPermissionsResult, onNewIntent, onResume, onDestroy, injectViewModelFactory, onCreate`) of `BaseActivity` such that `DeviceSummaryActivity` can be used where `BaseActivity` is expected? Indicates __inheritance__.

Does `DeviceSummaryActivity` want only some/part of the behavior exposed by `BaseActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  42 </span>import java.util.Date
<span class="lineno">  43 </span>import kotlinx.android.synthetic.main.activity_device_summary.*
<span class="lineno">  44 </span>
<span class="lineno">  45 </span><span class="error">class DeviceSummaryActivity : BaseActivity&lt;DeviceSummaryViewModel&gt;() {</span>
<span class="lineno">  46 </span><span class="error">    override val viewModelClass: Class&lt;DeviceSummaryViewModel&gt; = DeviceSummaryViewModel::class.java</span>
<span class="lineno">  47 </span><span class="error">    override val fwUpdateAvailableClickHandler = LaunchFwUpdateFragmentOperation()</span>
<span class="lineno">  48 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/dashboard/DeviceSummaryViewModel.kt:19:1</span><span class="message">The class `DeviceSummaryViewModel` is using inheritance, consider using composition instead.

Does `DeviceSummaryViewModel` want to expose the complete interface (`loadDevice, discoverOwnDevices`) of `DeviceViewModel` such that `DeviceSummaryViewModel` can be used where `DeviceViewModel` is expected? Indicates __inheritance__.

Does `DeviceSummaryViewModel` want only some/part of the behavior exposed by `DeviceViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>import com.airthings.airthings.widget.circleview.CircleViewResources
<span class="lineno">  17 </span>import javax.inject.Inject
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">class DeviceSummaryViewModel @Inject constructor(</span>
<span class="lineno">  20 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  21 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  22 </span><span class="error">    userRepository: UserRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/DetailDashboardViewModel.kt:30:1</span><span class="message">The class `DetailDashboardViewModel` is using inheritance, consider using composition instead.

Does `DetailDashboardViewModel` want to expose the complete interface (`loadDevice, discoverOwnDevices`) of `DeviceViewModel` such that `DetailDashboardViewModel` can be used where `DeviceViewModel` is expected? Indicates __inheritance__.

Does `DetailDashboardViewModel` want only some/part of the behavior exposed by `DeviceViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  27 </span>import java.util.TreeMap
<span class="lineno">  28 </span>import javax.inject.Inject
<span class="lineno">  29 </span>
<span class="lineno">  30 </span><span class="error">class DetailDashboardViewModel @Inject constructor(</span>
<span class="lineno">  31 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  32 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  33 </span><span class="error">    userRepository: UserRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/DetailedDashboardContainerActivity.kt:26:1</span><span class="message">The class `DetailedDashboardContainerActivity` is using inheritance, consider using composition instead.

Does `DetailedDashboardContainerActivity` want to expose the complete interface (`requestBluetoothEnable, requestLocationPermission, requestBluetoothAdminPermission, requestBluetoothPermission, onRequestPermissionsResult, onNewIntent, onResume, onDestroy, injectViewModelFactory, onCreate`) of `BaseActivity` such that `DetailedDashboardContainerActivity` can be used where `BaseActivity` is expected? Indicates __inheritance__.

Does `DetailedDashboardContainerActivity` want only some/part of the behavior exposed by `BaseActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  23 </span>import com.google.android.material.tabs.TabLayout
<span class="lineno">  24 </span>import kotlinx.android.synthetic.main.activity_detailed_dashboard_container.*
<span class="lineno">  25 </span>
<span class="lineno">  26 </span><span class="error">class DetailedDashboardContainerActivity : BaseActivity&lt;DetailDashboardViewModel&gt;(),</span>
<span class="lineno">  27 </span><span class="error">    DetailedViewPagerDelegate {</span>
<span class="lineno">  28 </span><span class="error">    override val viewModelClass: Class&lt;DetailDashboardViewModel&gt; =</span>
<span class="lineno">  29 </span><span class="error">        DetailDashboardViewModel::class.java</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/DetailedDashboardText.kt:18:1</span><span class="message">The class `DetailedDashboardTextRes` is using inheritance, consider using composition instead.

Does `DetailedDashboardTextRes` want to expose the complete interface (`empty public interface`) of `DetailedDashboardText` such that `DetailedDashboardTextRes` can be used where `DetailedDashboardText` is expected? Indicates __inheritance__.

Does `DetailedDashboardTextRes` want only some/part of the behavior exposed by `DetailedDashboardText`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>    abstract val longLastYear: String
<span class="lineno">  16 </span>}
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">class DetailedDashboardTextRes(context: Context) : DetailedDashboardText() {</span>
<span class="lineno">  19 </span><span class="error">    override val last48Hours = context.getString(R.string.detailed_dashboard_last_48_hours).toUpperCase(Locale.getDefault())</span>
<span class="lineno">  20 </span><span class="error">    override val lastWeek = context.getString(R.string.detailed_dashboard_last_week).toUpperCase(Locale.getDefault())</span>
<span class="lineno">  21 </span><span class="error">    override val lastMonth = context.getString(R.string.detailed_dashboard_last_month).toUpperCase(Locale.getDefault())</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/GraphViewAdapterImpl.kt:7:1</span><span class="message">The class `GraphViewAdapterImpl` is using inheritance, consider using composition instead.

Does `GraphViewAdapterImpl` want to expose the complete interface (`getValue, getValueList`) of `GraphViewAdapter` such that `GraphViewAdapterImpl` can be used where `GraphViewAdapter` is expected? Indicates __inheritance__.

Does `GraphViewAdapterImpl` want only some/part of the behavior exposed by `GraphViewAdapter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.uicomponents.view.widget.graph.GraphDefines
<span class="lineno">   5 </span>import com.airthings.uicomponents.view.widget.graph.GraphViewAdapter
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">class GraphViewAdapterImpl(</span>
<span class="lineno">   8 </span><span class="error">    private val dashboardViewModel: DetailDashboardViewModel,</span>
<span class="lineno">   9 </span><span class="error">    yellowLevel: Int,</span>
<span class="lineno">  10 </span><span class="error">    redLevel: Int</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/detaileddashboard/view/SensorHistoryViewModel.kt:13:1</span><span class="message">The class `SensorHistoryViewModel` is using inheritance, consider using composition instead.

Does `SensorHistoryViewModel` want to expose the complete interface (`loadDevice, discoverOwnDevices`) of `DeviceViewModel` such that `SensorHistoryViewModel` can be used where `DeviceViewModel` is expected? Indicates __inheritance__.

Does `SensorHistoryViewModel` want only some/part of the behavior exposed by `DeviceViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import com.airthings.airthings.repository.storage.StorageServiceRepository
<span class="lineno">  11 </span>import javax.inject.Inject
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class SensorHistoryViewModel @Inject constructor(</span>
<span class="lineno">  14 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  15 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  16 </span><span class="error">    userRepository: UserRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/devicemenu/DevicesActivity.kt:13:1</span><span class="message">The class `DevicesActivity` is using inheritance, consider using composition instead.

Does `DevicesActivity` want to expose the complete interface (`requestBluetoothEnable, requestLocationPermission, requestBluetoothAdminPermission, requestBluetoothPermission, onRequestPermissionsResult, onNewIntent, onResume, onDestroy, injectViewModelFactory, onCreate`) of `BaseActivity` such that `DevicesActivity` can be used where `BaseActivity` is expected? Indicates __inheritance__.

Does `DevicesActivity` want only some/part of the behavior exposed by `BaseActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import com.airthings.airthings.wizard.device.page.progress.WizardActivity.Companion.STATE_NAVIGATOR_INITIAL_PAGE
<span class="lineno">  11 </span>import com.airthings.utilities.Log
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class DevicesActivity : BaseActivity&lt;DevicesViewModel&gt;() {</span>
<span class="lineno">  14 </span><span class="error">    override val viewModelClass = DevicesViewModel::class.java</span>
<span class="lineno">  15 </span><span class="error"></span>
<span class="lineno">  16 </span><span class="error">    override fun onCreate(savedInstanceState: Bundle?) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/devicemenu/DevicesListAdapter.kt:62:5</span><span class="message">The class `RoomViewHolder` is using inheritance, consider using composition instead.

Does `RoomViewHolder` want to expose the complete interface (`render`) of `ViewHolder` such that `RoomViewHolder` can be used where `ViewHolder` is expected? Indicates __inheritance__.

Does `RoomViewHolder` want only some/part of the behavior exposed by `ViewHolder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  59 </span>        }
<span class="lineno">  60 </span>    }
<span class="lineno">  61 </span>
<span class="lineno">  62 </span>    <span class="error">class RoomViewHolder(view: View) : ViewHolder(view) {</span>
<span class="lineno">  63 </span><span class="error">        override val textView: TextView = view.findViewById(R.id.lblRoom)</span>
<span class="lineno">  64 </span><span class="error"></span>
<span class="lineno">  65 </span><span class="error">        companion object {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/devicemenu/DevicesListAdapter.kt:70:5</span><span class="message">The class `LocationViewHolder` is using inheritance, consider using composition instead.

Does `LocationViewHolder` want to expose the complete interface (`render`) of `ViewHolder` such that `LocationViewHolder` can be used where `ViewHolder` is expected? Indicates __inheritance__.

Does `LocationViewHolder` want only some/part of the behavior exposed by `ViewHolder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  67 </span>        }
<span class="lineno">  68 </span>    }
<span class="lineno">  69 </span>
<span class="lineno">  70 </span>    <span class="error">class LocationViewHolder(view: View) : ViewHolder(view) {</span>
<span class="lineno">  71 </span><span class="error">        override val textView: TextView = view.findViewById(R.id.lblLocation)</span>
<span class="lineno">  72 </span><span class="error"></span>
<span class="lineno">  73 </span><span class="error">        companion object {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/devicemenu/DevicesViewModel.kt:12:1</span><span class="message">The class `DevicesViewModel` is using inheritance, consider using composition instead.

Does `DevicesViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `DevicesViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `DevicesViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.airthings.repository.storage.StorageServiceRepository
<span class="lineno">  10 </span>import javax.inject.Inject
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class DevicesViewModel @Inject constructor(</span>
<span class="lineno">  13 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  14 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  15 </span><span class="error">    internetServiceRepository: InternetServiceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/devicemenu/MyDevicesActivity.kt:14:1</span><span class="message">The class `MyDevicesActivity` is using inheritance, consider using composition instead.

Does `MyDevicesActivity` want to expose the complete interface (`requestBluetoothEnable, requestLocationPermission, requestBluetoothAdminPermission, requestBluetoothPermission, onRequestPermissionsResult, onNewIntent, onResume, onDestroy, injectViewModelFactory, onCreate`) of `BaseActivity` such that `MyDevicesActivity` can be used where `BaseActivity` is expected? Indicates __inheritance__.

Does `MyDevicesActivity` want only some/part of the behavior exposed by `BaseActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import kotlinx.android.synthetic.main.activity_my_devices.back_button
<span class="lineno">  12 </span>import kotlinx.android.synthetic.main.activity_my_devices.my_devices_list
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">class MyDevicesActivity : BaseActivity&lt;MyDevicesViewModel&gt;() {</span>
<span class="lineno">  15 </span><span class="error">    override val viewModelClass = MyDevicesViewModel::class.java</span>
<span class="lineno">  16 </span><span class="error"></span>
<span class="lineno">  17 </span><span class="error">    private val devicesListAdapter = DevicesListAdapter()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/devicemenu/MyDevicesViewModel.kt:17:1</span><span class="message">The class `MyDevicesViewModel` is using inheritance, consider using composition instead.

Does `MyDevicesViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `MyDevicesViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `MyDevicesViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  14 </span>import com.airthings.airthings.utils.map
<span class="lineno">  15 </span>import javax.inject.Inject
<span class="lineno">  16 </span>
<span class="lineno">  17 </span><span class="error">class MyDevicesViewModel @Inject constructor(</span>
<span class="lineno">  18 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  19 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  20 </span><span class="error">    private val deviceRepository: DeviceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/forgotpassword/ConfirmForgotPasswordFragment.kt:24:1</span><span class="message">The class `ConfirmForgotPasswordFragment` is using inheritance, consider using composition instead.

Does `ConfirmForgotPasswordFragment` want to expose the complete interface (`presentError, inputBecameInvalid, inputBecameValid`) of `ForgotPasswordBaseFragment` such that `ConfirmForgotPasswordFragment` can be used where `ForgotPasswordBaseFragment` is expected? Indicates __inheritance__.

Does `ConfirmForgotPasswordFragment` want only some/part of the behavior exposed by `ForgotPasswordBaseFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  21 </span>import java.util.ArrayList
<span class="lineno">  22 </span>import kotlinx.android.synthetic.main.fragment_confirm_forgot_password.*
<span class="lineno">  23 </span>
<span class="lineno">  24 </span><span class="error">class ConfirmForgotPasswordFragment : ForgotPasswordBaseFragment() {</span>
<span class="lineno">  25 </span><span class="error">    override val inputContainerValidatorWrapper: InputContainerValidatorWrapper =</span>
<span class="lineno">  26 </span><span class="error">        InputContainerValidatorWrapper(this)</span>
<span class="lineno">  27 </span><span class="error">    override var nextButton: Button? = null</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/forgotpassword/ForgotPasswordActivity.kt:12:1</span><span class="message">The class `ForgotPasswordActivity` is using inheritance, consider using composition instead.

Does `ForgotPasswordActivity` want to expose the complete interface (`onUnAuthenticated, onCreate`) of `BaseAccountActivity` such that `ForgotPasswordActivity` can be used where `BaseAccountActivity` is expected? Indicates __inheritance__.

Does `ForgotPasswordActivity` want only some/part of the behavior exposed by `BaseAccountActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.airthings.usecase.login.BaseAccountActivity
<span class="lineno">  10 </span>import com.airthings.airthings.usecase.selectinstrument.SelectInstrumentActivity
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class ForgotPasswordActivity : BaseAccountActivity&lt;ForgotPasswordViewModel&gt;() {</span>
<span class="lineno">  13 </span><span class="error">    override val viewModelClass = ForgotPasswordViewModel::class.java</span>
<span class="lineno">  14 </span><span class="error"></span>
<span class="lineno">  15 </span><span class="error">    override fun onAuthenticated() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/forgotpassword/ForgotPasswordBaseFragment.kt:13:1</span><span class="message">The class `ForgotPasswordBaseFragment` is using inheritance, consider using composition instead.

Does `ForgotPasswordBaseFragment` want to expose the complete interface (`Exposing interface of a Java superclass is not supported`) of `AccountBaseFragment` such that `ForgotPasswordBaseFragment` can be used where `AccountBaseFragment` is expected? Indicates __inheritance__.

Does `ForgotPasswordBaseFragment` want only some/part of the behavior exposed by `AccountBaseFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import com.airthings.uicomponents.validation.InputValidatorListener
<span class="lineno">  11 </span>import java.util.Locale
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">abstract class ForgotPasswordBaseFragment : AccountBaseFragment(), InputValidatorListener {</span>
<span class="lineno">  14 </span><span class="error"></span>
<span class="lineno">  15 </span><span class="error">    abstract val inputContainerValidatorWrapper: InputContainerValidatorWrapper</span>
<span class="lineno">  16 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/forgotpassword/ForgotPasswordFragment.kt:19:1</span><span class="message">The class `ForgotPasswordFragment` is using inheritance, consider using composition instead.

Does `ForgotPasswordFragment` want to expose the complete interface (`presentError, inputBecameInvalid, inputBecameValid`) of `ForgotPasswordBaseFragment` such that `ForgotPasswordFragment` can be used where `ForgotPasswordBaseFragment` is expected? Indicates __inheritance__.

Does `ForgotPasswordFragment` want only some/part of the behavior exposed by `ForgotPasswordBaseFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>import java.util.ArrayList
<span class="lineno">  17 </span>import kotlinx.android.synthetic.main.fragment_forgot_password.*
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">class ForgotPasswordFragment : ForgotPasswordBaseFragment() {</span>
<span class="lineno">  20 </span><span class="error">    override val inputContainerValidatorWrapper = InputContainerValidatorWrapper(this)</span>
<span class="lineno">  21 </span><span class="error">    override var nextButton: Button? = null</span>
<span class="lineno">  22 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/forgotpassword/ForgotPasswordViewModel.kt:14:1</span><span class="message">The class `ForgotPasswordViewModel` is using inheritance, consider using composition instead.

Does `ForgotPasswordViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `ForgotPasswordViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `ForgotPasswordViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.airthings.repository.storage.StorageServiceRepository
<span class="lineno">  12 </span>import javax.inject.Inject
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">class ForgotPasswordViewModel @Inject constructor(</span>
<span class="lineno">  15 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  16 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  17 </span><span class="error">    internetServiceRepository: InternetServiceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/instrumentInfo/InstrumentInfoFragment.kt:19:1</span><span class="message">The class `InstrumentInfoFragment` is using inheritance, consider using composition instead.

Does `InstrumentInfoFragment` want to expose the complete interface (`onDetach, onAttach`) of `NavigableFragment` such that `InstrumentInfoFragment` can be used where `NavigableFragment` is expected? Indicates __inheritance__.

Does `InstrumentInfoFragment` want only some/part of the behavior exposed by `NavigableFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>import com.airthings.airthings.utils.viewModel
<span class="lineno">  17 </span>import kotlinx.android.synthetic.main.fragment_instrument_info.*
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">class InstrumentInfoFragment : NavigableFragment() {</span>
<span class="lineno">  20 </span><span class="error">    private val viewModel: InstrumentInfoViewModel by viewModel()</span>
<span class="lineno">  21 </span><span class="error"></span>
<span class="lineno">  22 </span><span class="error">    companion object {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/instrumentInfo/InstrumentInfoViewModel.kt:14:1</span><span class="message">The class `InstrumentInfoViewModel` is using inheritance, consider using composition instead.

Does `InstrumentInfoViewModel` want to expose the complete interface (`loadDevice, discoverOwnDevices`) of `DeviceViewModel` such that `InstrumentInfoViewModel` can be used where `DeviceViewModel` is expected? Indicates __inheritance__.

Does `InstrumentInfoViewModel` want only some/part of the behavior exposed by `DeviceViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.airthings.utils.suspendGetValue
<span class="lineno">  12 </span>import javax.inject.Inject
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">class InstrumentInfoViewModel @Inject constructor(</span>
<span class="lineno">  15 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  16 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  17 </span><span class="error">    userRepository: UserRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/login/BaseAccountActivity.kt:16:1</span><span class="message">The class `BaseAccountActivity` is using inheritance, consider using composition instead.

Does `BaseAccountActivity` want to expose the complete interface (`requestBluetoothEnable, requestLocationPermission, requestBluetoothAdminPermission, requestBluetoothPermission, onRequestPermissionsResult, onNewIntent, onResume, onDestroy, injectViewModelFactory, onCreate`) of `BaseActivity` such that `BaseAccountActivity` can be used where `BaseActivity` is expected? Indicates __inheritance__.

Does `BaseAccountActivity` want only some/part of the behavior exposed by `BaseActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import com.airthings.utilities.Log
<span class="lineno">  14 </span>import java.util.ArrayList
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">abstract class BaseAccountActivity&lt;VM : AirthingsViewModel&gt; : BaseActivity&lt;VM&gt;() {</span>
<span class="lineno">  17 </span><span class="error"></span>
<span class="lineno">  18 </span><span class="error">    protected var activityRootView: View? = null</span>
<span class="lineno">  19 </span><span class="error">    protected var dynamicLinearLayout: LinearLayout? = null</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/login/LoginActivity.kt:30:1</span><span class="message">The class `LoginActivity` is using inheritance, consider using composition instead.

Does `LoginActivity` want to expose the complete interface (`onUnAuthenticated, onCreate`) of `BaseAccountActivity` such that `LoginActivity` can be used where `BaseAccountActivity` is expected? Indicates __inheritance__.

Does `LoginActivity` want only some/part of the behavior exposed by `BaseAccountActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  27 </span>import java.util.Locale
<span class="lineno">  28 </span>import kotlinx.coroutines.Job
<span class="lineno">  29 </span>
<span class="lineno">  30 </span><span class="error">class LoginActivity : BaseAccountActivity&lt;LoginViewModel&gt;(), InputValidatorListener {</span>
<span class="lineno">  31 </span><span class="error">    companion object {</span>
<span class="lineno">  32 </span><span class="error">        private val TAG = LoginActivity::class.java.simpleName</span>
<span class="lineno">  33 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/login/LoginViewModel.kt:14:1</span><span class="message">The class `LoginViewModel` is using inheritance, consider using composition instead.

Does `LoginViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `LoginViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `LoginViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.airthings.repository.storage.StorageServiceRepository
<span class="lineno">  12 </span>import javax.inject.Inject
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">class LoginViewModel @Inject constructor(</span>
<span class="lineno">  15 </span><span class="error">    private val deviceRepository: DeviceRepository,</span>
<span class="lineno">  16 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  17 </span><span class="error">    userRepository: UserRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageaccount/AccountActivity.kt:15:1</span><span class="message">The class `AccountActivity` is using inheritance, consider using composition instead.

Does `AccountActivity` want to expose the complete interface (`requestBluetoothEnable, requestLocationPermission, requestBluetoothAdminPermission, requestBluetoothPermission, onRequestPermissionsResult, onNewIntent, onResume, onDestroy, injectViewModelFactory, onCreate`) of `BaseActivity` such that `AccountActivity` can be used where `BaseActivity` is expected? Indicates __inheritance__.

Does `AccountActivity` want only some/part of the behavior exposed by `BaseActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>import com.airthings.airthings.utils.uiDispatch
<span class="lineno">  13 </span>import kotlinx.android.synthetic.main.activity_manage_account.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">class AccountActivity : BaseActivity&lt;ManageAccountViewModel&gt;() {</span>
<span class="lineno">  16 </span><span class="error">    override val viewModelClass = ManageAccountViewModel::class.java</span>
<span class="lineno">  17 </span><span class="error">    private lateinit var waitDialog: ProgressDialog</span>
<span class="lineno">  18 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageaccount/ManageAccountViewModel.kt:17:1</span><span class="message">The class `ManageAccountViewModel` is using inheritance, consider using composition instead.

Does `ManageAccountViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `ManageAccountViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `ManageAccountViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  14 </span>import com.airthings.airthings.utils.not
<span class="lineno">  15 </span>import javax.inject.Inject
<span class="lineno">  16 </span>
<span class="lineno">  17 </span><span class="error">class ManageAccountViewModel @Inject constructor(</span>
<span class="lineno">  18 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  19 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  20 </span><span class="error">    internetServiceRepository: InternetServiceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageinstrument/ManageDeviceViewModel.kt:26:1</span><span class="message">The class `ManageDeviceViewModel` is using inheritance, consider using composition instead.

Does `ManageDeviceViewModel` want to expose the complete interface (`loadDevice, discoverOwnDevices`) of `DeviceViewModel` such that `ManageDeviceViewModel` can be used where `DeviceViewModel` is expected? Indicates __inheritance__.

Does `ManageDeviceViewModel` want only some/part of the behavior exposed by `DeviceViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  23 </span>import com.airthings.utilities.Log
<span class="lineno">  24 </span>import javax.inject.Inject
<span class="lineno">  25 </span>
<span class="lineno">  26 </span><span class="error">class ManageDeviceViewModel @Inject constructor(</span>
<span class="lineno">  27 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  28 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  29 </span><span class="error">    deviceRepository: DeviceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageinstrument/UpdateDevicePage.kt:7:1</span><span class="message">The class `UpdateDevicePage` is using inheritance, consider using composition instead.

Does `UpdateDevicePage` want to expose the complete interface (`onError, onProgress, onDone, onResume, onPause, onStart, onViewCreated, bind`) of `BaseProgressPage` such that `UpdateDevicePage` can be used where `BaseProgressPage` is expected? Indicates __inheritance__.

Does `UpdateDevicePage` want only some/part of the behavior exposed by `BaseProgressPage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.airthings.wizard.device.page.progress.ProgressStep
<span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.page.progress.UpdateFirmwareProgressStep
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class UpdateDevicePage : BaseProgressPage() {</span>
<span class="lineno">   8 </span><span class="error">    private lateinit var identifierOfLastStep: String</span>
<span class="lineno">   9 </span><span class="error"></span>
<span class="lineno">  10 </span><span class="error">    override fun enumerateStepsForHub() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageinstrument/UpdateDevicePagerAdapter.kt:11:1</span><span class="message">The class `UpdateDevicePagerAdapter` is using inheritance, consider using composition instead.

Does `UpdateDevicePagerAdapter` want to expose the complete interface (`onPageScrollStateChanged, onPageSelected, onPageScrolled, containsItem, getItemId, getItemCount, createFragment, createFragment`) of `WizardPagerAdapter` such that `UpdateDevicePagerAdapter` can be used where `WizardPagerAdapter` is expected? Indicates __inheritance__.

Does `UpdateDevicePagerAdapter` want only some/part of the behavior exposed by `WizardPagerAdapter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.uicomponents.wizard.WizardPageFragment
<span class="lineno">   9 </span>import com.airthings.uicomponents.wizard.WizardPagerAdapter
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class UpdateDevicePagerAdapter(</span>
<span class="lineno">  12 </span><span class="error">    activity: WizardActivity,</span>
<span class="lineno">  13 </span><span class="error">    navigator: WizardNavigatorConfig</span>
<span class="lineno">  14 </span><span class="error">) :</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageinstrument/UpdateDeviceWizard.kt:16:1</span><span class="message">The class `UpdateDeviceWizard` is using inheritance, consider using composition instead.

Does `UpdateDeviceWizard` want to expose the complete interface (`onRestoreInstanceState, onSaveInstanceState, onDestroy, onCreate, replace, remove, add, add, goBackwardIfAllowed, goBackward, goForward, goto`) of `Wizard` such that `UpdateDeviceWizard` can be used where `Wizard` is expected? Indicates __inheritance__.

Does `UpdateDeviceWizard` want only some/part of the behavior exposed by `Wizard`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import com.airthings.uicomponents.wizard.WizardPagerAdapter
<span class="lineno">  14 </span>import com.airthings.uicomponents.wizard.WizardStateHandler
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">internal class UpdateDeviceWizard(</span>
<span class="lineno">  17 </span><span class="error">    val activity: WizardActivity,</span>
<span class="lineno">  18 </span><span class="error">    navigator: WizardNavigatorConfig,</span>
<span class="lineno">  19 </span><span class="error">    pagerAdapter: WizardPagerAdapter,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/manageinstrument/UpdateDeviceWizardActivity.kt:14:1</span><span class="message">The class `UpdateDeviceWizardActivity` is using inheritance, consider using composition instead.

Does `UpdateDeviceWizardActivity` want to expose the complete interface (`possiblyCancelWizard, possiblyGotoPreviousPageOrExit, onRestoreInstanceState, onSaveInstanceState, onBackPressed, onDestroy, createNavigator, onCreate`) of `WizardActivity` such that `UpdateDeviceWizardActivity` can be used where `WizardActivity` is expected? Indicates __inheritance__.

Does `UpdateDeviceWizardActivity` want only some/part of the behavior exposed by `WizardActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.uicomponents.wizard.WizardNavigatorConfig
<span class="lineno">  12 </span>import com.airthings.uicomponents.wizard.WizardPage
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">class UpdateDeviceWizardActivity : WizardActivity() {</span>
<span class="lineno">  15 </span><span class="error"></span>
<span class="lineno">  16 </span><span class="error">    override fun onCreate(savedInstanceState: Bundle?) {</span>
<span class="lineno">  17 </span><span class="error">        super.onCreate(savedInstanceState)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/onboarding/OnBoardingViewModel.kt:12:1</span><span class="message">The class `OnBoardingViewModel` is using inheritance, consider using composition instead.

Does `OnBoardingViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `OnBoardingViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `OnBoardingViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.airthings.repository.storage.StorageServiceRepository
<span class="lineno">  10 </span>import javax.inject.Inject
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class OnBoardingViewModel @Inject constructor(</span>
<span class="lineno">  13 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  14 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  15 </span><span class="error">    internetServiceRepository: InternetServiceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/onboarding/OnboardingContainerActivity.kt:17:1</span><span class="message">The class `OnboardingContainerActivity` is using inheritance, consider using composition instead.

Does `OnboardingContainerActivity` want to expose the complete interface (`requestBluetoothEnable, requestLocationPermission, requestBluetoothAdminPermission, requestBluetoothPermission, onRequestPermissionsResult, onNewIntent, onResume, onDestroy, injectViewModelFactory, onCreate`) of `BaseActivity` such that `OnboardingContainerActivity` can be used where `BaseActivity` is expected? Indicates __inheritance__.

Does `OnboardingContainerActivity` want only some/part of the behavior exposed by `BaseActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  14 </span>import com.airthings.airthings.usecase.selectinstrument.SelectInstrumentActivity
<span class="lineno">  15 </span>import kotlinx.android.synthetic.main.activity_onboarding.*
<span class="lineno">  16 </span>
<span class="lineno">  17 </span><span class="error">class OnboardingContainerActivity : BaseActivity&lt;OnBoardingViewModel&gt;() {</span>
<span class="lineno">  18 </span><span class="error">    override val viewModelClass: Class&lt;OnBoardingViewModel&gt; = OnBoardingViewModel::class.java</span>
<span class="lineno">  19 </span><span class="error"></span>
<span class="lineno">  20 </span><span class="error">    private val LOCAL_APP_HISTORY = &quot;LOCAL_APP_HISTORY&quot;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/onboarding/OnboardingPageFragment.kt:26:1</span><span class="message">The class `OnboardingPage1Fragment` is using inheritance, consider using composition instead.

Does `OnboardingPage1Fragment` want to expose the complete interface (`onCreateView`) of `OnboardingPageFragment` such that `OnboardingPage1Fragment` can be used where `OnboardingPageFragment` is expected? Indicates __inheritance__.

Does `OnboardingPage1Fragment` want only some/part of the behavior exposed by `OnboardingPageFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  23 </span>    }
<span class="lineno">  24 </span>}
<span class="lineno">  25 </span>
<span class="lineno">  26 </span><span class="error">class OnboardingPage1Fragment : OnboardingPageFragment() {</span>
<span class="lineno">  27 </span><span class="error">    override val layoutResource: Int = R.layout.onboarding_page1</span>
<span class="lineno">  28 </span><span class="error">    override val imageResource: Int = R.drawable.onboarding_screen_1_graphic</span>
<span class="lineno">  29 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/onboarding/OnboardingPageFragment.kt:31:1</span><span class="message">The class `OnboardingPage2Fragment` is using inheritance, consider using composition instead.

Does `OnboardingPage2Fragment` want to expose the complete interface (`onCreateView`) of `OnboardingPageFragment` such that `OnboardingPage2Fragment` can be used where `OnboardingPageFragment` is expected? Indicates __inheritance__.

Does `OnboardingPage2Fragment` want only some/part of the behavior exposed by `OnboardingPageFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  28 </span>    override val imageResource: Int = R.drawable.onboarding_screen_1_graphic
<span class="lineno">  29 </span>}
<span class="lineno">  30 </span>
<span class="lineno">  31 </span><span class="error">class OnboardingPage2Fragment : OnboardingPageFragment() {</span>
<span class="lineno">  32 </span><span class="error">    override val layoutResource: Int = R.layout.onboarding_page2</span>
<span class="lineno">  33 </span><span class="error">    override val imageResource: Int = R.drawable.onboarding_screen_2_graphic</span>
<span class="lineno">  34 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/onboarding/OnboardingPageFragment.kt:36:1</span><span class="message">The class `OnboardingPage3Fragment` is using inheritance, consider using composition instead.

Does `OnboardingPage3Fragment` want to expose the complete interface (`onCreateView`) of `OnboardingPageFragment` such that `OnboardingPage3Fragment` can be used where `OnboardingPageFragment` is expected? Indicates __inheritance__.

Does `OnboardingPage3Fragment` want only some/part of the behavior exposed by `OnboardingPageFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  33 </span>    override val imageResource: Int = R.drawable.onboarding_screen_2_graphic
<span class="lineno">  34 </span>}
<span class="lineno">  35 </span>
<span class="lineno">  36 </span><span class="error">class OnboardingPage3Fragment : OnboardingPageFragment() {</span>
<span class="lineno">  37 </span><span class="error">    override val layoutResource: Int = R.layout.onboarding_page3</span>
<span class="lineno">  38 </span><span class="error">    override val imageResource: Int = R.drawable.onboarding_screen_3_graphic</span>
<span class="lineno">  39 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/onboarding/OnboardingPageFragment.kt:41:1</span><span class="message">The class `OnboardingPage4Fragment` is using inheritance, consider using composition instead.

Does `OnboardingPage4Fragment` want to expose the complete interface (`onCreateView`) of `OnboardingPageFragment` such that `OnboardingPage4Fragment` can be used where `OnboardingPageFragment` is expected? Indicates __inheritance__.

Does `OnboardingPage4Fragment` want only some/part of the behavior exposed by `OnboardingPageFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  38 </span>    override val imageResource: Int = R.drawable.onboarding_screen_3_graphic
<span class="lineno">  39 </span>}
<span class="lineno">  40 </span>
<span class="lineno">  41 </span><span class="error">class OnboardingPage4Fragment : OnboardingPageFragment() {</span>
<span class="lineno">  42 </span><span class="error">    override val layoutResource: Int = R.layout.onboarding_page4</span>
<span class="lineno">  43 </span><span class="error">    override val imageResource: Int = R.drawable.onboarding_screen_4_graphic</span>
<span class="lineno">  44 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/onboarding/OnboardingPageFragment.kt:46:1</span><span class="message">The class `OnboardingPage5Fragment` is using inheritance, consider using composition instead.

Does `OnboardingPage5Fragment` want to expose the complete interface (`onCreateView`) of `OnboardingPageFragment` such that `OnboardingPage5Fragment` can be used where `OnboardingPageFragment` is expected? Indicates __inheritance__.

Does `OnboardingPage5Fragment` want only some/part of the behavior exposed by `OnboardingPageFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  43 </span>    override val imageResource: Int = R.drawable.onboarding_screen_4_graphic
<span class="lineno">  44 </span>}
<span class="lineno">  45 </span>
<span class="lineno">  46 </span><span class="error">class OnboardingPage5Fragment : OnboardingPageFragment() {</span>
<span class="lineno">  47 </span><span class="error">    override val layoutResource: Int = R.layout.onboarding_page5</span>
<span class="lineno">  48 </span><span class="error">    override val imageResource: Int = R.drawable.onboarding_screen_5_wave</span>
<span class="lineno">  49 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/onboarding/OnboardingPageFragment.kt:51:1</span><span class="message">The class `OnboardingPage6Fragment` is using inheritance, consider using composition instead.

Does `OnboardingPage6Fragment` want to expose the complete interface (`onCreateView`) of `OnboardingPageFragment` such that `OnboardingPage6Fragment` can be used where `OnboardingPageFragment` is expected? Indicates __inheritance__.

Does `OnboardingPage6Fragment` want only some/part of the behavior exposed by `OnboardingPageFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  48 </span>    override val imageResource: Int = R.drawable.onboarding_screen_5_wave
<span class="lineno">  49 </span>}
<span class="lineno">  50 </span>
<span class="lineno">  51 </span><span class="error">class OnboardingPage6Fragment : OnboardingPageFragment() {</span>
<span class="lineno">  52 </span><span class="error">    override val layoutResource: Int = R.layout.onboarding_page6</span>
<span class="lineno">  53 </span><span class="error">    override val imageResource: Int = R.drawable.onboarding_screen_6_graphic</span>
<span class="lineno">  54 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/onboarding/OnboardingPageFragment.kt:56:1</span><span class="message">The class `OnboardingPage7Fragment` is using inheritance, consider using composition instead.

Does `OnboardingPage7Fragment` want to expose the complete interface (`onCreateView`) of `OnboardingPageFragment` such that `OnboardingPage7Fragment` can be used where `OnboardingPageFragment` is expected? Indicates __inheritance__.

Does `OnboardingPage7Fragment` want only some/part of the behavior exposed by `OnboardingPageFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  53 </span>    override val imageResource: Int = R.drawable.onboarding_screen_6_graphic
<span class="lineno">  54 </span>}
<span class="lineno">  55 </span>
<span class="lineno">  56 </span><span class="error">class OnboardingPage7Fragment : OnboardingPageFragment() {</span>
<span class="lineno">  57 </span><span class="error">    override val layoutResource: Int = R.layout.onboarding_page7</span>
<span class="lineno">  58 </span><span class="error">    override val imageResource: Int = R.drawable.onboarding_screen_7_graphic</span>
<span class="lineno">  59 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/selectinstrument/SelectInstrumentActivity.kt:39:1</span><span class="message">The class `SelectInstrumentActivity` is using inheritance, consider using composition instead.

Does `SelectInstrumentActivity` want to expose the complete interface (`requestBluetoothEnable, requestLocationPermission, requestBluetoothAdminPermission, requestBluetoothPermission, onRequestPermissionsResult, onNewIntent, onResume, onDestroy, injectViewModelFactory, onCreate`) of `BaseActivity` such that `SelectInstrumentActivity` can be used where `BaseActivity` is expected? Indicates __inheritance__.

Does `SelectInstrumentActivity` want only some/part of the behavior exposed by `BaseActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  36 </span>import kotlinx.android.synthetic.main.activity_select_instrument_main_view.select_instrument_recyclerView
<span class="lineno">  37 </span>import kotlinx.android.synthetic.main.activity_select_instrument_main_view.sync_refresh_layout
<span class="lineno">  38 </span>
<span class="lineno">  39 </span><span class="error">class SelectInstrumentActivity : BaseActivity&lt;SelectInstrumentViewModel&gt;() {</span>
<span class="lineno">  40 </span><span class="error">    private val instrumentSelectorAdapter = UserDevicesAdapter()</span>
<span class="lineno">  41 </span><span class="error">    private val deviceObservers = mutableMapOf&lt;ConnectedUserDevice, WeakReference&lt;Observer&lt;Long&gt;&gt;&gt;()</span>
<span class="lineno">  42 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/selectinstrument/SelectInstrumentViewModel.kt:19:1</span><span class="message">The class `SelectInstrumentViewModel` is using inheritance, consider using composition instead.

Does `SelectInstrumentViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `SelectInstrumentViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `SelectInstrumentViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>import com.airthings.utilities.Log
<span class="lineno">  17 </span>import javax.inject.Inject
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">class SelectInstrumentViewModel @Inject constructor(</span>
<span class="lineno">  20 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  21 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  22 </span><span class="error">    bluetoothServiceRepository: BluetoothServiceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/selectinstrument/UserDevicesAdapter.kt:113:5</span><span class="message">The class `LocationViewHolder` is using inheritance, consider using composition instead.

Does `LocationViewHolder` want to expose the complete interface (`empty public interface`) of `ViewHolder` such that `LocationViewHolder` can be used where `ViewHolder` is expected? Indicates __inheritance__.

Does `LocationViewHolder` want only some/part of the behavior exposed by `ViewHolder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 110 </span>        }
<span class="lineno"> 111 </span>    }
<span class="lineno"> 112 </span>
<span class="lineno"> 113 </span>    <span class="error">class LocationViewHolder(itemView: View) : ViewHolder(itemView) {</span>
<span class="lineno"> 114 </span><span class="error">        val locationTextView: TextView = itemView.findViewById(R.id.instrument_location_textView)</span>
<span class="lineno"> 115 </span><span class="error">    }</span>
<span class="lineno"> 116 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/selectinstrument/UserDevicesAdapter.kt:117:5</span><span class="message">The class `InstrumentViewHolder` is using inheritance, consider using composition instead.

Does `InstrumentViewHolder` want to expose the complete interface (`empty public interface`) of `ViewHolder` such that `InstrumentViewHolder` can be used where `ViewHolder` is expected? Indicates __inheritance__.

Does `InstrumentViewHolder` want only some/part of the behavior exposed by `ViewHolder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 114 </span>        val locationTextView: TextView = itemView.findViewById(R.id.instrument_location_textView)
<span class="lineno"> 115 </span>    }
<span class="lineno"> 116 </span>
<span class="lineno"> 117 </span>    <span class="error">class InstrumentViewHolder(itemView: View) : ViewHolder(itemView) {</span>
<span class="lineno"> 118 </span><span class="error">        private val roomTextView: TextView = itemView.findViewById(R.id.instrument_room_textView)</span>
<span class="lineno"> 119 </span><span class="error">        internal val colorRingView: ColorCircleView = itemView.findViewById(R.id.color_circle)</span>
<span class="lineno"> 120 </span><span class="error">        private val instrumentType: TextView = itemView.findViewById(R.id.instrument_type_textView)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/selectinstrument/UserDevicesAdapter.kt:203:1</span><span class="message">The class `DeviceItem` is using inheritance, consider using composition instead.

Does `DeviceItem` want to expose the complete interface (`empty public interface`) of `ListItem` such that `DeviceItem` can be used where `ListItem` is expected? Indicates __inheritance__.

Does `DeviceItem` want only some/part of the behavior exposed by `ListItem`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 200 </span>    }
<span class="lineno"> 201 </span>}
<span class="lineno"> 202 </span>
<span class="lineno"> 203 </span><span class="error">class DeviceItem(val userDevice: ConnectedUserDevice) : ListItem(TYPE) {</span>
<span class="lineno"> 204 </span><span class="error"></span>
<span class="lineno"> 205 </span><span class="error">    internal val colorCircleValue: CircleViewResources.Level</span>
<span class="lineno"> 206 </span><span class="error">        get() = userDevice.latestDataPoint.value?.let { dataPoint -&gt;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/selectinstrument/UserDevicesAdapter.kt:251:1</span><span class="message">The class `LocationItem` is using inheritance, consider using composition instead.

Does `LocationItem` want to expose the complete interface (`empty public interface`) of `ListItem` such that `LocationItem` can be used where `ListItem` is expected? Indicates __inheritance__.

Does `LocationItem` want only some/part of the behavior exposed by `ListItem`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 248 </span>    }
<span class="lineno"> 249 </span>}
<span class="lineno"> 250 </span>
<span class="lineno"> 251 </span><span class="error">class LocationItem(val location: String) : ListItem(TYPE) {</span>
<span class="lineno"> 252 </span><span class="error">    internal companion object {</span>
<span class="lineno"> 253 </span><span class="error">        const val TYPE = 1</span>
<span class="lineno"> 254 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/setlocation/SetLocationProcess.kt:8:9</span><span class="message">The class `LocationChangeReq` is using inheritance, consider using composition instead.

Does `LocationChangeReq` want to expose the complete interface (`empty public interface`) of `ChangeRequest` such that `LocationChangeReq` can be used where `ChangeRequest` is expected? Indicates __inheritance__.

Does `LocationChangeReq` want only some/part of the behavior exposed by `ChangeRequest`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   5 </span>    fun openSetLocationView(lat: Double, lng: Double, countryCode: String)
<span class="lineno">   6 </span>    fun openChangeRoomView(locationChangeReq: ChangeRequest.LocationChangeReq?)
<span class="lineno">   7 </span>    sealed class ChangeRequest {
<span class="lineno">   8 </span>        <span class="error">data class LocationChangeReq(val locationName: String, val lng: Double, val lat: Double) : ChangeRequest()</span>
<span class="lineno">   9 </span>        data class LocationAndRoomChangeReq(val roomName: String, val location: LocationChangeReq) : ChangeRequest()
<span class="lineno">  10 </span>        data class RoomChangeRequest(val roomName: String) : ChangeRequest()
<span class="lineno">  11 </span>    }
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/setlocation/SetLocationProcess.kt:9:9</span><span class="message">The class `LocationAndRoomChangeReq` is using inheritance, consider using composition instead.

Does `LocationAndRoomChangeReq` want to expose the complete interface (`empty public interface`) of `ChangeRequest` such that `LocationAndRoomChangeReq` can be used where `ChangeRequest` is expected? Indicates __inheritance__.

Does `LocationAndRoomChangeReq` want only some/part of the behavior exposed by `ChangeRequest`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>    fun openChangeRoomView(locationChangeReq: ChangeRequest.LocationChangeReq?)
<span class="lineno">   7 </span>    sealed class ChangeRequest {
<span class="lineno">   8 </span>        data class LocationChangeReq(val locationName: String, val lng: Double, val lat: Double) : ChangeRequest()
<span class="lineno">   9 </span>        <span class="error">data class LocationAndRoomChangeReq(val roomName: String, val location: LocationChangeReq) : ChangeRequest()</span>
<span class="lineno">  10 </span>        data class RoomChangeRequest(val roomName: String) : ChangeRequest()
<span class="lineno">  11 </span>    }
<span class="lineno">  12 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/setlocation/SetLocationProcess.kt:10:9</span><span class="message">The class `RoomChangeRequest` is using inheritance, consider using composition instead.

Does `RoomChangeRequest` want to expose the complete interface (`empty public interface`) of `ChangeRequest` such that `RoomChangeRequest` can be used where `ChangeRequest` is expected? Indicates __inheritance__.

Does `RoomChangeRequest` want only some/part of the behavior exposed by `ChangeRequest`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>    sealed class ChangeRequest {
<span class="lineno">   8 </span>        data class LocationChangeReq(val locationName: String, val lng: Double, val lat: Double) : ChangeRequest()
<span class="lineno">   9 </span>        data class LocationAndRoomChangeReq(val roomName: String, val location: LocationChangeReq) : ChangeRequest()
<span class="lineno">  10 </span>        <span class="error">data class RoomChangeRequest(val roomName: String) : ChangeRequest()</span>
<span class="lineno">  11 </span>    }
<span class="lineno">  12 </span>}
<span class="lineno">  13 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/settingsmenu/ManageSettingsViewModel.kt:13:1</span><span class="message">The class `ManageSettingsViewModel` is using inheritance, consider using composition instead.

Does `ManageSettingsViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `ManageSettingsViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `ManageSettingsViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import com.airthings.airthings.repository.storage.StorageServiceRepository
<span class="lineno">  11 </span>import javax.inject.Inject
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class ManageSettingsViewModel @Inject constructor(</span>
<span class="lineno">  14 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  15 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  16 </span><span class="error">    internetServiceRepository: InternetServiceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/settingsmenu/SettingsActivity.kt:15:1</span><span class="message">The class `SettingsActivity` is using inheritance, consider using composition instead.

Does `SettingsActivity` want to expose the complete interface (`requestBluetoothEnable, requestLocationPermission, requestBluetoothAdminPermission, requestBluetoothPermission, onRequestPermissionsResult, onNewIntent, onResume, onDestroy, injectViewModelFactory, onCreate`) of `BaseActivity` such that `SettingsActivity` can be used where `BaseActivity` is expected? Indicates __inheritance__.

Does `SettingsActivity` want only some/part of the behavior exposed by `BaseActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>import com.airthings.utilities.Log
<span class="lineno">  13 </span>import kotlinx.android.synthetic.main.activity_settings.*
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">class SettingsActivity : BaseActivity&lt;ManageSettingsViewModel&gt;() {</span>
<span class="lineno">  16 </span><span class="error">    override val viewModelClass = ManageSettingsViewModel::class.java</span>
<span class="lineno">  17 </span><span class="error">    lateinit var waitDialog: ProgressDialog</span>
<span class="lineno">  18 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/support/SupportActivity.kt:9:1</span><span class="message">The class `SupportActivity` is using inheritance, consider using composition instead.

Does `SupportActivity` want to expose the complete interface (`requestBluetoothEnable, requestLocationPermission, requestBluetoothAdminPermission, requestBluetoothPermission, onRequestPermissionsResult, onNewIntent, onResume, onDestroy, injectViewModelFactory, onCreate`) of `BaseActivity` such that `SupportActivity` can be used where `BaseActivity` is expected? Indicates __inheritance__.

Does `SupportActivity` want only some/part of the behavior exposed by `BaseActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>import com.airthings.airthings.activities.BaseActivity
<span class="lineno">   7 </span>import io.intercom.android.sdk.Intercom
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">class SupportActivity : BaseActivity&lt;SupportViewModel&gt;() {</span>
<span class="lineno">  10 </span><span class="error">    override val viewModelClass: Class&lt;SupportViewModel&gt; = SupportViewModel::class.java</span>
<span class="lineno">  11 </span><span class="error">    override fun onCreate(savedInstanceState: Bundle?) {</span>
<span class="lineno">  12 </span><span class="error">        super.onCreate(savedInstanceState)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/support/SupportViewModel.kt:12:1</span><span class="message">The class `SupportViewModel` is using inheritance, consider using composition instead.

Does `SupportViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `SupportViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `SupportViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.airthings.repository.storage.StorageServiceRepository
<span class="lineno">  10 </span>import javax.inject.Inject
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class SupportViewModel @Inject constructor(</span>
<span class="lineno">  13 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  14 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  15 </span><span class="error">    internetServiceRepository: InternetServiceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/updatefw/FirmwareUpdateViewModel.kt:36:1</span><span class="message">The class `Updating` is using inheritance, consider using composition instead.

Does `Updating` want to expose the complete interface (`empty public interface`) of `FirmwareUpdateViewState` such that `Updating` can be used where `FirmwareUpdateViewState` is expected? Indicates __inheritance__.

Does `Updating` want only some/part of the behavior exposed by `FirmwareUpdateViewState`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  33 </span>object ForceUpdate : FirmwareUpdateViewState()
<span class="lineno">  34 </span>object NoUpdatesAvaiable : FirmwareUpdateViewState()
<span class="lineno">  35 </span>object UpdateAvailable : FirmwareUpdateViewState()
<span class="lineno">  36 </span><span class="error">data class Updating(val progress: Int, val isRebooting: Boolean) : FirmwareUpdateViewState()</span>
<span class="lineno">  37 </span>object UpdateSuccessful : FirmwareUpdateViewState()
<span class="lineno">  38 </span>data class UpdateFailed(val error: String) : FirmwareUpdateViewState()
<span class="lineno">  39 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/updatefw/FirmwareUpdateViewModel.kt:38:1</span><span class="message">The class `UpdateFailed` is using inheritance, consider using composition instead.

Does `UpdateFailed` want to expose the complete interface (`empty public interface`) of `FirmwareUpdateViewState` such that `UpdateFailed` can be used where `FirmwareUpdateViewState` is expected? Indicates __inheritance__.

Does `UpdateFailed` want only some/part of the behavior exposed by `FirmwareUpdateViewState`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  35 </span>object UpdateAvailable : FirmwareUpdateViewState()
<span class="lineno">  36 </span>data class Updating(val progress: Int, val isRebooting: Boolean) : FirmwareUpdateViewState()
<span class="lineno">  37 </span>object UpdateSuccessful : FirmwareUpdateViewState()
<span class="lineno">  38 </span><span class="error">data class UpdateFailed(val error: String) : FirmwareUpdateViewState()</span>
<span class="lineno">  39 </span>
<span class="lineno">  40 </span>class FirmwareUpdateViewModel @Inject constructor(
<span class="lineno">  41 </span>    credentialRepository: CredentialRepository,
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/usecase/updatefw/FirmwareUpdateViewModel.kt:40:1</span><span class="message">The class `FirmwareUpdateViewModel` is using inheritance, consider using composition instead.

Does `FirmwareUpdateViewModel` want to expose the complete interface (`loadDevice, discoverOwnDevices`) of `DeviceViewModel` such that `FirmwareUpdateViewModel` can be used where `DeviceViewModel` is expected? Indicates __inheritance__.

Does `FirmwareUpdateViewModel` want only some/part of the behavior exposed by `DeviceViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  37 </span>object UpdateSuccessful : FirmwareUpdateViewState()
<span class="lineno">  38 </span>data class UpdateFailed(val error: String) : FirmwareUpdateViewState()
<span class="lineno">  39 </span>
<span class="lineno">  40 </span><span class="error">class FirmwareUpdateViewModel @Inject constructor(</span>
<span class="lineno">  41 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  42 </span><span class="error">    userRepository: UserRepository,</span>
<span class="lineno">  43 </span><span class="error">    deviceRepository: DeviceRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/utils/Funcs.kt:216:1</span><span class="message">The class `RealmModelLiveData` is using inheritance, consider using composition instead.

Does `RealmModelLiveData` want to expose the complete interface (`empty public interface`) of `RealmLiveData` such that `RealmModelLiveData` can be used where `RealmLiveData` is expected? Indicates __inheritance__.

Does `RealmModelLiveData` want only some/part of the behavior exposed by `RealmLiveData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 213 </span>    protected val listener = RealmChangeListener&lt;T&gt; { t -&gt; this@RealmLiveData.value = t }
<span class="lineno"> 214 </span>}
<span class="lineno"> 215 </span>
<span class="lineno"> 216 </span><span class="error">class RealmModelLiveData&lt;T : RealmModel&gt;(data: T) : RealmLiveData&lt;T&gt;(data) {</span>
<span class="lineno"> 217 </span><span class="error">    override fun onInactive() {</span>
<span class="lineno"> 218 </span><span class="error">        super.onInactive()</span>
<span class="lineno"> 219 </span><span class="error">        this.data.removeChangeListener(this.listener)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/utils/Funcs.kt:228:1</span><span class="message">The class `RealmResultsLiveData` is using inheritance, consider using composition instead.

Does `RealmResultsLiveData` want to expose the complete interface (`empty public interface`) of `RealmLiveData` such that `RealmResultsLiveData` can be used where `RealmLiveData` is expected? Indicates __inheritance__.

Does `RealmResultsLiveData` want only some/part of the behavior exposed by `RealmLiveData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 225 </span>    }
<span class="lineno"> 226 </span>}
<span class="lineno"> 227 </span>
<span class="lineno"> 228 </span><span class="error">class RealmResultsLiveData&lt;K, T : RealmResults&lt;K&gt;&gt;(data: T) : RealmLiveData&lt;RealmResults&lt;K&gt;&gt;(data) {</span>
<span class="lineno"> 229 </span><span class="error">    override fun onInactive() {</span>
<span class="lineno"> 230 </span><span class="error">        super.onInactive()</span>
<span class="lineno"> 231 </span><span class="error">        this.data.removeChangeListener(this.listener)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/widget/circleview/ColorCircleView.kt:14:1</span><span class="message">The class `ColorCircleView` is using inheritance, consider using composition instead.

Does `ColorCircleView` want to expose the complete interface (`Exposing interface of a Java superclass is not supported`) of `CircleView` such that `ColorCircleView` can be used where `CircleView` is expected? Indicates __inheritance__.

Does `ColorCircleView` want only some/part of the behavior exposed by `CircleView`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.airthings.R
<span class="lineno">  12 </span>import com.airthings.utilities.Log
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">open class ColorCircleView(context: Context, attrs: AttributeSet) : CircleView(context, attrs) {</span>
<span class="lineno">  15 </span><span class="error"></span>
<span class="lineno">  16 </span><span class="error">    companion object {</span>
<span class="lineno">  17 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/widget/circleview/DetailedColorCircleView.kt:16:1</span><span class="message">The class `DetailedColorCircleView` is using inheritance, consider using composition instead.

Does `DetailedColorCircleView` want to expose the complete interface (`onDraw, onSizeChanged, updatePaint`) of `ColorCircleView` such that `DetailedColorCircleView` can be used where `ColorCircleView` is expected? Indicates __inheritance__.

Does `DetailedColorCircleView` want only some/part of the behavior exposed by `ColorCircleView`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import com.airthings.airthings.models.MeasurementUnit
<span class="lineno">  14 </span>import java.util.Locale
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">/**</span>
<span class="lineno">  17 </span><span class="error"> * Created by Vegard Stjerna Lindrup on 28.12.2016.</span>
<span class="lineno">  18 </span><span class="error"> *</span>
<span class="lineno">  19 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/AddDeviceWizardActivity.kt:9:1</span><span class="message">The class `AddDeviceWizardActivity` is using inheritance, consider using composition instead.

Does `AddDeviceWizardActivity` want to expose the complete interface (`possiblyCancelWizard, possiblyGotoPreviousPageOrExit, onRestoreInstanceState, onSaveInstanceState, onBackPressed, onDestroy, createNavigator, onCreate`) of `WizardActivity` such that `AddDeviceWizardActivity` can be used where `WizardActivity` is expected? Indicates __inheritance__.

Does `AddDeviceWizardActivity` want only some/part of the behavior exposed by `WizardActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>import com.airthings.uicomponents.wizard.WizardPage
<span class="lineno">   7 </span>import com.airthings.uicomponents.wizard.WizardPagerAdapter
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">class AddDeviceWizardActivity : WizardActivity() {</span>
<span class="lineno">  10 </span><span class="error"></span>
<span class="lineno">  11 </span><span class="error">    override val pagerAdapter: WizardPagerAdapter by lazy { DevicePagerAdapter(this, navigator) }</span>
<span class="lineno">  12 </span><span class="error">    override val wizard by lazy {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/BaseCustomNameAdapter.kt:21:1</span><span class="message">The class `BaseCustomNameAdapter` is using inheritance, consider using composition instead.

Does `BaseCustomNameAdapter` want to expose the complete interface (`inflate, add, clear, update, add, append, indexOf, itemAt, onViewRecycled, onBindViewHolder, onCreateViewHolder, getItemViewType, getItemCount`) of `BaseRecyclerViewAdapter` such that `BaseCustomNameAdapter` can be used where `BaseRecyclerViewAdapter` is expected? Indicates __inheritance__.

Does `BaseCustomNameAdapter` want only some/part of the behavior exposed by `BaseRecyclerViewAdapter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  18 </span>import com.airthings.uicomponents.UI_DELAY_SHORT
<span class="lineno">  19 </span>import java.util.UUID
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">/*</span>
<span class="lineno">  22 </span><span class="error">    This should be refactored to use separate views for each type of view in the list.</span>
<span class="lineno">  23 </span><span class="error">    One view for Default list items, and one view for custom list items.</span>
<span class="lineno">  24 </span><span class="error">*/</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/BaseCustomNameAdapter.kt:124:1</span><span class="message">The class `FieldCustomNameAdapter` is using inheritance, consider using composition instead.

Does `FieldCustomNameAdapter` want to expose the complete interface (`setCustomName, possiblySetCustomName, add, getCustomName, onClick, setCustomNameFlag, onBindViewHolder, nameSubmitButton, nameEditText`) of `BaseCustomNameAdapter` such that `FieldCustomNameAdapter` can be used where `BaseCustomNameAdapter` is expected? Indicates __inheritance__.

Does `FieldCustomNameAdapter` want only some/part of the behavior exposed by `BaseCustomNameAdapter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 121 </span>    abstract fun setCustomName(it: String)
<span class="lineno"> 122 </span>}
<span class="lineno"> 123 </span>
<span class="lineno"> 124 </span><span class="error">internal abstract class FieldCustomNameAdapter constructor(</span>
<span class="lineno"> 125 </span><span class="error">    private val activity: WizardActivity,</span>
<span class="lineno"> 126 </span><span class="error">    viewModel: DeviceViewModel,</span>
<span class="lineno"> 127 </span><span class="error">    itemClickHandler: OnClickHandler&lt;BaseFieldItem, TileWizardDeviceFieldBinding&gt;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/BaseCustomNameAdapter.kt:165:1</span><span class="message">The class `DeviceNameCustomNameAdapter` is using inheritance, consider using composition instead.

Does `DeviceNameCustomNameAdapter` want to expose the complete interface (`onClick, inflate, userEnteredCustomName, onBindViewHolder, nameSubmitButton, nameEditText`) of `FieldCustomNameAdapter` such that `DeviceNameCustomNameAdapter` can be used where `FieldCustomNameAdapter` is expected? Indicates __inheritance__.

Does `DeviceNameCustomNameAdapter` want only some/part of the behavior exposed by `FieldCustomNameAdapter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 162 </span>    }
<span class="lineno"> 163 </span>}
<span class="lineno"> 164 </span>
<span class="lineno"> 165 </span><span class="error">internal class DeviceNameCustomNameAdapter(</span>
<span class="lineno"> 166 </span><span class="error">    activity: WizardActivity,</span>
<span class="lineno"> 167 </span><span class="error">    viewModel: DeviceViewModel,</span>
<span class="lineno"> 168 </span><span class="error">    itemClickHandler: OnClickHandler&lt;BaseFieldItem, TileWizardDeviceFieldBinding&gt;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/BaseCustomNameAdapter.kt:185:1</span><span class="message">The class `LocationNameCustomNameAdapter` is using inheritance, consider using composition instead.

Does `LocationNameCustomNameAdapter` want to expose the complete interface (`onClick, inflate, userEnteredCustomName, onBindViewHolder, nameSubmitButton, nameEditText`) of `FieldCustomNameAdapter` such that `LocationNameCustomNameAdapter` can be used where `FieldCustomNameAdapter` is expected? Indicates __inheritance__.

Does `LocationNameCustomNameAdapter` want only some/part of the behavior exposed by `FieldCustomNameAdapter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 182 </span>    }
<span class="lineno"> 183 </span>}
<span class="lineno"> 184 </span>
<span class="lineno"> 185 </span><span class="error">internal class LocationNameCustomNameAdapter(</span>
<span class="lineno"> 186 </span><span class="error">    activity: WizardActivity,</span>
<span class="lineno"> 187 </span><span class="error">    viewModel: DeviceViewModel,</span>
<span class="lineno"> 188 </span><span class="error">    itemClickHandler: OnClickHandler&lt;BaseFieldItem, TileWizardDeviceFieldBinding&gt;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/BaseFieldItem.kt:15:1</span><span class="message">The class `DefinedItem` is using inheritance, consider using composition instead.

Does `DefinedItem` want to expose the complete interface (`empty public interface`) of `BaseFieldItem` such that `DefinedItem` can be used where `BaseFieldItem` is expected? Indicates __inheritance__.

Does `DefinedItem` want only some/part of the behavior exposed by `BaseFieldItem`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>    val isCustom = FieldItemType.CUSTOM == type
<span class="lineno">  13 </span>}
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">open class DefinedItem constructor(</span>
<span class="lineno">  16 </span><span class="error">    code: String? = null,</span>
<span class="lineno">  17 </span><span class="error">    label: String,</span>
<span class="lineno">  18 </span><span class="error">    isExisting: Boolean</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/BaseFieldItem.kt:21:1</span><span class="message">The class `CustomItem` is using inheritance, consider using composition instead.

Does `CustomItem` want to expose the complete interface (`empty public interface`) of `BaseFieldItem` such that `CustomItem` can be used where `BaseFieldItem` is expected? Indicates __inheritance__.

Does `CustomItem` want only some/part of the behavior exposed by `BaseFieldItem`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  18 </span>    isExisting: Boolean
<span class="lineno">  19 </span>) : BaseFieldItem(code, label, FieldItemType.DEFINED, isExisting)
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">open class CustomItem constructor(</span>
<span class="lineno">  22 </span><span class="error">    code: String? = null,</span>
<span class="lineno">  23 </span><span class="error">    label: String</span>
<span class="lineno">  24 </span><span class="error">) : BaseFieldItem(code, label, FieldItemType.CUSTOM, false)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/ConnectionFailedFragment.kt:13:1</span><span class="message">The class `ConnectionFailedFragment` is using inheritance, consider using composition instead.

Does `ConnectionFailedFragment` want to expose the complete interface (`onTextChanged, beforeTextChanged, afterTextChanged, firstButtonOnClick, dismiss, onDismiss, onDestroyView, onCreateView, onEditableChanged, firstButtonOnClick`) of `DialogSheetFragment` such that `ConnectionFailedFragment` can be used where `DialogSheetFragment` is expected? Indicates __inheritance__.

Does `ConnectionFailedFragment` want only some/part of the behavior exposed by `DialogSheetFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import com.airthings.utilities.NonNullMutableLiveData
<span class="lineno">  11 </span>import com.google.android.material.bottomsheet.BottomSheetDialog
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class ConnectionFailedFragment : DialogSheetFragment() {</span>
<span class="lineno">  14 </span><span class="error">    override val themeResourceId =</span>
<span class="lineno">  15 </span><span class="error">        R.style.DeviceWizardBottomSheetDialogTheme_Accent</span>
<span class="lineno">  16 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/DeviceNavigatorConfig.kt:27:1</span><span class="message">The class `UpdateDeviceNavigatorConfig` is using inheritance, consider using composition instead.

Does `UpdateDeviceNavigatorConfig` want to expose the complete interface (`nextPageTitle, previousPageTitle`) of `DeviceNavigatorConfig` such that `UpdateDeviceNavigatorConfig` can be used where `DeviceNavigatorConfig` is expected? Indicates __inheritance__.

Does `UpdateDeviceNavigatorConfig` want only some/part of the behavior exposed by `DeviceNavigatorConfig`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  24 </span>    }
<span class="lineno">  25 </span>}
<span class="lineno">  26 </span>
<span class="lineno">  27 </span><span class="error">internal abstract class UpdateDeviceNavigatorConfig(initialPages: List&lt;WizardPage&gt;,</span>
<span class="lineno">  28 </span><span class="error">                                                    resources: Resources) :</span>
<span class="lineno">  29 </span><span class="error">    DeviceNavigatorConfig(initialPages, resources) {</span>
<span class="lineno">  30 </span><span class="error">    override val isCancelable: Boolean</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/DevicePagerAdapter.kt:21:1</span><span class="message">The class `DevicePagerAdapter` is using inheritance, consider using composition instead.

Does `DevicePagerAdapter` want to expose the complete interface (`onPageScrollStateChanged, onPageSelected, onPageScrolled, containsItem, getItemId, getItemCount, createFragment, createFragment`) of `WizardPagerAdapter` such that `DevicePagerAdapter` can be used where `WizardPagerAdapter` is expected? Indicates __inheritance__.

Does `DevicePagerAdapter` want only some/part of the behavior exposed by `WizardPagerAdapter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  18 </span>import com.airthings.uicomponents.wizard.WizardPageFragment
<span class="lineno">  19 </span>import com.airthings.uicomponents.wizard.WizardPagerAdapter
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">internal class DevicePagerAdapter(</span>
<span class="lineno">  22 </span><span class="error">    activity: AddDeviceWizardActivity,</span>
<span class="lineno">  23 </span><span class="error">    navigator: WizardNavigatorConfig</span>
<span class="lineno">  24 </span><span class="error">) : WizardPagerAdapter(activity, navigator) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/DeviceViewModel.kt:36:1</span><span class="message">The class `DeviceViewModel` is using inheritance, consider using composition instead.

Does `DeviceViewModel` want to expose the complete interface (`onDestroy, onCreate, getMeasurementUnit`) of `AirthingsViewModel` such that `DeviceViewModel` can be used where `AirthingsViewModel` is expected? Indicates __inheritance__.

Does `DeviceViewModel` want only some/part of the behavior exposed by `AirthingsViewModel`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  33 </span>import javax.inject.Inject
<span class="lineno">  34 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  35 </span>
<span class="lineno">  36 </span><span class="error">@Suppress(&quot;TooManyFunctions&quot;)</span>
<span class="lineno">  37 </span><span class="error">class DeviceViewModel @Inject constructor(</span>
<span class="lineno">  38 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  39 </span><span class="error">    userRepository: UserRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/DeviceWizard.kt:12:1</span><span class="message">The class `DeviceWizard` is using inheritance, consider using composition instead.

Does `DeviceWizard` want to expose the complete interface (`onRestoreInstanceState, onSaveInstanceState, onDestroy, onCreate, replace, remove, add, add, goBackwardIfAllowed, goBackward, goForward, goto`) of `Wizard` such that `DeviceWizard` can be used where `Wizard` is expected? Indicates __inheritance__.

Does `DeviceWizard` want only some/part of the behavior exposed by `Wizard`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.uicomponents.wizard.transformer.CupertinoPageNavigationTransformer
<span class="lineno">  10 </span>import com.airthings.uicomponents.wizard.transformer.WizardPageTransformer
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">internal class DeviceWizard(</span>
<span class="lineno">  13 </span><span class="error">    val activity: AddDeviceWizardActivity,</span>
<span class="lineno">  14 </span><span class="error">    navigator: DeviceNavigatorConfig,</span>
<span class="lineno">  15 </span><span class="error">    pagerAdapter: DevicePagerAdapter,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/TroubleshootingSheetFragment.kt:14:1</span><span class="message">The class `TroubleshootingSheetFragment` is using inheritance, consider using composition instead.

Does `TroubleshootingSheetFragment` want to expose the complete interface (`secondButtonOnClick`) of `FirstButtonPluggableDialogSheetFragment` such that `TroubleshootingSheetFragment` can be used where `FirstButtonPluggableDialogSheetFragment` is expected? Indicates __inheritance__.

Does `TroubleshootingSheetFragment` want only some/part of the behavior exposed by `FirstButtonPluggableDialogSheetFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.uicomponents.dialogsheet.FirstButtonPluggableDialogSheetUiConfig
<span class="lineno">  12 </span>import com.google.android.material.bottomsheet.BottomSheetDialog
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">/**</span>
<span class="lineno">  15 </span><span class="error"> * Shows a troubleshooting dialog that explains common problems when pairing a device.</span>
<span class="lineno">  16 </span><span class="error"> *</span>
<span class="lineno">  17 </span><span class="error"> * PS: Android requires this to be a public class, keep it as such -- or at least an internal one.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/ApplyHubPage.kt:11:1</span><span class="message">The class `ApplyHubPage` is using inheritance, consider using composition instead.

Does `ApplyHubPage` want to expose the complete interface (`onCreate, newInstance, onViewCreated`) of `BasePage` such that `ApplyHubPage` can be used where `BasePage` is expected? Indicates __inheritance__.

Does `ApplyHubPage` want only some/part of the behavior exposed by `BasePage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.airthings.wizard.device.AddDevicePage
<span class="lineno">   9 </span>import com.airthings.core.entities.Region
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class ApplyHubPage : BasePage&lt;WizardDeviceApplyBinding&gt;() {</span>
<span class="lineno">  12 </span><span class="error"></span>
<span class="lineno">  13 </span><span class="error">    override fun bind(view: View): WizardDeviceApplyBinding {</span>
<span class="lineno">  14 </span><span class="error">        val binding = WizardDeviceApplyBinding.bind(view)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/ApplyWaveMapPage.kt:13:1</span><span class="message">The class `ApplyWaveMapPage` is using inheritance, consider using composition instead.

Does `ApplyWaveMapPage` want to expose the complete interface (`onSaveInstanceState, onLowMemory, onDestroy, onStop, onStart, onResume, onViewCreated, onMapReady`) of `GoogleMapsPage` such that `ApplyWaveMapPage` can be used where `GoogleMapsPage` is expected? Indicates __inheritance__.

Does `ApplyWaveMapPage` want only some/part of the behavior exposed by `GoogleMapsPage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import com.google.android.gms.maps.GoogleMap
<span class="lineno">  11 </span>import java.util.UUID
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">internal class ApplyWaveMapPage :</span>
<span class="lineno">  14 </span><span class="error">    GoogleMapsPage&lt;WizardDeviceApplyMapBinding&gt;(),</span>
<span class="lineno">  15 </span><span class="error">    LocationServiceRepository.LocationUpdateListener {</span>
<span class="lineno">  16 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/ApplyWavePage.kt:10:1</span><span class="message">The class `ApplyWavePage` is using inheritance, consider using composition instead.

Does `ApplyWavePage` want to expose the complete interface (`onCreate, newInstance, onViewCreated`) of `BasePage` such that `ApplyWavePage` can be used where `BasePage` is expected? Indicates __inheritance__.

Does `ApplyWavePage` want only some/part of the behavior exposed by `BasePage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import com.airthings.airthings.databinding.WizardDeviceApplyBinding
<span class="lineno">   8 </span>import com.airthings.airthings.wizard.device.AddDevicePage
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">internal class ApplyWavePage : BasePage&lt;WizardDeviceApplyBinding&gt;() {</span>
<span class="lineno">  11 </span><span class="error"></span>
<span class="lineno">  12 </span><span class="error">    override fun bind(view: View): WizardDeviceApplyBinding {</span>
<span class="lineno">  13 </span><span class="error">        val binding = WizardDeviceApplyBinding.bind(view)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/BaseDeviceSelectionPage.kt:19:1</span><span class="message">The class `BaseDeviceSelectionPage` is using inheritance, consider using composition instead.

Does `BaseDeviceSelectionPage` want to expose the complete interface (`onCreate, newInstance, onViewCreated`) of `BasePage` such that `BaseDeviceSelectionPage` can be used where `BasePage` is expected? Indicates __inheritance__.

Does `BaseDeviceSelectionPage` want only some/part of the behavior exposed by `BasePage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>import com.airthings.uicomponents.UI_DELAY_DEFAULT
<span class="lineno">  17 </span>import com.airthings.utilities.ui
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">internal abstract class BaseDeviceSelectionPage : BasePage&lt;WizardDeviceSelectionBinding&gt;(),</span>
<span class="lineno">  20 </span><span class="error">    BaseRecyclerViewAdapter.OnClickHandler&lt;AirthingsDevice, TileWizardDeviceUnpairedBinding&gt; {</span>
<span class="lineno">  21 </span><span class="error"></span>
<span class="lineno">  22 </span><span class="error">    protected abstract val adapter: BaseResultAdapter</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/BasePage.kt:28:1</span><span class="message">The class `BasePage` is using inheritance, consider using composition instead.

Does `BasePage` want to expose the complete interface (`onHidden, onShown, onCreateView, bind`) of `WizardPageFragment` such that `BasePage` can be used where `WizardPageFragment` is expected? Indicates __inheritance__.

Does `BasePage` want only some/part of the behavior exposed by `WizardPageFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  25 </span>import com.airthings.uicomponents.wizard.WizardPageFragment
<span class="lineno">  26 </span>import com.airthings.utilities.NonNullMutableLiveData
<span class="lineno">  27 </span>
<span class="lineno">  28 </span><span class="error">/**</span>
<span class="lineno">  29 </span><span class="error"> * All pages in our wizard will extend this class.</span>
<span class="lineno">  30 </span><span class="error"> */</span>
<span class="lineno">  31 </span><span class="error">internal abstract class BasePage&lt;B : ViewDataBinding&gt; : WizardPageFragment&lt;WizardPage, B&gt;() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/BasePage.kt:123:1</span><span class="message">The class `DependencyDialogSheetFragment` is using inheritance, consider using composition instead.

Does `DependencyDialogSheetFragment` want to expose the complete interface (`secondButtonOnClick`) of `FirstButtonDialogSheetFragment` such that `DependencyDialogSheetFragment` can be used where `FirstButtonDialogSheetFragment` is expected? Indicates __inheritance__.

Does `DependencyDialogSheetFragment` want only some/part of the behavior exposed by `FirstButtonDialogSheetFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 120 </span>    }
<span class="lineno"> 121 </span>}
<span class="lineno"> 122 </span>
<span class="lineno"> 123 </span><span class="error">/**</span>
<span class="lineno"> 124 </span><span class="error"> * Base implementation for a dialog bottom sheet that requires a dependency to be met. Used by</span>
<span class="lineno"> 125 </span><span class="error"> * the [LocationServicesDialogSheetFragmentImpl], [ShareLocationDialogSheetFragmentImpl] and</span>
<span class="lineno"> 126 </span><span class="error"> * [BluetoothDisabledDialogSheetFragmentImpl] to ensure proper environment dependencies are met.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/BasePage.kt:159:1</span><span class="message">The class `LocationServicesDialogSheetFragmentImpl` is using inheritance, consider using composition instead.

Does `LocationServicesDialogSheetFragmentImpl` want to expose the complete interface (`isDependencyMet, onResume`) of `DependencyDialogSheetFragment` such that `LocationServicesDialogSheetFragmentImpl` can be used where `DependencyDialogSheetFragment` is expected? Indicates __inheritance__.

Does `LocationServicesDialogSheetFragmentImpl` want only some/part of the behavior exposed by `DependencyDialogSheetFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 156 </span>    abstract fun isDependencyMet(context: Context): Boolean
<span class="lineno"> 157 </span>}
<span class="lineno"> 158 </span>
<span class="lineno"> 159 </span><span class="error">/**</span>
<span class="lineno"> 160 </span><span class="error"> * Implementation for a dialog bottom sheet asking the user to enable Location Services.</span>
<span class="lineno"> 161 </span><span class="error"> *</span>
<span class="lineno"> 162 </span><span class="error"> * PS: Android requires this to be a public class, keep it as such -- or at least an internal one.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/BasePage.kt:189:1</span><span class="message">The class `ShareLocationDialogSheetFragmentImpl` is using inheritance, consider using composition instead.

Does `ShareLocationDialogSheetFragmentImpl` want to expose the complete interface (`isDependencyMet, onResume`) of `DependencyDialogSheetFragment` such that `ShareLocationDialogSheetFragmentImpl` can be used where `DependencyDialogSheetFragment` is expected? Indicates __inheritance__.

Does `ShareLocationDialogSheetFragmentImpl` want only some/part of the behavior exposed by `DependencyDialogSheetFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 186 </span>    }
<span class="lineno"> 187 </span>}
<span class="lineno"> 188 </span>
<span class="lineno"> 189 </span><span class="error">/**</span>
<span class="lineno"> 190 </span><span class="error"> * Implementation for a dialog bottom sheet asking the user to share her location.</span>
<span class="lineno"> 191 </span><span class="error"> *</span>
<span class="lineno"> 192 </span><span class="error"> * PS: Android requires this to be a public class, keep it as such -- or at least an internal one.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/BasePage.kt:253:1</span><span class="message">The class `BluetoothDisabledDialogSheetFragmentImpl` is using inheritance, consider using composition instead.

Does `BluetoothDisabledDialogSheetFragmentImpl` want to expose the complete interface (`isDependencyMet, onResume`) of `DependencyDialogSheetFragment` such that `BluetoothDisabledDialogSheetFragmentImpl` can be used where `DependencyDialogSheetFragment` is expected? Indicates __inheritance__.

Does `BluetoothDisabledDialogSheetFragmentImpl` want only some/part of the behavior exposed by `DependencyDialogSheetFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 250 </span>    }
<span class="lineno"> 251 </span>}
<span class="lineno"> 252 </span>
<span class="lineno"> 253 </span><span class="error">/**</span>
<span class="lineno"> 254 </span><span class="error"> * Implementation for a dialog bottom sheet asking the user to enable Bluetooth.</span>
<span class="lineno"> 255 </span><span class="error"> *</span>
<span class="lineno"> 256 </span><span class="error"> * PS: Android requires this to be a public class, keep it as such -- or at least an internal one.</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/BaseResultAdapter.kt:10:1</span><span class="message">The class `BaseResultAdapter` is using inheritance, consider using composition instead.

Does `BaseResultAdapter` want to expose the complete interface (`inflate, add, clear, update, add, append, indexOf, itemAt, onViewRecycled, onBindViewHolder, onCreateViewHolder, getItemViewType, getItemCount`) of `BaseRecyclerViewAdapter` such that `BaseResultAdapter` can be used where `BaseRecyclerViewAdapter` is expected? Indicates __inheritance__.

Does `BaseResultAdapter` want only some/part of the behavior exposed by `BaseRecyclerViewAdapter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import com.airthings.airthings.databinding.TileWizardDeviceUnpairedBinding
<span class="lineno">   8 </span>import com.airthings.airthings.utils.BaseRecyclerViewAdapter
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">internal abstract class BaseResultAdapter constructor(</span>
<span class="lineno">  11 </span><span class="error">    override val clickHandler: OnClickHandler&lt;AirthingsDevice, TileWizardDeviceUnpairedBinding&gt;</span>
<span class="lineno">  12 </span><span class="error">) : BaseRecyclerViewAdapter&lt;AirthingsDevice, TileWizardDeviceUnpairedBinding&gt;() {</span>
<span class="lineno">  13 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/DeviceNameHubPage.kt:18:1</span><span class="message">The class `DeviceNameHubPage` is using inheritance, consider using composition instead.

Does `DeviceNameHubPage` want to expose the complete interface (`onCreate, newInstance, onViewCreated`) of `BasePage` such that `DeviceNameHubPage` can be used where `BasePage` is expected? Indicates __inheritance__.

Does `DeviceNameHubPage` want only some/part of the behavior exposed by `BasePage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>import com.airthings.airthings.utils.requestSoftKeyboard
<span class="lineno">  16 </span>import com.airthings.airthings.wizard.device.AddDevicePage
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">internal class DeviceNameHubPage : BasePage&lt;WizardDeviceNameHubBinding&gt;(), TextWatcher {</span>
<span class="lineno">  19 </span><span class="error"></span>
<span class="lineno">  20 </span><span class="error">    private lateinit var binding: WizardDeviceNameHubBinding</span>
<span class="lineno">  21 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/DeviceNameWavePage.kt:19:1</span><span class="message">The class `DeviceNameWavePage` is using inheritance, consider using composition instead.

Does `DeviceNameWavePage` want to expose the complete interface (`onCreate, newInstance, onViewCreated`) of `BasePage` such that `DeviceNameWavePage` can be used where `BasePage` is expected? Indicates __inheritance__.

Does `DeviceNameWavePage` want only some/part of the behavior exposed by `BasePage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>import com.airthings.airthings.wizard.device.AddDeviceWizardActivity
<span class="lineno">  17 </span>import java.util.UUID
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">internal class DeviceNameWavePage : BasePage&lt;WizardDeviceFieldBinding&gt;(),</span>
<span class="lineno">  20 </span><span class="error">    BaseRecyclerViewAdapter.OnClickHandler&lt;BaseFieldItem, TileWizardDeviceFieldBinding&gt; {</span>
<span class="lineno">  21 </span><span class="error"></span>
<span class="lineno">  22 </span><span class="error">    private val adapter by lazy {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/DeviceSelectionPage.kt:19:1</span><span class="message">The class `DeviceSelectionPage` is using inheritance, consider using composition instead.

Does `DeviceSelectionPage` want to expose the complete interface (`onShown, onStop, onResume, onDestroyView, onViewCreated, bind`) of `BaseDeviceSelectionPage` such that `DeviceSelectionPage` can be used where `BaseDeviceSelectionPage` is expected? Indicates __inheritance__.

Does `DeviceSelectionPage` want only some/part of the behavior exposed by `BaseDeviceSelectionPage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>import com.airthings.uicomponents.dialogsheet.PluggableDialogSheetFragment
<span class="lineno">  17 </span>import com.airthings.utilities.NonNullMutableLiveData
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">internal class DeviceSelectionPage : BaseDeviceSelectionPage() {</span>
<span class="lineno">  20 </span><span class="error"></span>
<span class="lineno">  21 </span><span class="error">    override val adapter: BaseResultAdapter = DeviceResultAdapter(this)</span>
<span class="lineno">  22 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/DeviceSelectionPage.kt:83:1</span><span class="message">The class `UnpairableErrorSheetFragment` is using inheritance, consider using composition instead.

Does `UnpairableErrorSheetFragment` want to expose the complete interface (`onTextChanged, beforeTextChanged, afterTextChanged, firstButtonOnClick, dismiss, onDismiss, onDestroyView, onCreateView, onEditableChanged, firstButtonOnClick`) of `DialogSheetFragment` such that `UnpairableErrorSheetFragment` can be used where `DialogSheetFragment` is expected? Indicates __inheritance__.

Does `UnpairableErrorSheetFragment` want only some/part of the behavior exposed by `DialogSheetFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  80 </span>    }
<span class="lineno">  81 </span>}
<span class="lineno">  82 </span>
<span class="lineno">  83 </span><span class="error">// Android requires this to be a public class, keep it as such -- or at least an internal one.</span>
<span class="lineno">  84 </span><span class="error">internal class UnpairableErrorSheetFragment(</span>
<span class="lineno">  85 </span><span class="error">    private val serialNumber: String,</span>
<span class="lineno">  86 </span><span class="error">    private val launchSupport: (() -&gt; Unit)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/DeviceSelectionPage.kt:117:1</span><span class="message">The class `DeviceResultAdapter` is using inheritance, consider using composition instead.

Does `DeviceResultAdapter` want to expose the complete interface (`add, inflate, onBindViewHolder`) of `BaseResultAdapter` such that `DeviceResultAdapter` can be used where `BaseResultAdapter` is expected? Indicates __inheritance__.

Does `DeviceResultAdapter` want only some/part of the behavior exposed by `BaseResultAdapter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 114 </span>    }
<span class="lineno"> 115 </span>}
<span class="lineno"> 116 </span>
<span class="lineno"> 117 </span><span class="error">private class DeviceResultAdapter(</span>
<span class="lineno"> 118 </span><span class="error">    clickHandler: OnClickHandler&lt;AirthingsDevice, TileWizardDeviceUnpairedBinding&gt;</span>
<span class="lineno"> 119 </span><span class="error">) : BaseResultAdapter(clickHandler) {</span>
<span class="lineno"> 120 </span><span class="error">    override fun getTitle(device: AirthingsDevice): String = device.modelName</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/GoogleMapsPage.kt:18:1</span><span class="message">The class `GoogleMapsPage` is using inheritance, consider using composition instead.

Does `GoogleMapsPage` want to expose the complete interface (`onCreate, newInstance, onViewCreated`) of `BasePage` such that `GoogleMapsPage` can be used where `BasePage` is expected? Indicates __inheritance__.

Does `GoogleMapsPage` want only some/part of the behavior exposed by `BasePage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>import com.google.android.gms.maps.model.LatLng
<span class="lineno">  16 </span>import com.google.android.gms.maps.model.MarkerOptions
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">internal abstract class GoogleMapsPage&lt;B : ViewDataBinding&gt; : BasePage&lt;B&gt;(), OnMapReadyCallback {</span>
<span class="lineno">  19 </span><span class="error"></span>
<span class="lineno">  20 </span><span class="error">    protected lateinit var mapView: MapView</span>
<span class="lineno">  21 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/LinkDeviceSelectionPage.kt:20:1</span><span class="message">The class `LinkDeviceSelectionPage` is using inheritance, consider using composition instead.

Does `LinkDeviceSelectionPage` want to expose the complete interface (`onShown, onStop, onResume, onDestroyView, onViewCreated, bind`) of `BaseDeviceSelectionPage` such that `LinkDeviceSelectionPage` can be used where `BaseDeviceSelectionPage` is expected? Indicates __inheritance__.

Does `LinkDeviceSelectionPage` want only some/part of the behavior exposed by `BaseDeviceSelectionPage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  17 </span>import com.airthings.airthings.wizard.device.locationNameOf
<span class="lineno">  18 </span>import com.airthings.uicomponents.dialogsheet.PluggableDialogSheetFragment
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">internal class LinkDeviceSelectionPage : BaseDeviceSelectionPage() {</span>
<span class="lineno">  21 </span><span class="error"></span>
<span class="lineno">  22 </span><span class="error">    private val localDevices = mutableListOf&lt;UserDevice&gt;()</span>
<span class="lineno">  23 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/LinkDeviceSelectionPage.kt:84:5</span><span class="message">The class `LinkDeviceResultAdapter` is using inheritance, consider using composition instead.

Does `LinkDeviceResultAdapter` want to expose the complete interface (`add, inflate, onBindViewHolder`) of `BaseResultAdapter` such that `LinkDeviceResultAdapter` can be used where `BaseResultAdapter` is expected? Indicates __inheritance__.

Does `LinkDeviceResultAdapter` want only some/part of the behavior exposed by `BaseResultAdapter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  81 </span>        viewModel.isPairedDevice(device.serial) &amp;&amp;
<span class="lineno">  82 </span>        !viewModel.isLinkedDevice(device.serial)
<span class="lineno">  83 </span>
<span class="lineno">  84 </span>    <span class="error">private inner class LinkDeviceResultAdapter : BaseResultAdapter(this) {</span>
<span class="lineno">  85 </span><span class="error">        override fun getTitle(device: AirthingsDevice): String {</span>
<span class="lineno">  86 </span><span class="error">            synchronized(localDevices) {</span>
<span class="lineno">  87 </span><span class="error">                return localDevices.deviceNameOf(device.serial, device.modelName)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/LocationPage.kt:19:1</span><span class="message">The class `LocationPage` is using inheritance, consider using composition instead.

Does `LocationPage` want to expose the complete interface (`onCreate, newInstance, onViewCreated`) of `BasePage` such that `LocationPage` can be used where `BasePage` is expected? Indicates __inheritance__.

Does `LocationPage` want only some/part of the behavior exposed by `BasePage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>import com.airthings.airthings.wizard.device.LocationNameCustomNameAdapter
<span class="lineno">  17 </span>import java.util.UUID
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">internal class LocationPage : BasePage&lt;WizardDeviceFieldBinding&gt;(),</span>
<span class="lineno">  20 </span><span class="error">    BaseRecyclerViewAdapter.OnClickHandler&lt;BaseFieldItem, TileWizardDeviceFieldBinding&gt; {</span>
<span class="lineno">  21 </span><span class="error"></span>
<span class="lineno">  22 </span><span class="error">    private val adapter by lazy { LocationNameCustomNameAdapter(wizardActivity, viewModel, this) }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/LocationPage.kt:102:1</span><span class="message">The class `LocationItem` is using inheritance, consider using composition instead.

Does `LocationItem` want to expose the complete interface (`empty public interface`) of `DefinedItem` such that `LocationItem` can be used where `DefinedItem` is expected? Indicates __inheritance__.

Does `LocationItem` want only some/part of the behavior exposed by `DefinedItem`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  99 </span>    }
<span class="lineno"> 100 </span>}
<span class="lineno"> 101 </span>
<span class="lineno"> 102 </span><span class="error">private class LocationItem(location: LocationName) : DefinedItem(</span>
<span class="lineno"> 103 </span><span class="error">    location.identifier,</span>
<span class="lineno"> 104 </span><span class="error">    location.name,</span>
<span class="lineno"> 105 </span><span class="error">    location.isExisting</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/LocationSharePage.kt:8:1</span><span class="message">The class `LocationSharePage` is using inheritance, consider using composition instead.

Does `LocationSharePage` want to expose the complete interface (`onCreate, newInstance, onViewCreated`) of `BasePage` such that `LocationSharePage` can be used where `BasePage` is expected? Indicates __inheritance__.

Does `LocationSharePage` want only some/part of the behavior exposed by `BasePage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   5 </span>import com.airthings.airthings.models.GeoLocation
<span class="lineno">   6 </span>import com.airthings.airthings.wizard.device.AddDevicePage
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">internal class LocationSharePage : BasePage&lt;WizardDeviceLocationShareBinding&gt;() {</span>
<span class="lineno">   9 </span><span class="error"></span>
<span class="lineno">  10 </span><span class="error">    override fun bind(view: View): WizardDeviceLocationShareBinding {</span>
<span class="lineno">  11 </span><span class="error">        val binding = WizardDeviceLocationShareBinding.bind(view)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/SetRegionPage.kt:23:1</span><span class="message">The class `SetRegionPage` is using inheritance, consider using composition instead.

Does `SetRegionPage` want to expose the complete interface (`onCreate, newInstance, onViewCreated`) of `BasePage` such that `SetRegionPage` can be used where `BasePage` is expected? Indicates __inheritance__.

Does `SetRegionPage` want only some/part of the behavior exposed by `BasePage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  20 </span>import com.airthings.utilities.StringIdentifiable
<span class="lineno">  21 </span>import io.intercom.android.sdk.Intercom
<span class="lineno">  22 </span>
<span class="lineno">  23 </span><span class="error">internal class SetRegionPage(</span>
<span class="lineno">  24 </span><span class="error">    private val nextPage: AddDevicePage? = null</span>
<span class="lineno">  25 </span><span class="error">) :</span>
<span class="lineno">  26 </span><span class="error">    BasePage&lt;WizardDeviceRegionBinding&gt;(),</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/SetRegionPage.kt:114:1</span><span class="message">The class `RegionAdapter` is using inheritance, consider using composition instead.

Does `RegionAdapter` want to expose the complete interface (`inflate, add, clear, update, add, append, indexOf, itemAt, onViewRecycled, onBindViewHolder, onCreateViewHolder, getItemViewType, getItemCount`) of `BaseRecyclerViewAdapter` such that `RegionAdapter` can be used where `BaseRecyclerViewAdapter` is expected? Indicates __inheritance__.

Does `RegionAdapter` want only some/part of the behavior exposed by `BaseRecyclerViewAdapter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 111 </span>    }
<span class="lineno"> 112 </span>}
<span class="lineno"> 113 </span>
<span class="lineno"> 114 </span><span class="error">private class RegionAdapter constructor(</span>
<span class="lineno"> 115 </span><span class="error">    override val clickHandler: OnClickHandler&lt;RegionItem, TileWizardDeviceRegionBinding&gt;</span>
<span class="lineno"> 116 </span><span class="error">) : BaseRecyclerViewAdapter&lt;RegionItem, TileWizardDeviceRegionBinding&gt;() {</span>
<span class="lineno"> 117 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/SetRegionPage.kt:140:1</span><span class="message">The class `UnsupportedRegionFragment` is using inheritance, consider using composition instead.

Does `UnsupportedRegionFragment` want to expose the complete interface (`onTextChanged, beforeTextChanged, afterTextChanged, firstButtonOnClick, dismiss, onDismiss, onDestroyView, onCreateView, onEditableChanged, firstButtonOnClick`) of `DialogSheetFragment` such that `UnsupportedRegionFragment` can be used where `DialogSheetFragment` is expected? Indicates __inheritance__.

Does `UnsupportedRegionFragment` want only some/part of the behavior exposed by `DialogSheetFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 137 </span>    }
<span class="lineno"> 138 </span>}
<span class="lineno"> 139 </span>
<span class="lineno"> 140 </span><span class="error">// Android requires this to be a public class, keep it as such -- or at least an internal one.</span>
<span class="lineno"> 141 </span><span class="error">internal class UnsupportedRegionFragment : DialogSheetFragment() {</span>
<span class="lineno"> 142 </span><span class="error">    override val identifier = &quot;UnsupportedRegion&quot;</span>
<span class="lineno"> 143 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/AwaitRebootProgressStep.kt:13:1</span><span class="message">The class `AwaitRebootProgressStep` is using inheritance, consider using composition instead.

Does `AwaitRebootProgressStep` want to expose the complete interface (`onResume, onPause, toString`) of `ProgressStep` such that `AwaitRebootProgressStep` can be used where `ProgressStep` is expected? Indicates __inheritance__.

Does `AwaitRebootProgressStep` want only some/part of the behavior exposed by `ProgressStep`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import com.airthings.utilities.Log
<span class="lineno">  11 </span>import kotlinx.coroutines.delay
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">internal class AwaitRebootProgressStep(</span>
<span class="lineno">  14 </span><span class="error">    logTag: String,</span>
<span class="lineno">  15 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  16 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/BaseProgressPage.kt:29:1</span><span class="message">The class `BaseProgressPage` is using inheritance, consider using composition instead.

Does `BaseProgressPage` want to expose the complete interface (`onCreate, newInstance, onViewCreated`) of `BasePage` such that `BaseProgressPage` can be used where `BasePage` is expected? Indicates __inheritance__.

Does `BaseProgressPage` want only some/part of the behavior exposed by `BasePage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  26 </span>import com.airthings.utilities.ui
<span class="lineno">  27 </span>import com.google.android.material.bottomsheet.BottomSheetDialog
<span class="lineno">  28 </span>
<span class="lineno">  29 </span><span class="error">/**</span>
<span class="lineno">  30 </span><span class="error"> * All progress pages will use this class to streamline the linking, pairing, upgrading, and connecting to devices.</span>
<span class="lineno">  31 </span><span class="error"> * In addition, this class manages the lifecycle of each page and handles resume/pause of the app properly.</span>
<span class="lineno">  32 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/BaseProgressPage.kt:301:1</span><span class="message">The class `ProgressErrorSheetFragment` is using inheritance, consider using composition instead.

Does `ProgressErrorSheetFragment` want to expose the complete interface (`onTextChanged, beforeTextChanged, afterTextChanged, firstButtonOnClick, dismiss, onDismiss, onDestroyView, onCreateView, onEditableChanged, firstButtonOnClick`) of `DialogSheetFragment` such that `ProgressErrorSheetFragment` can be used where `DialogSheetFragment` is expected? Indicates __inheritance__.

Does `ProgressErrorSheetFragment` want only some/part of the behavior exposed by `DialogSheetFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 298 </span>    }
<span class="lineno"> 299 </span>}
<span class="lineno"> 300 </span>
<span class="lineno"> 301 </span><span class="error">// Android requires this to be a public class, keep it as such -- or at least an internal one.</span>
<span class="lineno"> 302 </span><span class="error">internal class ProgressErrorSheetFragment(</span>
<span class="lineno"> 303 </span><span class="error">    val title: String,</span>
<span class="lineno"> 304 </span><span class="error">    val message: String,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/CheckFirmwareProgressStep.kt:7:1</span><span class="message">The class `CheckFirmwareProgressStep` is using inheritance, consider using composition instead.

Does `CheckFirmwareProgressStep` want to expose the complete interface (`onResume, onPause, toString`) of `ProgressStep` such that `CheckFirmwareProgressStep` can be used where `ProgressStep` is expected? Indicates __inheritance__.

Does `CheckFirmwareProgressStep` want only some/part of the behavior exposed by `ProgressStep`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.airthings.R
<span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class CheckFirmwareProgressStep(</span>
<span class="lineno">   8 </span><span class="error">    logTag: String,</span>
<span class="lineno">   9 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  10 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/ConnectProgressStep.kt:7:1</span><span class="message">The class `ConnectProgressStep` is using inheritance, consider using composition instead.

Does `ConnectProgressStep` want to expose the complete interface (`onResume, onPause, toString`) of `ProgressStep` such that `ConnectProgressStep` can be used where `ProgressStep` is expected? Indicates __inheritance__.

Does `ConnectProgressStep` want only some/part of the behavior exposed by `ProgressStep`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.airthings.R
<span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class ConnectProgressStep(</span>
<span class="lineno">   8 </span><span class="error">    logTag: String,</span>
<span class="lineno">   9 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  10 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/DelayProgressStep.kt:9:1</span><span class="message">The class `DelayProgressStep` is using inheritance, consider using composition instead.

Does `DelayProgressStep` want to expose the complete interface (`onResume, onPause, toString`) of `ProgressStep` such that `DelayProgressStep` can be used where `ProgressStep` is expected? Indicates __inheritance__.

Does `DelayProgressStep` want only some/part of the behavior exposed by `ProgressStep`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   7 </span>import kotlinx.coroutines.delay
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">internal class DelayProgressStep(</span>
<span class="lineno">  10 </span><span class="error">    logTag: String,</span>
<span class="lineno">  11 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  12 </span><span class="error">    handler: ResultHandler,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/DoneProgressStep.kt:11:1</span><span class="message">The class `DoneProgressStep` is using inheritance, consider using composition instead.

Does `DoneProgressStep` want to expose the complete interface (`onResume, onPause, toString`) of `ProgressStep` such that `DoneProgressStep` can be used where `ProgressStep` is expected? Indicates __inheritance__.

Does `DoneProgressStep` want only some/part of the behavior exposed by `ProgressStep`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   9 </span>import com.airthings.uicomponents.getStringOrEmpty
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class DoneProgressStep(</span>
<span class="lineno">  12 </span><span class="error">    logTag: String,</span>
<span class="lineno">  13 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  14 </span><span class="error">    private val binding: WizardDeviceProgressBinding,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/DownloadProgressStep.kt:7:1</span><span class="message">The class `DownloadProgressStep` is using inheritance, consider using composition instead.

Does `DownloadProgressStep` want to expose the complete interface (`onResume, onPause, toString`) of `ProgressStep` such that `DownloadProgressStep` can be used where `ProgressStep` is expected? Indicates __inheritance__.

Does `DownloadProgressStep` want only some/part of the behavior exposed by `ProgressStep`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.airthings.R
<span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class DownloadProgressStep(</span>
<span class="lineno">   8 </span><span class="error">    logTag: String,</span>
<span class="lineno">   9 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  10 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/LinkProgressPage.kt:11:1</span><span class="message">The class `LinkProgressPage` is using inheritance, consider using composition instead.

Does `LinkProgressPage` want to expose the complete interface (`onError, onProgress, onDone, onResume, onPause, onStart, onViewCreated, bind`) of `BaseProgressPage` such that `LinkProgressPage` can be used where `BaseProgressPage` is expected? Indicates __inheritance__.

Does `LinkProgressPage` want only some/part of the behavior exposed by `BaseProgressPage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.airthings.wizard.device.AddDeviceWizardActivity
<span class="lineno">   9 </span>import com.airthings.airthings.wizard.device.page.progress.WizardActivity.Companion.STATE_NAVIGATOR_INITIAL_PAGE
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class LinkProgressPage : BaseProgressPage(), DoneProgressStep.ResultHandler {</span>
<span class="lineno">  12 </span><span class="error"></span>
<span class="lineno">  13 </span><span class="error">    override fun enumerateStepsForHub() = error(&quot;Linking a Hub to a Hub is not supported.&quot;)</span>
<span class="lineno">  14 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/PairProgressStep.kt:7:1</span><span class="message">The class `PairProgressStep` is using inheritance, consider using composition instead.

Does `PairProgressStep` want to expose the complete interface (`onResume, onPause, toString`) of `ProgressStep` such that `PairProgressStep` can be used where `ProgressStep` is expected? Indicates __inheritance__.

Does `PairProgressStep` want only some/part of the behavior exposed by `ProgressStep`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.airthings.R
<span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class PairProgressStep(</span>
<span class="lineno">   8 </span><span class="error">    logTag: String,</span>
<span class="lineno">   9 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  10 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/ProgressPage.kt:14:1</span><span class="message">The class `ProgressPage` is using inheritance, consider using composition instead.

Does `ProgressPage` want to expose the complete interface (`onError, onProgress, onDone, onResume, onPause, onStart, onViewCreated, bind`) of `BaseProgressPage` such that `ProgressPage` can be used where `BaseProgressPage` is expected? Indicates __inheritance__.

Does `ProgressPage` want only some/part of the behavior exposed by `BaseProgressPage`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.airthings.wizard.device.page.RegionItem
<span class="lineno">  12 </span>import com.airthings.airthings.wizard.device.page.progress.WizardActivity.Companion.STATE_NAVIGATOR_INITIAL_PAGE
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">internal class ProgressPage : BaseProgressPage(), DoneProgressStep.ResultHandler {</span>
<span class="lineno">  15 </span><span class="error"></span>
<span class="lineno">  16 </span><span class="error">    private val region: RegionItem by lazy {</span>
<span class="lineno">  17 </span><span class="error">        val region = viewModel.region.value</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/ReadFirmwareProgressStep.kt:8:1</span><span class="message">The class `ReadFirmwareProgressStep` is using inheritance, consider using composition instead.

Does `ReadFirmwareProgressStep` want to expose the complete interface (`onResume, onPause, toString`) of `ProgressStep` such that `ReadFirmwareProgressStep` can be used where `ProgressStep` is expected? Indicates __inheritance__.

Does `ReadFirmwareProgressStep` want only some/part of the behavior exposed by `ProgressStep`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   6 </span>import com.airthings.instrumentapi.BleException
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">internal class ReadFirmwareProgressStep(</span>
<span class="lineno">   9 </span><span class="error">    logTag: String,</span>
<span class="lineno">  10 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  11 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/SetHubRegionProgressStep.kt:7:1</span><span class="message">The class `SetHubRegionProgressStep` is using inheritance, consider using composition instead.

Does `SetHubRegionProgressStep` want to expose the complete interface (`onResume, onPause, toString`) of `ProgressStep` such that `SetHubRegionProgressStep` can be used where `ProgressStep` is expected? Indicates __inheritance__.

Does `SetHubRegionProgressStep` want only some/part of the behavior exposed by `ProgressStep`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.airthings.R
<span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class SetHubRegionProgressStep constructor(</span>
<span class="lineno">   8 </span><span class="error">    logTag: String,</span>
<span class="lineno">   9 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  10 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/SetWaveRegionProgressStep.kt:7:1</span><span class="message">The class `SetWaveRegionProgressStep` is using inheritance, consider using composition instead.

Does `SetWaveRegionProgressStep` want to expose the complete interface (`onResume, onPause, toString`) of `ProgressStep` such that `SetWaveRegionProgressStep` can be used where `ProgressStep` is expected? Indicates __inheritance__.

Does `SetWaveRegionProgressStep` want only some/part of the behavior exposed by `ProgressStep`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.airthings.R
<span class="lineno">   5 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class SetWaveRegionProgressStep constructor(</span>
<span class="lineno">   8 </span><span class="error">    logTag: String,</span>
<span class="lineno">   9 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  10 </span><span class="error">    handler: ResultHandler</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/UpdateFirmwareProgressStep.kt:9:1</span><span class="message">The class `UpdateFirmwareProgressStep` is using inheritance, consider using composition instead.

Does `UpdateFirmwareProgressStep` want to expose the complete interface (`onResume, onPause, toString`) of `ProgressStep` such that `UpdateFirmwareProgressStep` can be used where `ProgressStep` is expected? Indicates __inheritance__.

Does `UpdateFirmwareProgressStep` want only some/part of the behavior exposed by `ProgressStep`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>import com.airthings.airthings.wizard.device.DeviceViewModel
<span class="lineno">   7 </span>import com.airthings.instrumentapi.BleException
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">internal class UpdateFirmwareProgressStep(</span>
<span class="lineno">  10 </span><span class="error">    logTag: String,</span>
<span class="lineno">  11 </span><span class="error">    resources: Resources,</span>
<span class="lineno">  12 </span><span class="error">    handler: ResultHandler,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/main/java/com/airthings/airthings/wizard/device/page/progress/WizardActivity.kt:14:1</span><span class="message">The class `WizardActivity` is using inheritance, consider using composition instead.

Does `WizardActivity` want to expose the complete interface (`requestBluetoothEnable, requestLocationPermission, requestBluetoothAdminPermission, requestBluetoothPermission, onRequestPermissionsResult, onNewIntent, onResume, onDestroy, injectViewModelFactory, onCreate`) of `BaseActivity` such that `WizardActivity` can be used where `BaseActivity` is expected? Indicates __inheritance__.

Does `WizardActivity` want only some/part of the behavior exposed by `BaseActivity`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.uicomponents.wizard.WizardPage
<span class="lineno">  12 </span>import com.airthings.uicomponents.wizard.WizardPagerAdapter
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">abstract class WizardActivity : BaseActivity&lt;DeviceViewModel&gt;() {</span>
<span class="lineno">  15 </span><span class="error"></span>
<span class="lineno">  16 </span><span class="error">    internal lateinit var navigator: WizardNavigatorConfig</span>
<span class="lineno">  17 </span><span class="error">    internal abstract val pagerAdapter: WizardPagerAdapter</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/test/java/com/airthings/airthings/models/ArrayRecordRepository.kt:9:1</span><span class="message">The class `ArrayRecordRepository` is using inheritance, consider using composition instead.

Does `ArrayRecordRepository` want to expose the complete interface (`syncFrom, markRecordsAsSynced, deleteAllRecords, getRecords, getUnsyncedRecords, storeRecords, getLatestSyncedRecords`) of `RecordRepository` such that `ArrayRecordRepository` can be used where `RecordRepository` is expected? Indicates __inheritance__.

Does `ArrayRecordRepository` want only some/part of the behavior exposed by `RecordRepository`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>import java.util.Calendar
<span class="lineno">   7 </span>import kotlin.math.min
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">class ArrayRecordRepository(</span>
<span class="lineno">  10 </span><span class="error">    serial: String,</span>
<span class="lineno">  11 </span><span class="error">    credentialRepository: CredentialRepository,</span>
<span class="lineno">  12 </span><span class="error">    val records: MutableList&lt;RecordData&gt;,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/app/src/test/java/com/airthings/airthings/models/device/ConnectedUserDeviceTest.kt:35:1</span><span class="message">The class `TestUserDevice` is using inheritance, consider using composition instead.

Does `TestUserDevice` want to expose the complete interface (`toString, segmentStartTime, sensorStorageSizeBytes, latestBatteryVoltage, lastSyncedTime, samplesSynced, getLastBleConnectionTime, clearData, getValuesAsSensorMap, getValues, triggerLightRing, connect, disconnect, writeDefaultUiSettings, getLastError, shouldUpdateDevice, bluetoothSync, cloudUpSync, cloudDownSync, sync, isInSync, findBluetoothDevice, updateFirmware, getFwVersionsFromBluetooth, getFwVersionsFromCache, writeDefaultSettings, userDeviceDataUpdated`) of `ConnectedUserDevice` such that `TestUserDevice` can be used where `ConnectedUserDevice` is expected? Indicates __inheritance__.

Does `TestUserDevice` want only some/part of the behavior exposed by `ConnectedUserDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  32 </span>import org.mockito.Mockito.`when`
<span class="lineno">  33 </span>import org.mockito.Mockito.mock
<span class="lineno">  34 </span>
<span class="lineno">  35 </span><span class="error">class TestUserDevice(</span>
<span class="lineno">  36 </span><span class="error">    userDeviceData: UserDeviceData,</span>
<span class="lineno">  37 </span><span class="error">    deviceRepository: DeviceRepository,</span>
<span class="lineno">  38 </span><span class="error">    credentialRepository: CredentialRepository,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/AirthingsRadonDevice.kt:10:1</span><span class="message">The class `AirthingsRadonDevice` is using inheritance, consider using composition instead.

Does `AirthingsRadonDevice` want to expose the complete interface (`hashCode, equals, toString, writeUiSettings, writeDefaultUiSettings, disconnect, readUiSettings, getSensorValues, getFirmwareVersion, readCurrentValues, updateFirmware, writeRfRegion, readRfRegion, pulse, connect`) of `AirthingsDevice` such that `AirthingsRadonDevice` can be used where `AirthingsDevice` is expected? Indicates __inheritance__.

Does `AirthingsRadonDevice` want only some/part of the behavior exposed by `AirthingsDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import com.airthings.utilities.Success
<span class="lineno">   8 </span>import com.airthings.utilities.ui
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">abstract class AirthingsRadonDevice(serial: String, mac: String, model: Model) : AirthingsDevice(serial, mac, model) {</span>
<span class="lineno">  11 </span><span class="error">    fun isRadonAlarmEnabled(fn: (enabled: Boolean?, err: Throwable?) -&gt; Unit) {</span>
<span class="lineno">  12 </span><span class="error">        readUiSettings { settings, err -&gt;</span>
<span class="lineno">  13 </span><span class="error">            if (err != null) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/GriffinDevice.kt:16:1</span><span class="message">The class `GriffinDevice` is using inheritance, consider using composition instead.

Does `GriffinDevice` want to expose the complete interface (`setRadonAlarmEnabled, isRadonAlarmEnabled, setRadonAlarmEnabled, isRadonAlarmEnabled`) of `AirthingsRadonDevice` such that `GriffinDevice` can be used where `AirthingsRadonDevice` is expected? Indicates __inheritance__.

Does `GriffinDevice` want only some/part of the behavior exposed by `AirthingsRadonDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import com.airthings.utilities.ui
<span class="lineno">  14 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">abstract class GriffinDevice(serial: String, mac: String, model: Model) : AirthingsRadonDevice(serial, mac, model) {</span>
<span class="lineno">  17 </span><span class="error">    override val defaultUISettings: UISettings = WavePlusUiSettings()</span>
<span class="lineno">  18 </span><span class="error"></span>
<span class="lineno">  19 </span><span class="error">    override fun pulse(fn: (err: Throwable?) -&gt; Unit) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/HubDevice.kt:11:1</span><span class="message">The class `HubDevice` is using inheritance, consider using composition instead.

Does `HubDevice` want to expose the complete interface (`hashCode, equals, toString, writeUiSettings, writeDefaultUiSettings, disconnect, readUiSettings, getSensorValues, getFirmwareVersion, readCurrentValues, updateFirmware, writeRfRegion, readRfRegion, pulse, connect`) of `AirthingsDevice` such that `HubDevice` can be used where `AirthingsDevice` is expected? Indicates __inheritance__.

Does `HubDevice` want only some/part of the behavior exposed by `AirthingsDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.utilities.TryCallback
<span class="lineno">   9 </span>import java.lang.UnsupportedOperationException
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">open class HubDevice(serial: String, mac: String) : AirthingsDevice(serial, mac, Model.Hub) {</span>
<span class="lineno">  12 </span><span class="error"></span>
<span class="lineno">  13 </span><span class="error">    override val modelName: String = &quot;Hub&quot;</span>
<span class="lineno">  14 </span><span class="error">    override val defaultUISettings: UISettings</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/MerlinDevice.kt:15:1</span><span class="message">The class `MerlinDevice` is using inheritance, consider using composition instead.

Does `MerlinDevice` want to expose the complete interface (`hashCode, equals, toString, writeUiSettings, writeDefaultUiSettings, disconnect, readUiSettings, getSensorValues, getFirmwareVersion, readCurrentValues, updateFirmware, writeRfRegion, readRfRegion, pulse, connect`) of `AirthingsDevice` such that `MerlinDevice` can be used where `AirthingsDevice` is expected? Indicates __inheritance__.

Does `MerlinDevice` want only some/part of the behavior exposed by `AirthingsDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>import com.airthings.utilities.ui
<span class="lineno">  13 </span>import kotlin.coroutines.suspendCoroutine
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">abstract class MerlinDevice(serial: String, mac: String, model: Model) : AirthingsDevice(serial, mac, model) {</span>
<span class="lineno">  16 </span><span class="error">    override val defaultUISettings: UISettings = MerlinUiSettings()</span>
<span class="lineno">  17 </span><span class="error">    override fun pulse(fn: (err: Throwable?) -&gt; Unit) {</span>
<span class="lineno">  18 </span><span class="error">        this.interactionClient.postCommand(this.serial,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/MistDevice.kt:3:1</span><span class="message">The class `MistDevice` is using inheritance, consider using composition instead.

Does `MistDevice` want to expose the complete interface (`writeRfRegion, readRfRegion, pulse`) of `MerlinDevice` such that `MistDevice` can be used where `MerlinDevice` is expected? Indicates __inheritance__.

Does `MistDevice` want only some/part of the behavior exposed by `MerlinDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   1 </span>package com.airthings.aircurtain
<span class="lineno">   2 </span>
<span class="lineno">   3 </span><span class="error">class MistDevice(serial: String, mac: String) : MerlinDevice(serial, mac, Model.Mist) {</span>
<span class="lineno">   4 </span><span class="error">    override val modelName: String = &quot;Mist&quot;</span>
<span class="lineno">   5 </span><span class="error">}</span>
<span class="lineno">   6 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/Observer.kt:16:1</span><span class="message">The class `MutableObservable` is using inheritance, consider using composition instead.

Does `MutableObservable` want to expose the complete interface (`unObserve, observeOnce, observe`) of `Observable` such that `MutableObservable` can be used where `Observable` is expected? Indicates __inheritance__.

Does `MutableObservable` want only some/part of the behavior exposed by `Observable`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>    abstract fun unObserve(observer: Observer&lt;T&gt;): Boolean
<span class="lineno">  14 </span>}
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">class MutableObservable&lt;T&gt;(initial: T) : Observable&lt;T&gt;() {</span>
<span class="lineno">  17 </span><span class="error">    private val listeners = CopyOnWriteArraySet&lt;Observer&lt;T&gt;&gt;()</span>
<span class="lineno">  18 </span><span class="error">    override var value: T by Delegates.observable(initialValue = initial, onChange = { _, _, _ -&gt;</span>
<span class="lineno">  19 </span><span class="error">        val toRemove = mutableListOf&lt;Observer&lt;T&gt;&gt;()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/UnknownDevice.kt:6:1</span><span class="message">The class `UnknownDevice` is using inheritance, consider using composition instead.

Does `UnknownDevice` want to expose the complete interface (`hashCode, equals, toString, writeUiSettings, writeDefaultUiSettings, disconnect, readUiSettings, getSensorValues, getFirmwareVersion, readCurrentValues, updateFirmware, writeRfRegion, readRfRegion, pulse, connect`) of `AirthingsDevice` such that `UnknownDevice` can be used where `AirthingsDevice` is expected? Indicates __inheritance__.

Does `UnknownDevice` want only some/part of the behavior exposed by `AirthingsDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   3 </span>import com.airthings.core.entities.Region
<span class="lineno">   4 </span>import com.airthings.instrumentapi.instrumentops.uisettings.UISettings
<span class="lineno">   5 </span>
<span class="lineno">   6 </span><span class="error">/**</span>
<span class="lineno">   7 </span><span class="error"> * This is left here in case the app needs to use it for some reason. It has no power in AirCurtain beyond that.</span>
<span class="lineno">   8 </span><span class="error"> */</span>
<span class="lineno">   9 </span><span class="error">@Suppress(&quot;unused&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/Wave1Device.kt:20:1</span><span class="message">The class `Wave1Device` is using inheritance, consider using composition instead.

Does `Wave1Device` want to expose the complete interface (`setRadonAlarmEnabled, isRadonAlarmEnabled, setRadonAlarmEnabled, isRadonAlarmEnabled`) of `AirthingsRadonDevice` such that `Wave1Device` can be used where `AirthingsRadonDevice` is expected? Indicates __inheritance__.

Does `Wave1Device` want only some/part of the behavior exposed by `AirthingsRadonDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  17 </span>import com.airthings.utilities.Success
<span class="lineno">  18 </span>import com.airthings.utilities.ui
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">open class Wave1Device(serial: String, mac: String) : AirthingsRadonDevice(serial, mac, Model.Wave1) {</span>
<span class="lineno">  21 </span><span class="error"></span>
<span class="lineno">  22 </span><span class="error">    override val modelName: String = &quot;Wave&quot;</span>
<span class="lineno">  23 </span><span class="error">    override val defaultUISettings: UISettings = WaveUiSettings()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/Wave2Device.kt:7:1</span><span class="message">The class `Wave2Device` is using inheritance, consider using composition instead.

Does `Wave2Device` want to expose the complete interface (`writeRfRegion, readRfRegion, setRadonAlarmEnabled, isRadonAlarmEnabled, pulse`) of `GriffinDevice` such that `Wave2Device` can be used where `GriffinDevice` is expected? Indicates __inheritance__.

Does `Wave2Device` want only some/part of the behavior exposed by `GriffinDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.instrumentapi.instrumentops.UICommand
<span class="lineno">   5 </span>import com.airthings.utilities.ui
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">open class Wave2Device(serial: String, mac: String) : GriffinDevice(serial, mac, Model.Wave2) {</span>
<span class="lineno">   8 </span><span class="error">    override val modelName: String = &quot;Wave&quot;</span>
<span class="lineno">   9 </span><span class="error"></span>
<span class="lineno">  10 </span><span class="error">    override fun pulse(fn: (err: Throwable?) -&gt; Unit) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/WaveMiniDevice.kt:3:1</span><span class="message">The class `WaveMiniDevice` is using inheritance, consider using composition instead.

Does `WaveMiniDevice` want to expose the complete interface (`writeRfRegion, readRfRegion, pulse`) of `MerlinDevice` such that `WaveMiniDevice` can be used where `MerlinDevice` is expected? Indicates __inheritance__.

Does `WaveMiniDevice` want only some/part of the behavior exposed by `MerlinDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   1 </span>package com.airthings.aircurtain
<span class="lineno">   2 </span>
<span class="lineno">   3 </span><span class="error">open class WaveMiniDevice(serial: String, mac: String) : MerlinDevice(serial, mac, Model.WaveMini) {</span>
<span class="lineno">   4 </span><span class="error"></span>
<span class="lineno">   5 </span><span class="error">    override val modelName: String = &quot;Wave Mini&quot;</span>
<span class="lineno">   6 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-aircurtain/src/main/java/com/airthings/aircurtain/WavePlusDevice.kt:7:1</span><span class="message">The class `WavePlusDevice` is using inheritance, consider using composition instead.

Does `WavePlusDevice` want to expose the complete interface (`writeRfRegion, readRfRegion, setRadonAlarmEnabled, isRadonAlarmEnabled, pulse`) of `GriffinDevice` such that `WavePlusDevice` can be used where `GriffinDevice` is expected? Indicates __inheritance__.

Does `WavePlusDevice` want only some/part of the behavior exposed by `GriffinDevice`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.instrumentapi.instrumentops.UICommand
<span class="lineno">   5 </span>import com.airthings.utilities.ui
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">open class WavePlusDevice(serial: String, mac: String) : GriffinDevice(serial, mac, Model.WavePlus) {</span>
<span class="lineno">   8 </span><span class="error">    override val modelName: String = &quot;Wave Plus&quot;</span>
<span class="lineno">   9 </span><span class="error"></span>
<span class="lineno">  10 </span><span class="error">    override fun pulse(fn: (err: Throwable?) -&gt; Unit) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-core/src/main/java/com/airthings/core/entities/instrument/Instrument.kt:8:1</span><span class="message">The class `Instrument` is using inheritance, consider using composition instead.

Does `Instrument` want to expose the complete interface (`empty public interface`) of `SimpleInstrument` such that `Instrument` can be used where `SimpleInstrument` is expected? Indicates __inheritance__.

Does `Instrument` want only some/part of the behavior exposed by `SimpleInstrument`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   5 </span>
<span class="lineno">   6 </span>open class SimpleInstrument(open val type: Instrument.Type, open val serialNumber: String)
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">class Instrument(</span>
<span class="lineno">   9 </span><span class="error">    override val type: Type,</span>
<span class="lineno">  10 </span><span class="error">    override val serialNumber: String</span>
<span class="lineno">  11 </span><span class="error">) : SimpleInstrument(type, serialNumber), ISensors {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-core/src/main/java/com/airthings/core/entities/segments/WaveSegment.kt:6:1</span><span class="message">The class `WaveSegment` is using inheritance, consider using composition instead.

Does `WaveSegment` want to expose the complete interface (`getTimeLastSynced, getSamples`) of `Segment` such that `WaveSegment` can be used where `Segment` is expected? Indicates __inheritance__.

Does `WaveSegment` want only some/part of the behavior exposed by `Segment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   3 </span>import java.util.ArrayList
<span class="lineno">   4 </span>import java.util.TreeMap
<span class="lineno">   5 </span>
<span class="lineno">   6 </span><span class="error">open class WaveSegment(override val id: String, override val startTime: Long) : Segment() {</span>
<span class="lineno">   7 </span><span class="error"></span>
<span class="lineno">   8 </span><span class="error">    var latitude: Double = 0.toDouble()</span>
<span class="lineno">   9 </span><span class="error">    var longitude: Double = 0.toDouble()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/androidTest/java/com/airthings/instrumentapi/DeviceHolderTest.kt:20:1</span><span class="message">The class `MockIns` is using inheritance, consider using composition instead.

Does `MockIns` want to expose the complete interface (`setDisconnectListener, getDisconnectListener, disconnected, disconnect, isConfiguredForPairing, isConnected, connect`) of `Instrument` such that `MockIns` can be used where `Instrument` is expected? Indicates __inheritance__.

Does `MockIns` want only some/part of the behavior exposed by `Instrument`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  17 </span>import org.mockito.Mockito
<span class="lineno">  18 </span>import org.mockito.Mockito.mock
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">internal class MockIns(private val sn: Long) : Instrument() {</span>
<span class="lineno">  21 </span><span class="error">    override val context: Context</span>
<span class="lineno">  22 </span><span class="error">        get() = mock(Context::class.java)</span>
<span class="lineno">  23 </span><span class="error">    override val serialNumber: Long</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/androidTest/java/com/airthings/instrumentapi/instrumentops/ReadCurrentValuesTest.kt:8:1</span><span class="message">The class `ReadCurrentValuesTest` is using inheritance, consider using composition instead.

Does `ReadCurrentValuesTest` want to expose the complete interface (`setUp`) of `InstrumentCommandTestPreparation` such that `ReadCurrentValuesTest` can be used where `InstrumentCommandTestPreparation` is expected? Indicates __inheritance__.

Does `ReadCurrentValuesTest` want only some/part of the behavior exposed by `InstrumentCommandTestPreparation`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   5 </span>import org.junit.Assert.assertTrue
<span class="lineno">   6 </span>import org.junit.Test
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">class ReadCurrentValuesTest : InstrumentCommandTestPreparation(), ReadCurrentValues.ReadCurrentValuesCB {</span>
<span class="lineno">   9 </span><span class="error"></span>
<span class="lineno">  10 </span><span class="error">    var successWasCalled = false</span>
<span class="lineno">  11 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/InstrumentInteractionHandler.kt:11:1</span><span class="message">The class `InstrumentInteractionHandler` is using inheritance, consider using composition instead.

Does `InstrumentInteractionHandler` want to expose the complete interface (`initiateInteraction, disconnect, postCommand, isInitialized`) of `InstrumentInteraction` such that `InstrumentInteractionHandler` can be used where `InstrumentInteraction` is expected? Indicates __inheritance__.

Does `InstrumentInteractionHandler` want only some/part of the behavior exposed by `InstrumentInteraction`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.instrumentapi.instrumentops.InstrumentCommand
<span class="lineno">   9 </span>import com.airthings.utilities.Log
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">class InstrumentInteractionHandler internal constructor(</span>
<span class="lineno">  12 </span><span class="error">    context: Context,</span>
<span class="lineno">  13 </span><span class="error">    serialNumber: String,</span>
<span class="lineno">  14 </span><span class="error">    interactionCallback: InteractionCallback2</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/fwutil/BleFwImageLoader.kt:11:1</span><span class="message">The class `BleFwImageLoader` is using inheritance, consider using composition instead.

Does `BleFwImageLoader` want to expose the complete interface (`tryLoadAndValidateImage, tryLoadAndValidateImage`) of `FwImageLoader` such that `BleFwImageLoader` can be used where `FwImageLoader` is expected? Indicates __inheritance__.

Does `BleFwImageLoader` want only some/part of the behavior exposed by `FwImageLoader`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import java.io.InputStream
<span class="lineno">   9 </span>import java.util.regex.Pattern
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">class BleFwImageLoader(path: String, val context: Context) : FwImageLoader(path) {</span>
<span class="lineno">  12 </span><span class="error"></span>
<span class="lineno">  13 </span><span class="error">    @Suppress(&quot;NotImplementedDeclaration&quot;)</span>
<span class="lineno">  14 </span><span class="error">    override fun tryLoadAndValidateImage(fileName: String) = throw NotImplementedError(&quot;Not implemented.&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/fwutil/MspFwImageData.kt:3:1</span><span class="message">The class `MspFwImageData` is using inheritance, consider using composition instead.

Does `MspFwImageData` want to expose the complete interface (`empty public interface`) of `FwImageData` such that `MspFwImageData` can be used where `FwImageData` is expected? Indicates __inheritance__.

Does `MspFwImageData` want only some/part of the behavior exposed by `FwImageData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   1 </span>package com.airthings.instrumentapi.fwutil
<span class="lineno">   2 </span>
<span class="lineno">   3 </span><span class="error">class MspFwImageData(</span>
<span class="lineno">   4 </span><span class="error">    fwImageName: String,</span>
<span class="lineno">   5 </span><span class="error">    fwImageBinary: List&lt;ByteArray&gt;,</span>
<span class="lineno">   6 </span><span class="error">    val header: MspFwHeader</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/fwutil/MspFwImageLoader.kt:12:1</span><span class="message">The class `MspFwImageLoader` is using inheritance, consider using composition instead.

Does `MspFwImageLoader` want to expose the complete interface (`tryLoadAndValidateImage, tryLoadAndValidateImage`) of `FwImageLoader` such that `MspFwImageLoader` can be used where `FwImageLoader` is expected? Indicates __inheritance__.

Does `MspFwImageLoader` want only some/part of the behavior exposed by `FwImageLoader`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import java.io.InputStream
<span class="lineno">  10 </span>import java.util.regex.Pattern
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class MspFwImageLoader(val context: Context, path: String) : FwImageLoader(path) {</span>
<span class="lineno">  13 </span><span class="error"></span>
<span class="lineno">  14 </span><span class="error">    private val numWritesKeyword = &quot;NUMWRITES=&quot;</span>
<span class="lineno">  15 </span><span class="error">    private val startIdxKeyword = &quot;STARTIDX=&quot;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/fwutil/waveplus/FakeTestImageSource.kt:45:5</span><span class="message">The class `FakeHeader` is using inheritance, consider using composition instead.

Does `FakeHeader` want to expose the complete interface (`initialize, getHeaderForImageNotify`) of `Header` such that `FakeHeader` can be used where `Header` is expected? Indicates __inheritance__.

Does `FakeHeader` want only some/part of the behavior exposed by `Header`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  42 </span>        return WavePlusFwImage(&quot;&quot;, &quot;&quot;, rawData, header, FirmwareImageType.BLE)
<span class="lineno">  43 </span>    }
<span class="lineno">  44 </span>
<span class="lineno">  45 </span>    <span class="error">class FakeHeader : Header(byteArrayOf()) {</span>
<span class="lineno">  46 </span><span class="error">        override fun initialize() {</span>
<span class="lineno">  47 </span><span class="error">            this.bimVersion = 1</span>
<span class="lineno">  48 </span><span class="error">            this.headerLength = 44</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/fwutil/waveplus/WavePlusImageLoader.kt:343:5</span><span class="message">The class `ContiguousImageInformation` is using inheritance, consider using composition instead.

Does `ContiguousImageInformation` want to expose the complete interface (`printSegmentInformation`) of `SegmentInformation` such that `ContiguousImageInformation` can be used where `SegmentInformation` is expected? Indicates __inheritance__.

Does `ContiguousImageInformation` want only some/part of the behavior exposed by `SegmentInformation`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 340 </span>        return true
<span class="lineno"> 341 </span>    }
<span class="lineno"> 342 </span>
<span class="lineno"> 343 </span>    <span class="error">class ContiguousImageInformation : SegmentInformation() {</span>
<span class="lineno"> 344 </span><span class="error">        var stackEntryAddress: Long = 0</span>
<span class="lineno"> 345 </span><span class="error"></span>
<span class="lineno"> 346 </span><span class="error">        override val isContiguous: Boolean = true</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/fwutil/waveplus/WavePlusImageLoader.kt:349:5</span><span class="message">The class `BoundaryInformation` is using inheritance, consider using composition instead.

Does `BoundaryInformation` want to expose the complete interface (`printSegmentInformation`) of `SegmentInformation` such that `BoundaryInformation` can be used where `SegmentInformation` is expected? Indicates __inheritance__.

Does `BoundaryInformation` want only some/part of the behavior exposed by `SegmentInformation`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 346 </span>        override val isContiguous: Boolean = true
<span class="lineno"> 347 </span>    }
<span class="lineno"> 348 </span>
<span class="lineno"> 349 </span>    <span class="error">class BoundaryInformation : SegmentInformation() {</span>
<span class="lineno"> 350 </span><span class="error">        var stackEntryAddress: Long = 0</span>
<span class="lineno"> 351 </span><span class="error">        var boundaryIcallStack0Address: Long = 0</span>
<span class="lineno"> 352 </span><span class="error">        var boundaryRamStartAddress: Long = 0</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/BtSampleMakerFactory.kt:26:1</span><span class="message">The class `NullBtSampleMaker` is using inheritance, consider using composition instead.

Does `NullBtSampleMaker` want to expose the complete interface (`add5MinuteRecords, addHourlyRecords`) of `BtSampleMaker` such that `NullBtSampleMaker` can be used where `BtSampleMaker` is expected? Indicates __inheritance__.

Does `NullBtSampleMaker` want only some/part of the behavior exposed by `BtSampleMaker`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  23 </span>    }
<span class="lineno">  24 </span>}
<span class="lineno">  25 </span>
<span class="lineno">  26 </span><span class="error">internal class NullBtSampleMaker(dataSetInfo: DataSetInfo, bleFwVersion: String, mspFwVersion: String) :</span>
<span class="lineno">  27 </span><span class="error">    BtSampleMaker(dataSetInfo, bleFwVersion, mspFwVersion) {</span>
<span class="lineno">  28 </span><span class="error">    override fun add5MinuteRecords(sensorRecords: ArrayList&lt;SensorRecord&gt;, block: HourInfoBlock, index: Int) {</span>
<span class="lineno">  29 </span><span class="error">        // STUBBED TO DO NOTHING</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/BtSampleMakerFactory.kt:37:1</span><span class="message">The class `Wave2BtSampleMaker` is using inheritance, consider using composition instead.

Does `Wave2BtSampleMaker` want to expose the complete interface (`add5MinuteRecords, addHourlyRecords`) of `BtSampleMaker` such that `Wave2BtSampleMaker` can be used where `BtSampleMaker` is expected? Indicates __inheritance__.

Does `Wave2BtSampleMaker` want only some/part of the behavior exposed by `BtSampleMaker`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  34 </span>    }
<span class="lineno">  35 </span>}
<span class="lineno">  36 </span>
<span class="lineno">  37 </span><span class="error">internal class Wave2BtSampleMaker(dataSetInfo: DataSetInfo, bleFwVersion: String, mspFwVersion: String) :</span>
<span class="lineno">  38 </span><span class="error">    BtSampleMaker(dataSetInfo, bleFwVersion, mspFwVersion) {</span>
<span class="lineno">  39 </span><span class="error">    override fun addHourlyRecords(sensorRecordsHourly: ArrayList&lt;SensorRecord&gt;, block: HourInfoBlock) {</span>
<span class="lineno">  40 </span><span class="error">        sensorRecordsHourly.add(SensorRecord(RecordType.HCTS_Bk, block.radon?.hcts_Bk))</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/BtSampleMakerFactory.kt:67:1</span><span class="message">The class `WavePlusBtSampleMaker` is using inheritance, consider using composition instead.

Does `WavePlusBtSampleMaker` want to expose the complete interface (`add5MinuteRecords, addHourlyRecords`) of `BtSampleMaker` such that `WavePlusBtSampleMaker` can be used where `BtSampleMaker` is expected? Indicates __inheritance__.

Does `WavePlusBtSampleMaker` want only some/part of the behavior exposed by `BtSampleMaker`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  64 </span>    }
<span class="lineno">  65 </span>}
<span class="lineno">  66 </span>
<span class="lineno">  67 </span><span class="error">internal class WavePlusBtSampleMaker(</span>
<span class="lineno">  68 </span><span class="error">    dataSetInfo: DataSetInfo,</span>
<span class="lineno">  69 </span><span class="error">    bleFwVersion: String,</span>
<span class="lineno">  70 </span><span class="error">    mspFwVersion: String</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/Instrument.kt:48:1</span><span class="message">The class `NullInstrument` is using inheritance, consider using composition instead.

Does `NullInstrument` want to expose the complete interface (`setDisconnectListener, getDisconnectListener, disconnected, disconnect, isConfiguredForPairing, isConnected, connect`) of `Instrument` such that `NullInstrument` can be used where `Instrument` is expected? Indicates __inheritance__.

Does `NullInstrument` want only some/part of the behavior exposed by `Instrument`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  45 </span>    }
<span class="lineno">  46 </span>}
<span class="lineno">  47 </span>
<span class="lineno">  48 </span><span class="error">internal open class NullInstrument(</span>
<span class="lineno">  49 </span><span class="error">    override val context: Context,</span>
<span class="lineno">  50 </span><span class="error">    override val serialNumber: Long,</span>
<span class="lineno">  51 </span><span class="error">    final override val scanResult: ScanResult</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/Instrument.kt:65:5</span><span class="message">The class `NullScanResultData` is using inheritance, consider using composition instead.

Does `NullScanResultData` want to expose the complete interface (`empty public interface`) of `ScanResultData` such that `NullScanResultData` can be used where `ScanResultData` is expected? Indicates __inheritance__.

Does `NullScanResultData` want only some/part of the behavior exposed by `ScanResultData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  62 </span>        return Failure(Exception(&quot;Instrument of type NullInstrument are not connectible.&quot;))
<span class="lineno">  63 </span>    }
<span class="lineno">  64 </span>
<span class="lineno">  65 </span>    <span class="error">private class NullScanResultData(scanResult: ScanResult) : ScanResultData(scanResult) {</span>
<span class="lineno">  66 </span><span class="error">        override val isHubConnected: Boolean = false</span>
<span class="lineno">  67 </span><span class="error">    }</span>
<span class="lineno">  68 </span>}
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/AtGattProfile.kt:26:1</span><span class="message">The class `WavePlusGattProfile` is using inheritance, consider using composition instead.

Does `WavePlusGattProfile` want to expose the complete interface (`empty public interface`) of `AtGattProfile` such that `WavePlusGattProfile` can be used where `AtGattProfile` is expected? Indicates __inheritance__.

Does `WavePlusGattProfile` want only some/part of the behavior exposed by `AtGattProfile`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  23 </span>    abstract var btSigDisFirmwareRevisionChar: BluetoothGattCharacteristic
<span class="lineno">  24 </span>}
<span class="lineno">  25 </span>
<span class="lineno">  26 </span><span class="error">internal open class WavePlusGattProfile(gattClient: GattClient) : AtGattProfile() {</span>
<span class="lineno">  27 </span><span class="error"></span>
<span class="lineno">  28 </span><span class="error">    override val airSensorServiceUUID = UUID.fromString(&quot;b42e1c08-ade7-11e4-89d3-123b93f75cba&quot;)</span>
<span class="lineno">  29 </span><span class="error">    override val asracpCharUUID = UUID.fromString(ASRACP_UUID)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/AtGattProfile.kt:71:1</span><span class="message">The class `WaveGattProfile` is using inheritance, consider using composition instead.

Does `WaveGattProfile` want to expose the complete interface (`empty public interface`) of `AtGattProfile` such that `WaveGattProfile` can be used where `AtGattProfile` is expected? Indicates __inheritance__.

Does `WaveGattProfile` want only some/part of the behavior exposed by `AtGattProfile`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  68 </span>    }
<span class="lineno">  69 </span>}
<span class="lineno">  70 </span>
<span class="lineno">  71 </span><span class="error">internal class WaveGattProfile(gattClient: GattClient) : AtGattProfile() {</span>
<span class="lineno">  72 </span><span class="error"></span>
<span class="lineno">  73 </span><span class="error">    override val airSensorServiceUUID = UUID.fromString(&quot;b42e1f6e-ade7-11e4-89d3-123b93f75cba&quot;)</span>
<span class="lineno">  74 </span><span class="error">    override val asracpCharUUID = UUID.fromString(&quot;b42e24fa-ade7-11e4-89d3-123b93f75cba&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/AtGattProfile.kt:116:1</span><span class="message">The class `Wave2GattProfile` is using inheritance, consider using composition instead.

Does `Wave2GattProfile` want to expose the complete interface (`empty public interface`) of `AtGattProfile` such that `Wave2GattProfile` can be used where `AtGattProfile` is expected? Indicates __inheritance__.

Does `Wave2GattProfile` want only some/part of the behavior exposed by `AtGattProfile`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 113 </span>        airSensorService.getCharacteristic(currentCombinedSensorsCharUUID) ?: throw IllegalStateException()
<span class="lineno"> 114 </span>}
<span class="lineno"> 115 </span>
<span class="lineno"> 116 </span><span class="error">internal class Wave2GattProfile(gattClient: GattClient) : AtGattProfile() {</span>
<span class="lineno"> 117 </span><span class="error">    override val airSensorServiceUUID = UUID.fromString(DeviceDefines.Wave2ServiceUUID)</span>
<span class="lineno"> 118 </span><span class="error">    override val asracpCharUUID = UUID.fromString(&quot;b42e50d8-ade7-11e4-89d3-123b93f75cba&quot;)</span>
<span class="lineno"> 119 </span><span class="error">    override val asrCharUUID = UUID.fromString(&quot;b42e538a-ade7-11e4-89d3-123b93f75cba&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:218:1</span><span class="message">The class `OnCharacteristicChangedListener` is using inheritance, consider using composition instead.

Does `OnCharacteristicChangedListener` want to expose the complete interface (`empty public interface`) of `GattObserver` such that `OnCharacteristicChangedListener` can be used where `GattObserver` is expected? Indicates __inheritance__.

Does `OnCharacteristicChangedListener` want only some/part of the behavior exposed by `GattObserver`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 215 </span>    }
<span class="lineno"> 216 </span>}
<span class="lineno"> 217 </span>
<span class="lineno"> 218 </span><span class="error">abstract class OnCharacteristicChangedListener(uuid: UUID) : GattObserver(uuid) {</span>
<span class="lineno"> 219 </span><span class="error">    abstract fun onCharacteristicChanged(characteristic: BluetoothGattCharacteristic)</span>
<span class="lineno"> 220 </span><span class="error">}</span>
<span class="lineno"> 221 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:222:1</span><span class="message">The class `OnCharacteristicReadInterceptor` is using inheritance, consider using composition instead.

Does `OnCharacteristicReadInterceptor` want to expose the complete interface (`empty public interface`) of `GattObserver` such that `OnCharacteristicReadInterceptor` can be used where `GattObserver` is expected? Indicates __inheritance__.

Does `OnCharacteristicReadInterceptor` want only some/part of the behavior exposed by `GattObserver`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 219 </span>    abstract fun onCharacteristicChanged(characteristic: BluetoothGattCharacteristic)
<span class="lineno"> 220 </span>}
<span class="lineno"> 221 </span>
<span class="lineno"> 222 </span><span class="error">abstract class OnCharacteristicReadInterceptor(uuid: UUID) : GattObserver(uuid) {</span>
<span class="lineno"> 223 </span><span class="error">    abstract fun onCharacteristicReadIntercept(characteristic: BluetoothGattCharacteristic)</span>
<span class="lineno"> 224 </span><span class="error">}</span>
<span class="lineno"> 225 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:226:1</span><span class="message">The class `OnMtuChangedListener` is using inheritance, consider using composition instead.

Does `OnMtuChangedListener` want to expose the complete interface (`empty public interface`) of `GattObserver` such that `OnMtuChangedListener` can be used where `GattObserver` is expected? Indicates __inheritance__.

Does `OnMtuChangedListener` want only some/part of the behavior exposed by `GattObserver`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 223 </span>    abstract fun onCharacteristicReadIntercept(characteristic: BluetoothGattCharacteristic)
<span class="lineno"> 224 </span>}
<span class="lineno"> 225 </span>
<span class="lineno"> 226 </span><span class="error">abstract class OnMtuChangedListener(uuid: UUID) : GattObserver(uuid) {</span>
<span class="lineno"> 227 </span><span class="error">    abstract fun onMtuChanged(newMtu: Int, status: Int)</span>
<span class="lineno"> 228 </span><span class="error">}</span>
<span class="lineno"> 229 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:230:1</span><span class="message">The class `OnPhyReadListener` is using inheritance, consider using composition instead.

Does `OnPhyReadListener` want to expose the complete interface (`empty public interface`) of `GattObserver` such that `OnPhyReadListener` can be used where `GattObserver` is expected? Indicates __inheritance__.

Does `OnPhyReadListener` want only some/part of the behavior exposed by `GattObserver`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 227 </span>    abstract fun onMtuChanged(newMtu: Int, status: Int)
<span class="lineno"> 228 </span>}
<span class="lineno"> 229 </span>
<span class="lineno"> 230 </span><span class="error">abstract class OnPhyReadListener(uuid: UUID) : GattObserver(uuid) {</span>
<span class="lineno"> 231 </span><span class="error">    abstract fun onPhyRead(txPhy: Int, rxPhy: Int, status: Int)</span>
<span class="lineno"> 232 </span><span class="error">}</span>
<span class="lineno"> 233 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:234:1</span><span class="message">The class `OnPhyUpdateListener` is using inheritance, consider using composition instead.

Does `OnPhyUpdateListener` want to expose the complete interface (`empty public interface`) of `GattObserver` such that `OnPhyUpdateListener` can be used where `GattObserver` is expected? Indicates __inheritance__.

Does `OnPhyUpdateListener` want only some/part of the behavior exposed by `GattObserver`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 231 </span>    abstract fun onPhyRead(txPhy: Int, rxPhy: Int, status: Int)
<span class="lineno"> 232 </span>}
<span class="lineno"> 233 </span>
<span class="lineno"> 234 </span><span class="error">abstract class OnPhyUpdateListener(uuid: UUID) : GattObserver(uuid) {</span>
<span class="lineno"> 235 </span><span class="error">    abstract fun onPhyUpdate(txPhy: Int, rxPhy: Int, status: Int)</span>
<span class="lineno"> 236 </span><span class="error">}</span>
<span class="lineno"> 237 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:238:1</span><span class="message">The class `OnDescriptorWriteListener` is using inheritance, consider using composition instead.

Does `OnDescriptorWriteListener` want to expose the complete interface (`empty public interface`) of `GattObserver` such that `OnDescriptorWriteListener` can be used where `GattObserver` is expected? Indicates __inheritance__.

Does `OnDescriptorWriteListener` want only some/part of the behavior exposed by `GattObserver`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 235 </span>    abstract fun onPhyUpdate(txPhy: Int, rxPhy: Int, status: Int)
<span class="lineno"> 236 </span>}
<span class="lineno"> 237 </span>
<span class="lineno"> 238 </span><span class="error">abstract class OnDescriptorWriteListener(uuid: UUID) : GattObserver(uuid) {</span>
<span class="lineno"> 239 </span><span class="error">    abstract fun onDescriptorWrite(descriptor: BluetoothGattDescriptor, status: Int)</span>
<span class="lineno"> 240 </span><span class="error">}</span>
<span class="lineno"> 241 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:242:1</span><span class="message">The class `OnDescriptorReadListener` is using inheritance, consider using composition instead.

Does `OnDescriptorReadListener` want to expose the complete interface (`empty public interface`) of `GattObserver` such that `OnDescriptorReadListener` can be used where `GattObserver` is expected? Indicates __inheritance__.

Does `OnDescriptorReadListener` want only some/part of the behavior exposed by `GattObserver`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 239 </span>    abstract fun onDescriptorWrite(descriptor: BluetoothGattDescriptor, status: Int)
<span class="lineno"> 240 </span>}
<span class="lineno"> 241 </span>
<span class="lineno"> 242 </span><span class="error">abstract class OnDescriptorReadListener(uuid: UUID) : GattObserver(uuid) {</span>
<span class="lineno"> 243 </span><span class="error">    abstract fun onDescriptorRead(descriptor: BluetoothGattDescriptor, status: Int)</span>
<span class="lineno"> 244 </span><span class="error">}</span>
<span class="lineno"> 245 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:246:1</span><span class="message">The class `OnCharacteristicWriteListener` is using inheritance, consider using composition instead.

Does `OnCharacteristicWriteListener` want to expose the complete interface (`empty public interface`) of `GattObserver` such that `OnCharacteristicWriteListener` can be used where `GattObserver` is expected? Indicates __inheritance__.

Does `OnCharacteristicWriteListener` want only some/part of the behavior exposed by `GattObserver`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 243 </span>    abstract fun onDescriptorRead(descriptor: BluetoothGattDescriptor, status: Int)
<span class="lineno"> 244 </span>}
<span class="lineno"> 245 </span>
<span class="lineno"> 246 </span><span class="error">abstract class OnCharacteristicWriteListener(uuid: UUID) : GattObserver(uuid) {</span>
<span class="lineno"> 247 </span><span class="error">    abstract fun onCharacteristicWrite(characteristic: BluetoothGattCharacteristic, status: Int)</span>
<span class="lineno"> 248 </span><span class="error">}</span>
<span class="lineno"> 249 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:250:1</span><span class="message">The class `OnCharacteristicReadListener` is using inheritance, consider using composition instead.

Does `OnCharacteristicReadListener` want to expose the complete interface (`empty public interface`) of `GattObserver` such that `OnCharacteristicReadListener` can be used where `GattObserver` is expected? Indicates __inheritance__.

Does `OnCharacteristicReadListener` want only some/part of the behavior exposed by `GattObserver`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 247 </span>    abstract fun onCharacteristicWrite(characteristic: BluetoothGattCharacteristic, status: Int)
<span class="lineno"> 248 </span>}
<span class="lineno"> 249 </span>
<span class="lineno"> 250 </span><span class="error">abstract class OnCharacteristicReadListener(uuid: UUID) : GattObserver(uuid) {</span>
<span class="lineno"> 251 </span><span class="error">    abstract fun onCharacteristicRead(characteristic: BluetoothGattCharacteristic, status: Int)</span>
<span class="lineno"> 252 </span><span class="error">}</span>
<span class="lineno"> 253 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:254:1</span><span class="message">The class `OnServicesDiscoveredListener` is using inheritance, consider using composition instead.

Does `OnServicesDiscoveredListener` want to expose the complete interface (`empty public interface`) of `GattObserver` such that `OnServicesDiscoveredListener` can be used where `GattObserver` is expected? Indicates __inheritance__.

Does `OnServicesDiscoveredListener` want only some/part of the behavior exposed by `GattObserver`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 251 </span>    abstract fun onCharacteristicRead(characteristic: BluetoothGattCharacteristic, status: Int)
<span class="lineno"> 252 </span>}
<span class="lineno"> 253 </span>
<span class="lineno"> 254 </span><span class="error">abstract class OnServicesDiscoveredListener(uuid: UUID) : GattObserver(uuid) {</span>
<span class="lineno"> 255 </span><span class="error">    abstract fun onServicesDiscovered(gatt: BluetoothGatt, status: Int)</span>
<span class="lineno"> 256 </span><span class="error">}</span>
<span class="lineno"> 257 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:258:1</span><span class="message">The class `GotConnectedListener` is using inheritance, consider using composition instead.

Does `GotConnectedListener` want to expose the complete interface (`empty public interface`) of `GattObserver` such that `GotConnectedListener` can be used where `GattObserver` is expected? Indicates __inheritance__.

Does `GotConnectedListener` want only some/part of the behavior exposed by `GattObserver`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 255 </span>    abstract fun onServicesDiscovered(gatt: BluetoothGatt, status: Int)
<span class="lineno"> 256 </span>}
<span class="lineno"> 257 </span>
<span class="lineno"> 258 </span><span class="error">abstract class GotConnectedListener(uuid: UUID) : GattObserver(uuid) {</span>
<span class="lineno"> 259 </span><span class="error">    abstract fun isConnected()</span>
<span class="lineno"> 260 </span><span class="error">}</span>
<span class="lineno"> 261 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClient.kt:262:1</span><span class="message">The class `ConnectionStateChangedListener` is using inheritance, consider using composition instead.

Does `ConnectionStateChangedListener` want to expose the complete interface (`empty public interface`) of `GattObserver` such that `ConnectionStateChangedListener` can be used where `GattObserver` is expected? Indicates __inheritance__.

Does `ConnectionStateChangedListener` want only some/part of the behavior exposed by `GattObserver`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 259 </span>    abstract fun isConnected()
<span class="lineno"> 260 </span>}
<span class="lineno"> 261 </span>
<span class="lineno"> 262 </span><span class="error">abstract class ConnectionStateChangedListener(uuid: UUID) : GattObserver(uuid) {</span>
<span class="lineno"> 263 </span><span class="error">    abstract fun onConnectionStateChanged(status: Int, newState: Int)</span>
<span class="lineno"> 264 </span><span class="error">}</span>
<span class="lineno"> 265 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/GattClientImpl.kt:12:1</span><span class="message">The class `GattClientImpl` is using inheritance, consider using composition instead.

Does `GattClientImpl` want to expose the complete interface (`onServicesDiscovered, onMtuChanged, onDescriptorWrite, onDescriptorRead, onCharacteristicWrite, onCharacteristicRead, onConnectionStateChange, onCharacteristicChanged, getConnectionState, removeGattObserver, addGattObserver, close, disconnect, connect`) of `GattClient` such that `GattClientImpl` can be used where `GattClient` is expected? Indicates __inheritance__.

Does `GattClientImpl` want only some/part of the behavior exposed by `GattClient`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import android.os.Build
<span class="lineno">  10 </span>import java.util.UUID
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">internal open class GattClientImpl : GattClient() {</span>
<span class="lineno">  13 </span><span class="error"></span>
<span class="lineno">  14 </span><span class="error">    override fun writeCharacteristic(btChar: BluetoothGattCharacteristic): Boolean {</span>
<span class="lineno">  15 </span><span class="error">        return bluetoothGatt?.writeCharacteristic(btChar) ?: return false</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/LoggingGattClient.kt:13:1</span><span class="message">The class `LoggingGattClient` is using inheritance, consider using composition instead.

Does `LoggingGattClient` want to expose the complete interface (`getService, discoverServices, getServices, requestMtu, requestConnectionPriority, close, disconnect, connect, writeDescriptor, setCharacteristicNotification, readCharacteristic, writeCharacteristic`) of `GattClientImpl` such that `LoggingGattClient` can be used where `GattClientImpl` is expected? Indicates __inheritance__.

Does `LoggingGattClient` want only some/part of the behavior exposed by `GattClientImpl`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>
<span class="lineno">  11 </span>private val TAG: String = LoggingGattClient::class.java.simpleName
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">internal class LoggingGattClient(val serialNumber: String) : GattClientImpl() {</span>
<span class="lineno">  14 </span><span class="error"></span>
<span class="lineno">  15 </span><span class="error">    private fun makeLogMessage(</span>
<span class="lineno">  16 </span><span class="error">        event: String,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/operations/WriteDescriptor.kt:16:1</span><span class="message">The class `SetCharacteristicNotification` is using inheritance, consider using composition instead.

Does `SetCharacteristicNotification` want to expose the complete interface (`invoke`) of `WriteDescriptor` such that `SetCharacteristicNotification` can be used where `WriteDescriptor` is expected? Indicates __inheritance__.

Does `SetCharacteristicNotification` want only some/part of the behavior exposed by `WriteDescriptor`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  13 </span>import java.util.concurrent.Semaphore
<span class="lineno">  14 </span>import java.util.concurrent.TimeUnit
<span class="lineno">  15 </span>
<span class="lineno">  16 </span><span class="error">internal class SetCharacteristicNotification(gattClient: GattClient) : WriteDescriptor(gattClient) {</span>
<span class="lineno">  17 </span><span class="error">    override fun invoke(characteristic: BluetoothGattCharacteristic, enable: Boolean): Try&lt;Unit&gt; {</span>
<span class="lineno">  18 </span><span class="error">        if (!gattClient.setCharacteristicNotification(</span>
<span class="lineno">  19 </span><span class="error">                characteristic,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/gatt/operations/WriteDescriptor.kt:41:1</span><span class="message">The class `SetCharacteristicIndication` is using inheritance, consider using composition instead.

Does `SetCharacteristicIndication` want to expose the complete interface (`invoke`) of `WriteDescriptor` such that `SetCharacteristicIndication` can be used where `WriteDescriptor` is expected? Indicates __inheritance__.

Does `SetCharacteristicIndication` want only some/part of the behavior exposed by `WriteDescriptor`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  38 </span>    }
<span class="lineno">  39 </span>}
<span class="lineno">  40 </span>
<span class="lineno">  41 </span><span class="error">internal class SetCharacteristicIndication(gattClient: GattClient) : WriteDescriptor(gattClient) {</span>
<span class="lineno">  42 </span><span class="error">    override fun invoke(characteristic: BluetoothGattCharacteristic, enable: Boolean): Try&lt;Unit&gt; {</span>
<span class="lineno">  43 </span><span class="error">        if (!gattClient.setCharacteristicNotification(characteristic, enable)) {</span>
<span class="lineno">  44 </span><span class="error">            return Failure(IOException(&quot;Failed to set characteristic notification.&quot;))</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/hub/HubInstrument.kt:11:1</span><span class="message">The class `HubInstrument` is using inheritance, consider using composition instead.

Does `HubInstrument` want to expose the complete interface (`setDisconnectListener, getDisconnectListener, disconnected, disconnect, isConfiguredForPairing, isConnected, connect`) of `Instrument` such that `HubInstrument` can be used where `Instrument` is expected? Indicates __inheritance__.

Does `HubInstrument` want only some/part of the behavior exposed by `Instrument`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.utilities.Failure
<span class="lineno">   9 </span>import com.airthings.utilities.Try
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class HubInstrument(</span>
<span class="lineno">  12 </span><span class="error">    override val context: Context,</span>
<span class="lineno">  13 </span><span class="error">    override val serialNumber: Long,</span>
<span class="lineno">  14 </span><span class="error">    override val scanResult: ScanResult</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/hub/HubScanResultData.kt:6:1</span><span class="message">The class `HubScanResultData` is using inheritance, consider using composition instead.

Does `HubScanResultData` want to expose the complete interface (`empty public interface`) of `ScanResultData` such that `HubScanResultData` can be used where `ScanResultData` is expected? Indicates __inheritance__.

Does `HubScanResultData` want only some/part of the behavior exposed by `ScanResultData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   3 </span>import android.bluetooth.le.ScanResult
<span class="lineno">   4 </span>import com.airthings.instrumentapi.instrument.ScanResultData
<span class="lineno">   5 </span>
<span class="lineno">   6 </span><span class="error">internal class HubScanResultData(scanResult: ScanResult) : ScanResultData(scanResult) {</span>
<span class="lineno">   7 </span><span class="error">    override val isHubConnected: Boolean = false</span>
<span class="lineno">   8 </span><span class="error">}</span>
<span class="lineno">   9 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveCommProtocol.kt:34:1</span><span class="message">The class `WaveCommProtocol` is using inheritance, consider using composition instead.

Does `WaveCommProtocol` want to expose the complete interface (`disconnect, writeRfRegion, readRfRegion, readDeviceClock, setColorRing, sendUiCommand, startNewMeasurement, readBaseTime, readSensorRecords, readFwVersions, writeUiSettings, readUiSettings, readCurrentValues`) of `AtCommProtocol2` such that `WaveCommProtocol` can be used where `AtCommProtocol2` is expected? Indicates __inheritance__.

Does `WaveCommProtocol` want only some/part of the behavior exposed by `AtCommProtocol2`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  31 </span>import java.util.Date
<span class="lineno">  32 </span>import java.util.HashMap
<span class="lineno">  33 </span>
<span class="lineno">  34 </span><span class="error">internal class WaveCommProtocol(</span>
<span class="lineno">  35 </span><span class="error">    gattProfile: AtGattProfile,</span>
<span class="lineno">  36 </span><span class="error">    gattClient: GattClient,</span>
<span class="lineno">  37 </span><span class="error">    onDisconnectListener: OnDisconnectListener</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveInstrument.kt:22:1</span><span class="message">The class `WaveInstrument` is using inheritance, consider using composition instead.

Does `WaveInstrument` want to expose the complete interface (`setDisconnectListener, getDisconnectListener, disconnected, disconnect, isConfiguredForPairing, isConnected, connect`) of `Instrument` such that `WaveInstrument` can be used where `Instrument` is expected? Indicates __inheritance__.

Does `WaveInstrument` want only some/part of the behavior exposed by `Instrument`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  19 </span>import com.airthings.utilities.Success
<span class="lineno">  20 </span>import com.airthings.utilities.Try
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">internal class WaveInstrument(</span>
<span class="lineno">  23 </span><span class="error">    override val context: Context,</span>
<span class="lineno">  24 </span><span class="error">    override val serialNumber: Long,</span>
<span class="lineno">  25 </span><span class="error">    override val scanResult: ScanResult</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave/WaveScanResultData.kt:15:1</span><span class="message">The class `WaveScanResultData` is using inheritance, consider using composition instead.

Does `WaveScanResultData` want to expose the complete interface (`empty public interface`) of `ScanResultData` such that `WaveScanResultData` can be used where `ScanResultData` is expected? Indicates __inheritance__.

Does `WaveScanResultData` want only some/part of the behavior exposed by `ScanResultData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>import com.airthings.instrumentapi.util.InstrumentDefines.INST_FLAG_WAIT_SET
<span class="lineno">  13 </span>import com.airthings.instrumentapi.util.InstrumentDefines.INST_FLAG_WAVE_DISABLED
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">internal class WaveScanResultData(scanResult: ScanResult) : ScanResultData(scanResult) {</span>
<span class="lineno">  16 </span><span class="error">    private val manufacturerData = getManufacturerData(scanResult)</span>
<span class="lineno">  17 </span><span class="error">    val flags: Flags?</span>
<span class="lineno">  18 </span><span class="error">        get() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave2/Wave2CommProtocol.kt:21:1</span><span class="message">The class `Wave2CommProtocol` is using inheritance, consider using composition instead.

Does `Wave2CommProtocol` want to expose the complete interface (`writeRfRegion, readRfRegion, readDeviceClock, setColorRing, sendUiCommand, startNewMeasurement, readBaseTime, readSensorRecords, readFwVersions, writeUiSettings, readUiSettings, readCurrentValues`) of `WavePlusCommProtocol` such that `Wave2CommProtocol` can be used where `WavePlusCommProtocol` is expected? Indicates __inheritance__.

Does `Wave2CommProtocol` want only some/part of the behavior exposed by `WavePlusCommProtocol`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  18 </span>import java.util.Date
<span class="lineno">  19 </span>import java.util.HashMap
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">internal class Wave2CommProtocol(</span>
<span class="lineno">  22 </span><span class="error">    gattProfile: AtGattProfile,</span>
<span class="lineno">  23 </span><span class="error">    gattClient: GattClient,</span>
<span class="lineno">  24 </span><span class="error">    onDisconnectListener: OnDisconnectListener,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave2/Wave2CurrentValueParser.kt:11:1</span><span class="message">The class `Wave2CurrentValueParser` is using inheritance, consider using composition instead.

Does `Wave2CurrentValueParser` want to expose the complete interface (`parseWaveCount, parseOrientation, parseLightLevel, parseHumidity, parseVOC, parseCO2, parseAtmPressure, parseTemperatureCelsius, parseLongTermRadon, parseShortTermRadon, parseCurrentValuesIntoValueMap`) of `CurrentValuesParser` such that `Wave2CurrentValueParser` can be used where `CurrentValuesParser` is expected? Indicates __inheritance__.

Does `Wave2CurrentValueParser` want only some/part of the behavior exposed by `CurrentValuesParser`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import java.io.IOException
<span class="lineno">   9 </span>import java.util.HashMap
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class Wave2CurrentValueParser : CurrentValuesParser() {</span>
<span class="lineno">  12 </span><span class="error">    override fun parseCurrentValuesIntoValueMap(currValByteArray: ByteArray): Try&lt;HashMap&lt;RecordType, Float?&gt;&gt; {</span>
<span class="lineno">  13 </span><span class="error">        if (currValByteArray.size &lt; 20) {</span>
<span class="lineno">  14 </span><span class="error">            return Failure(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wave2/Wave2Instrument.kt:27:1</span><span class="message">The class `Wave2Instrument` is using inheritance, consider using composition instead.

Does `Wave2Instrument` want to expose the complete interface (`setDisconnectListener, getDisconnectListener, disconnected, disconnect, isConfiguredForPairing, isConnected, connect`) of `Instrument` such that `Wave2Instrument` can be used where `Instrument` is expected? Indicates __inheritance__.

Does `Wave2Instrument` want only some/part of the behavior exposed by `Instrument`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  24 </span>import com.airthings.utilities.Success
<span class="lineno">  25 </span>import com.airthings.utilities.Try
<span class="lineno">  26 </span>
<span class="lineno">  27 </span><span class="error">internal class Wave2Instrument(</span>
<span class="lineno">  28 </span><span class="error">    override val context: Context,</span>
<span class="lineno">  29 </span><span class="error">    override val serialNumber: Long,</span>
<span class="lineno">  30 </span><span class="error">    override val scanResult: ScanResult</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/MerlinSelfCheckSummary.kt:10:1</span><span class="message">The class `MerlinSelfCheckSummary` is using inheritance, consider using composition instead.

Does `MerlinSelfCheckSummary` want to expose the complete interface (`empty public interface`) of `SelfCheckSummary` such that `MerlinSelfCheckSummary` can be used where `SelfCheckSummary` is expected? Indicates __inheritance__.

Does `MerlinSelfCheckSummary` want only some/part of the behavior exposed by `SelfCheckSummary`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import com.airthings.utilities.Success
<span class="lineno">   8 </span>import com.airthings.utilities.Try
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">internal class MerlinSelfCheckSummary(</span>
<span class="lineno">  11 </span><span class="error">    uptime: Long,</span>
<span class="lineno">  12 </span><span class="error">    deviceType: InstrumentType,</span>
<span class="lineno">  13 </span><span class="error">    fwVersion: String,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniCommProtocol.kt:23:1</span><span class="message">The class `WaveMiniCommProtocol` is using inheritance, consider using composition instead.

Does `WaveMiniCommProtocol` want to expose the complete interface (`disconnect, writeRfRegion, readRfRegion, readDeviceClock, setColorRing, sendUiCommand, startNewMeasurement, readBaseTime, readSensorRecords, readFwVersions, writeUiSettings, readUiSettings, readCurrentValues`) of `AtCommProtocol2` such that `WaveMiniCommProtocol` can be used where `AtCommProtocol2` is expected? Indicates __inheritance__.

Does `WaveMiniCommProtocol` want only some/part of the behavior exposed by `AtCommProtocol2`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  20 </span>import java.util.Date
<span class="lineno">  21 </span>import java.util.HashMap
<span class="lineno">  22 </span>
<span class="lineno">  23 </span><span class="error">@Suppress(&quot;TooManyFunctions&quot;)</span>
<span class="lineno">  24 </span><span class="error">internal class WaveMiniCommProtocol(</span>
<span class="lineno">  25 </span><span class="error">    waveMiniGattProfile: AtGattProfile,</span>
<span class="lineno">  26 </span><span class="error">    gattClient: GattClient,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniGattProfile.kt:13:1</span><span class="message">The class `WaveMiniGattProfile` is using inheritance, consider using composition instead.

Does `WaveMiniGattProfile` want to expose the complete interface (`empty public interface`) of `AtGattProfile` such that `WaveMiniGattProfile` can be used where `AtGattProfile` is expected? Indicates __inheritance__.

Does `WaveMiniGattProfile` want only some/part of the behavior exposed by `AtGattProfile`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import com.airthings.utilities.Try
<span class="lineno">  11 </span>import java.util.UUID
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">internal class WaveMiniGattProfile(val gattClient: GattClient) : AtGattProfile() {</span>
<span class="lineno">  14 </span><span class="error">    override val airSensorServiceUUID: UUID = UUID.fromString(DeviceDefines.WaveMiniServiceUUID)</span>
<span class="lineno">  15 </span><span class="error">    override val asracpCharUUID: UUID = UUID.fromString(&quot;b42e3ef4-ade7-11e4-89d3-123b93f75cba&quot;)</span>
<span class="lineno">  16 </span><span class="error">    override val asrCharUUID: UUID = UUID.fromString(&quot;b42e41c4-ade7-11e4-89d3-123b93f75cba&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniInstrument.kt:24:1</span><span class="message">The class `WaveMiniInstrument` is using inheritance, consider using composition instead.

Does `WaveMiniInstrument` want to expose the complete interface (`setDisconnectListener, getDisconnectListener, disconnected, disconnect, isConfiguredForPairing, isConnected, connect`) of `Instrument` such that `WaveMiniInstrument` can be used where `Instrument` is expected? Indicates __inheritance__.

Does `WaveMiniInstrument` want only some/part of the behavior exposed by `Instrument`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  21 </span>import com.airthings.utilities.Success
<span class="lineno">  22 </span>import com.airthings.utilities.Try
<span class="lineno">  23 </span>
<span class="lineno">  24 </span><span class="error">internal class WaveMiniInstrument(</span>
<span class="lineno">  25 </span><span class="error">    override val context: Context,</span>
<span class="lineno">  26 </span><span class="error">    override val serialNumber: Long,</span>
<span class="lineno">  27 </span><span class="error">    override val scanResult: ScanResult</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/wavemini/WaveMiniInstrument.kt:49:1</span><span class="message">The class `WaveMiniScanResultData` is using inheritance, consider using composition instead.

Does `WaveMiniScanResultData` want to expose the complete interface (`empty public interface`) of `ScanResultData` such that `WaveMiniScanResultData` can be used where `ScanResultData` is expected? Indicates __inheritance__.

Does `WaveMiniScanResultData` want only some/part of the behavior exposed by `ScanResultData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  46 </span>    override fun isConfiguredForPairing() = true
<span class="lineno">  47 </span>}
<span class="lineno">  48 </span>
<span class="lineno">  49 </span><span class="error">// Documentation: https://airthings.atlassian.net/wiki/spaces/FW/pages/446660832/Merlin+Platform+BLE+Specifications</span>
<span class="lineno">  50 </span><span class="error">internal class WaveMiniScanResultData(scanResult: ScanResult) : ScanResultData(scanResult) {</span>
<span class="lineno">  51 </span><span class="error"></span>
<span class="lineno">  52 </span><span class="error">    override val isHubConnected: Boolean = getIsHubConnected(scanResult)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/CommandFactory.kt:10:1</span><span class="message">The class `ReadInstrumentClockCmdFactory` is using inheritance, consider using composition instead.

Does `ReadInstrumentClockCmdFactory` want to expose the complete interface (`getCommand`) of `CmdFactory` such that `ReadInstrumentClockCmdFactory` can be used where `CmdFactory` is expected? Indicates __inheritance__.

Does `ReadInstrumentClockCmdFactory` want only some/part of the behavior exposed by `CmdFactory`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import com.airthings.utilities.Success
<span class="lineno">   8 </span>import com.airthings.utilities.Try
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">/**</span>
<span class="lineno">  11 </span><span class="error"> * Ref. https://airthings.atlassian.net/wiki/spaces/FW/pages/683376641</span>
<span class="lineno">  12 </span><span class="error"> */</span>
<span class="lineno">  13 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/CommandFactory.kt:33:1</span><span class="message">The class `SetInstrumentClockCmdFactory` is using inheritance, consider using composition instead.

Does `SetInstrumentClockCmdFactory` want to expose the complete interface (`getCommand`) of `CmdFactory` such that `SetInstrumentClockCmdFactory` can be used where `CmdFactory` is expected? Indicates __inheritance__.

Does `SetInstrumentClockCmdFactory` want only some/part of the behavior exposed by `CmdFactory`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  30 </span>    }
<span class="lineno">  31 </span>}
<span class="lineno">  32 </span>
<span class="lineno">  33 </span><span class="error">internal class SetInstrumentClockCmdFactory : CmdFactory&lt;SetInstrumentClockCmdFactory.Request&gt;() {</span>
<span class="lineno">  34 </span><span class="error"></span>
<span class="lineno">  35 </span><span class="error">    @Suppress(&quot;ReturnCount&quot;)</span>
<span class="lineno">  36 </span><span class="error">    override fun getCommand(fwVersions: HashMap&lt;FirmwareImageType, String&gt;, request: Request): Try&lt;ByteArray&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/CommandFactory.kt:73:1</span><span class="message">The class `GetDatasetInfoCmdFactory` is using inheritance, consider using composition instead.

Does `GetDatasetInfoCmdFactory` want to expose the complete interface (`getCommand`) of `CmdFactory` such that `GetDatasetInfoCmdFactory` can be used where `CmdFactory` is expected? Indicates __inheritance__.

Does `GetDatasetInfoCmdFactory` want only some/part of the behavior exposed by `CmdFactory`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  70 </span>    data class Request(val timeToSetSeconds: Long)
<span class="lineno">  71 </span>}
<span class="lineno">  72 </span>
<span class="lineno">  73 </span><span class="error">internal class GetDatasetInfoCmdFactory : CmdFactory&lt;GetDatasetInfoCmdFactory.Request&gt;() {</span>
<span class="lineno">  74 </span><span class="error"></span>
<span class="lineno">  75 </span><span class="error">    @Suppress(&quot;ReturnCount&quot;)</span>
<span class="lineno">  76 </span><span class="error">    override fun getCommand(fwVersions: HashMap&lt;FirmwareImageType, String&gt;, request: Request): Try&lt;ByteArray&gt; {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/GriffinScanResultData.kt:8:1</span><span class="message">The class `GriffinScanResultData` is using inheritance, consider using composition instead.

Does `GriffinScanResultData` want to expose the complete interface (`empty public interface`) of `ScanResultData` such that `GriffinScanResultData` can be used where `ScanResultData` is expected? Indicates __inheritance__.

Does `GriffinScanResultData` want only some/part of the behavior exposed by `ScanResultData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   5 </span>import com.airthings.instrumentapi.util.InstrumentDefines
<span class="lineno">   6 </span>import com.airthings.instrumentapi.util.buildUInt16
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">/**</span>
<span class="lineno">   9 </span><span class="error"> * Documentation:</span>
<span class="lineno">  10 </span><span class="error"> * https://airthings.atlassian.net/wiki/spaces/FW/pages/683376641/Griffin+Bluetooth+interface+specification#GriffinBluetoothinterfacespecification-Advertisements</span>
<span class="lineno">  11 </span><span class="error"> */</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/ReadSensorSampleSequence.kt:297:1</span><span class="message">The class `AnalyticsReadSensorSamplesSequence` is using inheritance, consider using composition instead.

Does `AnalyticsReadSensorSamplesSequence` want to expose the complete interface (`invoke`) of `ReadSensorSampleSequence` such that `AnalyticsReadSensorSamplesSequence` can be used where `ReadSensorSampleSequence` is expected? Indicates __inheritance__.

Does `AnalyticsReadSensorSamplesSequence` want only some/part of the behavior exposed by `ReadSensorSampleSequence`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 294 </span>    return &quot;${this.map { it.toString() }}&quot;
<span class="lineno"> 295 </span>}
<span class="lineno"> 296 </span>
<span class="lineno"> 297 </span><span class="error">internal class AnalyticsReadSensorSamplesSequence(</span>
<span class="lineno"> 298 </span><span class="error">    gattClient: GattClient,</span>
<span class="lineno"> 299 </span><span class="error">    gattProfile: AtGattProfile,</span>
<span class="lineno"> 300 </span><span class="error">    fwVersions: HashMap&lt;FirmwareImageType, String&gt;,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/VersionComparator.kt:71:5</span><span class="message">The class `SemanticVersion` is using inheritance, consider using composition instead.

Does `SemanticVersion` want to expose the complete interface (`isBefore`) of `Version` such that `SemanticVersion` can be used where `Version` is expected? Indicates __inheritance__.

Does `SemanticVersion` want only some/part of the behavior exposed by `Version`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  68 </span>        abstract fun isBefore(version: Version): Boolean
<span class="lineno">  69 </span>    }
<span class="lineno">  70 </span>
<span class="lineno">  71 </span>    <span class="error">private class SemanticVersion(versionString: String?) : Version() {</span>
<span class="lineno">  72 </span><span class="error"></span>
<span class="lineno">  73 </span><span class="error">        val versionNumbers: List&lt;Int&gt; = versionString?.split(&quot;.&quot;)?.map { it.toInt() } ?: throw NullPointerException()</span>
<span class="lineno">  74 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/VersionComparator.kt:94:5</span><span class="message">The class `DateVersion` is using inheritance, consider using composition instead.

Does `DateVersion` want to expose the complete interface (`isBefore`) of `Version` such that `DateVersion` can be used where `Version` is expected? Indicates __inheritance__.

Does `DateVersion` want only some/part of the behavior exposed by `Version`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  91 </span>        }
<span class="lineno">  92 </span>    }
<span class="lineno">  93 </span>
<span class="lineno">  94 </span>    <span class="error">private class DateVersion(versionString: String) : Version() {</span>
<span class="lineno">  95 </span><span class="error">        @SuppressLint(&quot;SimpleDateFormat&quot;)</span>
<span class="lineno">  96 </span><span class="error">        private val simpleDateFormat = SimpleDateFormat(dateFormat)</span>
<span class="lineno">  97 </span><span class="error">        val versionDate: Date? = simpleDateFormat.parse(versionString)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/WavePlusCommProtocol.kt:34:1</span><span class="message">The class `WavePlusCommProtocol` is using inheritance, consider using composition instead.

Does `WavePlusCommProtocol` want to expose the complete interface (`disconnect, writeRfRegion, readRfRegion, readDeviceClock, setColorRing, sendUiCommand, startNewMeasurement, readBaseTime, readSensorRecords, readFwVersions, writeUiSettings, readUiSettings, readCurrentValues`) of `AtCommProtocol2` such that `WavePlusCommProtocol` can be used where `AtCommProtocol2` is expected? Indicates __inheritance__.

Does `WavePlusCommProtocol` want only some/part of the behavior exposed by `AtCommProtocol2`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  31 </span>import java.util.Date
<span class="lineno">  32 </span>import java.util.HashMap
<span class="lineno">  33 </span>
<span class="lineno">  34 </span><span class="error">@Suppress(&quot;TooManyFunctions&quot;)</span>
<span class="lineno">  35 </span><span class="error">internal open class WavePlusCommProtocol(</span>
<span class="lineno">  36 </span><span class="error">    gattProfile: AtGattProfile,</span>
<span class="lineno">  37 </span><span class="error">    gattClient: GattClient,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/WavePlusInstrument.kt:26:1</span><span class="message">The class `WavePlusInstrument` is using inheritance, consider using composition instead.

Does `WavePlusInstrument` want to expose the complete interface (`setDisconnectListener, getDisconnectListener, disconnected, disconnect, isConfiguredForPairing, isConnected, connect`) of `Instrument` such that `WavePlusInstrument` can be used where `Instrument` is expected? Indicates __inheritance__.

Does `WavePlusInstrument` want only some/part of the behavior exposed by `Instrument`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  23 </span>import com.airthings.utilities.Success
<span class="lineno">  24 </span>import com.airthings.utilities.Try
<span class="lineno">  25 </span>
<span class="lineno">  26 </span><span class="error">internal class WavePlusInstrument(</span>
<span class="lineno">  27 </span><span class="error">    override val context: Context,</span>
<span class="lineno">  28 </span><span class="error">    override val serialNumber: Long,</span>
<span class="lineno">  29 </span><span class="error">    override val scanResult: ScanResult</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/ReadRFRegionCommandFactory.kt:11:1</span><span class="message">The class `ReadRFRegionCommandFactory` is using inheritance, consider using composition instead.

Does `ReadRFRegionCommandFactory` want to expose the complete interface (`getCommand`) of `CmdFactory` such that `ReadRFRegionCommandFactory` can be used where `CmdFactory` is expected? Indicates __inheritance__.

Does `ReadRFRegionCommandFactory` want only some/part of the behavior exposed by `CmdFactory`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.utilities.Success
<span class="lineno">   9 </span>import com.airthings.utilities.Try
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class ReadRFRegionCommandFactory : CmdFactory&lt;Any?&gt;() {</span>
<span class="lineno">  12 </span><span class="error">    companion object {</span>
<span class="lineno">  13 </span><span class="error">        private val PASSTHROUGH_COMMAND = byteArrayOf(</span>
<span class="lineno">  14 </span><span class="error">            PassThrough.FLAG.code,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/ReadRfRegionCommand.kt:12:1</span><span class="message">The class `ReadRfRegionCommand` is using inheritance, consider using composition instead.

Does `ReadRfRegionCommand` want to expose the complete interface (`empty public interface`) of `RfRegionCommand` such that `ReadRfRegionCommand` can be used where `RfRegionCommand` is expected? Indicates __inheritance__.

Does `ReadRfRegionCommand` want only some/part of the behavior exposed by `RfRegionCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.utilities.Success
<span class="lineno">  10 </span>import com.airthings.utilities.Try
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">internal class ReadRfRegionCommand(</span>
<span class="lineno">  13 </span><span class="error">    private val asracp: ASRACP,</span>
<span class="lineno">  14 </span><span class="error">    private val firmwareVersions: HashMap&lt;FirmwareImageType, String&gt;</span>
<span class="lineno">  15 </span><span class="error">) : RfRegionCommand() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/RfRegionResponseParser.kt:13:1</span><span class="message">The class `RfRegionResponseParser` is using inheritance, consider using composition instead.

Does `RfRegionResponseParser` want to expose the complete interface (`parseResponse`) of `ParserFactory` such that `RfRegionResponseParser` can be used where `ParserFactory` is expected? Indicates __inheritance__.

Does `RfRegionResponseParser` want only some/part of the behavior exposed by `ParserFactory`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import com.airthings.utilities.Try
<span class="lineno">  11 </span>import java.io.IOException
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">internal class RfRegionResponseParser : ParserFactory&lt;Region&gt;() {</span>
<span class="lineno">  14 </span><span class="error"></span>
<span class="lineno">  15 </span><span class="error">    override fun parseResponse(fwVersions: Map&lt;FirmwareImageType, String&gt;, rawResponse: ByteArray): Try&lt;Region&gt; {</span>
<span class="lineno">  16 </span><span class="error">        val ccFwVersion = fwVersions[FirmwareImageType.BLE] ?: error(&quot;Image type BLE was null.&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/WriteRFRegionCommandFactory.kt:14:1</span><span class="message">The class `WriteRFRegionCommandFactory` is using inheritance, consider using composition instead.

Does `WriteRFRegionCommandFactory` want to expose the complete interface (`getCommand`) of `CmdFactory` such that `WriteRFRegionCommandFactory` can be used where `CmdFactory` is expected? Indicates __inheritance__.

Does `WriteRFRegionCommandFactory` want only some/part of the behavior exposed by `CmdFactory`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.utilities.Success
<span class="lineno">  12 </span>import com.airthings.utilities.Try
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">internal class WriteRFRegionCommandFactory : CmdFactory&lt;Region&gt;() {</span>
<span class="lineno">  15 </span><span class="error"></span>
<span class="lineno">  16 </span><span class="error">    override fun getCommand(fwVersions: HashMap&lt;FirmwareImageType, String&gt;, request: Region): Try&lt;ByteArray&gt; {</span>
<span class="lineno">  17 </span><span class="error">        return when (val passThroughNeeded = requiresPassThrough(</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/WriteRfRegionCommand.kt:12:1</span><span class="message">The class `WriteRfRegionCommand` is using inheritance, consider using composition instead.

Does `WriteRfRegionCommand` want to expose the complete interface (`empty public interface`) of `RfRegionCommand` such that `WriteRfRegionCommand` can be used where `RfRegionCommand` is expected? Indicates __inheritance__.

Does `WriteRfRegionCommand` want only some/part of the behavior exposed by `RfRegionCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.utilities.Success
<span class="lineno">  10 </span>import com.airthings.utilities.Try
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">internal class WriteRfRegionCommand(</span>
<span class="lineno">  13 </span><span class="error">    private val asracp: ASRACP,</span>
<span class="lineno">  14 </span><span class="error">    private val firmwareVersions: HashMap&lt;FirmwareImageType, String&gt;</span>
<span class="lineno">  15 </span><span class="error">) : RfRegionCommand() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrument/waveplus/rfregion/WriteRfRegionResponseParser.kt:11:1</span><span class="message">The class `WriteRfRegionResponseParser` is using inheritance, consider using composition instead.

Does `WriteRfRegionResponseParser` want to expose the complete interface (`parseResponse`) of `ParserFactory` such that `WriteRfRegionResponseParser` can be used where `ParserFactory` is expected? Indicates __inheritance__.

Does `WriteRfRegionResponseParser` want only some/part of the behavior exposed by `ParserFactory`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.utilities.Try
<span class="lineno">   9 </span>import java.io.IOException
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class WriteRfRegionResponseParser : ParserFactory&lt;Region&gt;() {</span>
<span class="lineno">  12 </span><span class="error"></span>
<span class="lineno">  13 </span><span class="error">    override fun parseResponse(fwVersions: Map&lt;FirmwareImageType, String&gt;, rawResponse: ByteArray): Try&lt;Region&gt; {</span>
<span class="lineno">  14 </span><span class="error">        val ccFwVersion = fwVersions[FirmwareImageType.BLE] ?: error(&quot;Image type BLE was null.&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/BreatheColorRing.kt:14:1</span><span class="message">The class `BreatheColorRing` is using inheritance, consider using composition instead.

Does `BreatheColorRing` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `BreatheColorRing` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `BreatheColorRing` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  11 </span>import com.airthings.utilities.Failure
<span class="lineno">  12 </span>import com.airthings.utilities.Success
<span class="lineno">  13 </span>
<span class="lineno">  14 </span><span class="error">class BreatheColorRing(</span>
<span class="lineno">  15 </span><span class="error">    context: Context,</span>
<span class="lineno">  16 </span><span class="error">    val serialNumber: String,</span>
<span class="lineno">  17 </span><span class="error">    val color: Color,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/ConnectionCommand.kt:10:1</span><span class="message">The class `ConnectionCommand` is using inheritance, consider using composition instead.

Does `ConnectionCommand` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `ConnectionCommand` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `ConnectionCommand` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import com.airthings.utilities.Log
<span class="lineno">   8 </span>import java.io.IOException
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">class ConnectionCommand(</span>
<span class="lineno">  11 </span><span class="error">    context: Context,</span>
<span class="lineno">  12 </span><span class="error">    private val serialNumber: String,</span>
<span class="lineno">  13 </span><span class="error">    private val connectionListener: ConnectionListener</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/ConvertSpinningBlueRingToSolid.kt:9:1</span><span class="message">The class `ConvertSpinningBlueRingToSolid` is using inheritance, consider using composition instead.

Does `ConvertSpinningBlueRingToSolid` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `ConvertSpinningBlueRingToSolid` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `ConvertSpinningBlueRingToSolid` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>import com.airthings.utilities.Failure
<span class="lineno">   7 </span>import com.airthings.utilities.Log
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">class ConvertSpinningBlueRingToSolid(context: Context, val serialNumber: String) : InstrumentCommand(context) {</span>
<span class="lineno">  10 </span><span class="error"></span>
<span class="lineno">  11 </span><span class="error">    override fun run() {</span>
<span class="lineno">  12 </span><span class="error">        super.run()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/DisconnectCommand.kt:5:1</span><span class="message">The class `DisconnectCommand` is using inheritance, consider using composition instead.

Does `DisconnectCommand` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `DisconnectCommand` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `DisconnectCommand` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   2 </span>
<span class="lineno">   3 </span>import android.content.Context
<span class="lineno">   4 </span>
<span class="lineno">   5 </span><span class="error">class DisconnectCommand(context: Context, val serialNumber: String, private val disconnectCB: DisconnectCB) :</span>
<span class="lineno">   6 </span><span class="error">    InstrumentCommand(context) {</span>
<span class="lineno">   7 </span><span class="error">    override fun run() {</span>
<span class="lineno">   8 </span><span class="error">        super.run()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/FwUpgradeCommand.kt:9:1</span><span class="message">The class `FwUpgradeCommand` is using inheritance, consider using composition instead.

Does `FwUpgradeCommand` want to expose the complete interface (`runAsFailure, completed, progressUpdate, aborted, started, disconnect, run`) of `WavePlusFwUpgrade2` such that `FwUpgradeCommand` can be used where `WavePlusFwUpgrade2` is expected? Indicates __inheritance__.

Does `FwUpgradeCommand` want only some/part of the behavior exposed by `WavePlusFwUpgrade2`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>import com.airthings.instrumentapi.instrument.waveplus.oad.OadProgressCB
<span class="lineno">   7 </span>import com.airthings.instrumentapi.instrumentops.uisettings.UISettings
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">@Suppress(&quot;DEPRECATION&quot;)</span>
<span class="lineno">  10 </span><span class="error">class FwUpgradeCommand(</span>
<span class="lineno">  11 </span><span class="error">    context: Context,</span>
<span class="lineno">  12 </span><span class="error">    serialNumber: String,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/MspFwUpdate.kt:21:1</span><span class="message">The class `MspFwUpdate` is using inheritance, consider using composition instead.

Does `MspFwUpdate` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `MspFwUpdate` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `MspFwUpdate` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  18 </span>import java.util.concurrent.Semaphore
<span class="lineno">  19 </span>import java.util.concurrent.TimeUnit
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">class MspFwUpdate(</span>
<span class="lineno">  22 </span><span class="error">    context: Context,</span>
<span class="lineno">  23 </span><span class="error">    val serialNumber: String,</span>
<span class="lineno">  24 </span><span class="error">    private val validatedFwImageData: MspFwImageData,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/ReadBaseTime.kt:8:1</span><span class="message">The class `ReadBaseTime` is using inheritance, consider using composition instead.

Does `ReadBaseTime` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `ReadBaseTime` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `ReadBaseTime` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   5 </span>import com.airthings.utilities.Success
<span class="lineno">   6 </span>import java.util.Date
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">class ReadBaseTime(context: Context, private val serialNumber: String, private val callback: BaseTimeCB) : InstrumentCommand(context) {</span>
<span class="lineno">   9 </span><span class="error">    override fun run() {</span>
<span class="lineno">  10 </span><span class="error">        super.run()</span>
<span class="lineno">  11 </span><span class="error">        val instrument = deviceHolder.getInstrument(serialNumber)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/ReadCurrentValues.kt:11:1</span><span class="message">The class `ReadCurrentValues` is using inheritance, consider using composition instead.

Does `ReadCurrentValues` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `ReadCurrentValues` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `ReadCurrentValues` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import java.util.Calendar
<span class="lineno">   9 </span>import java.util.HashMap
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">class ReadCurrentValues(context: Context, val serialNumber: String, private val callback: ReadCurrentValuesCB) :</span>
<span class="lineno">  12 </span><span class="error">    InstrumentCommand(context) {</span>
<span class="lineno">  13 </span><span class="error">    override fun run() {</span>
<span class="lineno">  14 </span><span class="error">        super.run()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/ReadFwVersions.kt:11:1</span><span class="message">The class `ReadFwVersions` is using inheritance, consider using composition instead.

Does `ReadFwVersions` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `ReadFwVersions` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `ReadFwVersions` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import com.airthings.utilities.Log
<span class="lineno">   9 </span>import com.airthings.utilities.Success
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">class ReadFwVersions(</span>
<span class="lineno">  12 </span><span class="error">    context: Context,</span>
<span class="lineno">  13 </span><span class="error">    val serialNumber: String,</span>
<span class="lineno">  14 </span><span class="error">    private val readFwVersionsCB: ReadFwVersionsCB</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/ReadInstrumentClock.kt:9:1</span><span class="message">The class `ReadInstrumentClock` is using inheritance, consider using composition instead.

Does `ReadInstrumentClock` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `ReadInstrumentClock` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `ReadInstrumentClock` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>import com.airthings.utilities.Log
<span class="lineno">   7 </span>import com.airthings.utilities.Success
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">class ReadInstrumentClock(context: Context, val serialNumber: String, private val callback: Callback) :</span>
<span class="lineno">  10 </span><span class="error">    InstrumentCommand(context) {</span>
<span class="lineno">  11 </span><span class="error"></span>
<span class="lineno">  12 </span><span class="error">    override fun run() {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/ReadRfRegion.kt:8:1</span><span class="message">The class `ReadRfRegion` is using inheritance, consider using composition instead.

Does `ReadRfRegion` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `ReadRfRegion` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `ReadRfRegion` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   5 </span>import com.airthings.utilities.Failure
<span class="lineno">   6 </span>import com.airthings.utilities.Try
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">class ReadRfRegion(</span>
<span class="lineno">   9 </span><span class="error">    context: Context,</span>
<span class="lineno">  10 </span><span class="error">    val serial: String,</span>
<span class="lineno">  11 </span><span class="error">    private val fn: WriteRegionCallback</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/SendUICommand.kt:13:1</span><span class="message">The class `SendUICommand` is using inheritance, consider using composition instead.

Does `SendUICommand` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `SendUICommand` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `SendUICommand` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import java.io.IOException
<span class="lineno">  11 </span>import java.lang.IllegalArgumentException
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class SendUICommand(</span>
<span class="lineno">  14 </span><span class="error">    context: Context,</span>
<span class="lineno">  15 </span><span class="error">    val serialNumber: String,</span>
<span class="lineno">  16 </span><span class="error">    private val operation: UICommand.Operation,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/SendUICommand.kt:48:1</span><span class="message">The class `WavePlusUiCommand` is using inheritance, consider using composition instead.

Does `WavePlusUiCommand` want to expose the complete interface (`getByteArray`) of `UICommand` such that `WavePlusUiCommand` can be used where `UICommand` is expected? Indicates __inheritance__.

Does `WavePlusUiCommand` want only some/part of the behavior exposed by `UICommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  45 </span>    abstract fun getByteArray(): ByteArray
<span class="lineno">  46 </span>}
<span class="lineno">  47 </span>
<span class="lineno">  48 </span><span class="error">class WavePlusUiCommand(operation: Operation) : UICommand(operation) {</span>
<span class="lineno">  49 </span><span class="error">    override fun getByteArray(): ByteArray {</span>
<span class="lineno">  50 </span><span class="error">        val commandParams = when (operation) {</span>
<span class="lineno">  51 </span><span class="error">            Operation.WELCOME -&gt; byteArrayOf(UI_COMMAND, 1)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/SendUICommand.kt:71:1</span><span class="message">The class `WaveUiCommand` is using inheritance, consider using composition instead.

Does `WaveUiCommand` want to expose the complete interface (`getByteArray`) of `UICommand` such that `WaveUiCommand` can be used where `UICommand` is expected? Indicates __inheritance__.

Does `WaveUiCommand` want only some/part of the behavior exposed by `UICommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  68 </span>    }
<span class="lineno">  69 </span>}
<span class="lineno">  70 </span>
<span class="lineno">  71 </span><span class="error">class WaveUiCommand(operation: Operation) : UICommand(operation) {</span>
<span class="lineno">  72 </span><span class="error">    override fun getByteArray(): ByteArray {</span>
<span class="lineno">  73 </span><span class="error">        val commandParams = when (operation) {</span>
<span class="lineno">  74 </span><span class="error">            Operation.WELCOME -&gt; byteArrayOf(248.toByte(), UI_COMMAND, 0, 1, 0)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/SendUICommand.kt:95:1</span><span class="message">The class `WaveMiniUiCommand` is using inheritance, consider using composition instead.

Does `WaveMiniUiCommand` want to expose the complete interface (`getByteArray`) of `UICommand` such that `WaveMiniUiCommand` can be used where `UICommand` is expected? Indicates __inheritance__.

Does `WaveMiniUiCommand` want only some/part of the behavior exposed by `UICommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  92 </span>    }
<span class="lineno">  93 </span>}
<span class="lineno">  94 </span>
<span class="lineno">  95 </span><span class="error">class WaveMiniUiCommand(operation: UICommand.Operation) : UICommand(operation) {</span>
<span class="lineno">  96 </span><span class="error">    override fun getByteArray(): ByteArray {</span>
<span class="lineno">  97 </span><span class="error">        return when (operation) {</span>
<span class="lineno">  98 </span><span class="error">            Operation.BREATHE_RED -&gt; byteArrayOf(Merlin.Opcode.UI_COMMAND, 0x00, 0x00)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/SetColorRing.kt:7:1</span><span class="message">The class `SetColorRing` is using inheritance, consider using composition instead.

Does `SetColorRing` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `SetColorRing` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `SetColorRing` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.deviceio.bleio.DeviceDataTypes
<span class="lineno">   5 </span>import com.airthings.instrumentapi.instrument.AtCommProtocol2
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">class SetColorRing(</span>
<span class="lineno">   8 </span><span class="error">    context: Context,</span>
<span class="lineno">   9 </span><span class="error">    private val serialNumber: String,</span>
<span class="lineno">  10 </span><span class="error">    private val color: Int,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/SetWavePlusClockCommand.kt:10:1</span><span class="message">The class `SetWavePlusClockCommand` is using inheritance, consider using composition instead.

Does `SetWavePlusClockCommand` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `SetWavePlusClockCommand` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `SetWavePlusClockCommand` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import com.airthings.utilities.Failure
<span class="lineno">   8 </span>import com.airthings.utilities.Log
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">class SetWavePlusClockCommand(context: Context, private val serialNumber: String) : InstrumentCommand(context) {</span>
<span class="lineno">  11 </span><span class="error"></span>
<span class="lineno">  12 </span><span class="error">    override fun run() {</span>
<span class="lineno">  13 </span><span class="error">        super.run()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/WavePlusFwUpgrade2.kt:29:1</span><span class="message">The class `WavePlusFwUpgrade2` is using inheritance, consider using composition instead.

Does `WavePlusFwUpgrade2` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `WavePlusFwUpgrade2` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `WavePlusFwUpgrade2` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  26 </span>import kotlinx.coroutines.delay
<span class="lineno">  27 </span>import kotlinx.coroutines.runBlocking
<span class="lineno">  28 </span>
<span class="lineno">  29 </span><span class="error">@Deprecated(&quot;Use com.airthings.instrumentapi.instrumentops.FwUpgradeCommand.kt instead.&quot;)</span>
<span class="lineno">  30 </span><span class="error">open class WavePlusFwUpgrade2(</span>
<span class="lineno">  31 </span><span class="error">    context: Context,</span>
<span class="lineno">  32 </span><span class="error">    val serialNumber: String,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/WavePlusFwUpgrade2.kt:597:5</span><span class="message">The class `BleTransfer` is using inheritance, consider using composition instead.

Does `BleTransfer` want to expose the complete interface (`empty public interface`) of `ImageTransfer` such that `BleTransfer` can be used where `ImageTransfer` is expected? Indicates __inheritance__.

Does `BleTransfer` want only some/part of the behavior exposed by `ImageTransfer`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 594 </span>        }
<span class="lineno"> 595 </span>    }
<span class="lineno"> 596 </span>
<span class="lineno"> 597 </span>    <span class="error">private inner class BleTransfer : ImageTransfer() {</span>
<span class="lineno"> 598 </span><span class="error">        fun invoke(gattClient: GattClient, image: WavePlusFwImage): Try&lt;Unit&gt; =</span>
<span class="lineno"> 599 </span><span class="error">            prepareAndTransferImage(</span>
<span class="lineno"> 600 </span><span class="error">                gattClient,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/WavePlusFwUpgrade2.kt:605:5</span><span class="message">The class `Sub1Transfer` is using inheritance, consider using composition instead.

Does `Sub1Transfer` want to expose the complete interface (`empty public interface`) of `ImageTransfer` such that `Sub1Transfer` can be used where `ImageTransfer` is expected? Indicates __inheritance__.

Does `Sub1Transfer` want only some/part of the behavior exposed by `ImageTransfer`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 602 </span>            )
<span class="lineno"> 603 </span>    }
<span class="lineno"> 604 </span>
<span class="lineno"> 605 </span>    <span class="error">private inner class Sub1Transfer : ImageTransfer() {</span>
<span class="lineno"> 606 </span><span class="error">        fun invoke(gattClient: GattClient, image: WavePlusFwImage): Try&lt;Unit&gt; =</span>
<span class="lineno"> 607 </span><span class="error">            prepareAndTransferImage(</span>
<span class="lineno"> 608 </span><span class="error">                gattClient,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/WavePlusFwUpgrade2.kt:613:5</span><span class="message">The class `MspTransfer` is using inheritance, consider using composition instead.

Does `MspTransfer` want to expose the complete interface (`empty public interface`) of `ImageTransfer` such that `MspTransfer` can be used where `ImageTransfer` is expected? Indicates __inheritance__.

Does `MspTransfer` want only some/part of the behavior exposed by `ImageTransfer`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 610 </span>            )
<span class="lineno"> 611 </span>    }
<span class="lineno"> 612 </span>
<span class="lineno"> 613 </span>    <span class="error">private inner class MspTransfer : ImageTransfer() {</span>
<span class="lineno"> 614 </span><span class="error">        @Suppress(&quot;LabeledExpression&quot;)</span>
<span class="lineno"> 615 </span><span class="error">        fun invoke(</span>
<span class="lineno"> 616 </span><span class="error">            instrument: Instrument,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/WriteRfRegion.kt:10:1</span><span class="message">The class `WriteRfRegion` is using inheritance, consider using composition instead.

Does `WriteRfRegion` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `WriteRfRegion` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `WriteRfRegion` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>
<span class="lineno">   8 </span>typealias WriteRegionCallback = (Try&lt;Region&gt;) -&gt; Unit
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">class WriteRfRegion(</span>
<span class="lineno">  11 </span><span class="error">    context: Context,</span>
<span class="lineno">  12 </span><span class="error">    private val serial: String,</span>
<span class="lineno">  13 </span><span class="error">    private val rfRegion: Region,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/getsensorvalues/GetSensorValues.kt:12:1</span><span class="message">The class `GetSensorValues` is using inheritance, consider using composition instead.

Does `GetSensorValues` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `GetSensorValues` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `GetSensorValues` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import com.airthings.utilities.Success
<span class="lineno">  10 </span>import java.util.Date
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class GetSensorValues(</span>
<span class="lineno">  13 </span><span class="error">    context: Context,</span>
<span class="lineno">  14 </span><span class="error">    val serialNumber: String,</span>
<span class="lineno">  15 </span><span class="error">    private val from: Long,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/uisettings/ReadUISettings.kt:9:1</span><span class="message">The class `ReadUISettings` is using inheritance, consider using composition instead.

Does `ReadUISettings` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `ReadUISettings` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `ReadUISettings` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>import com.airthings.utilities.Failure
<span class="lineno">   7 </span>import com.airthings.utilities.Success
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">class ReadUISettings(context: Context, val serialNumber: String, private val readUISettingsCB: ReadUISettingsCB) :</span>
<span class="lineno">  10 </span><span class="error">    InstrumentCommand(context) {</span>
<span class="lineno">  11 </span><span class="error">    override fun run() {</span>
<span class="lineno">  12 </span><span class="error">        super.run()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/uisettings/UISettings.kt:12:1</span><span class="message">The class `WaveUiSettings` is using inheritance, consider using composition instead.

Does `WaveUiSettings` want to expose the complete interface (`getByteArray`) of `UISettings` such that `WaveUiSettings` can be used where `UISettings` is expected? Indicates __inheritance__.

Does `WaveUiSettings` want only some/part of the behavior exposed by `UISettings`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>    abstract fun getByteArray(): ByteArray
<span class="lineno">  10 </span>}
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">@Suppress(&quot;DataClassShouldBeImmutable&quot;) // The properties are being changed in the app.</span>
<span class="lineno">  13 </span><span class="error">data class WaveUiSettings(</span>
<span class="lineno">  14 </span><span class="error">    var yellowLevel: Int = ValueDefines.DEFAULT_RADON_WARNING_LEVEL,</span>
<span class="lineno">  15 </span><span class="error">    var redLevel: Int = ValueDefines.DEFAULT_RADON_HIGH_LEVEL,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/uisettings/WriteUISettings.kt:10:1</span><span class="message">The class `WriteUISettings` is using inheritance, consider using composition instead.

Does `WriteUISettings` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `WriteUISettings` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `WriteUISettings` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import com.airthings.utilities.Success
<span class="lineno">   8 </span>import com.airthings.utilities.Try
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">class WriteUISettings(</span>
<span class="lineno">  11 </span><span class="error">    context: Context,</span>
<span class="lineno">  12 </span><span class="error">    val serialNumber: String,</span>
<span class="lineno">  13 </span><span class="error">    private val uiSettings: UISettings,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/uisettings/griffin/WavePlusUiSettings.kt:20:1</span><span class="message">The class `WavePlusUiSettings` is using inheritance, consider using composition instead.

Does `WavePlusUiSettings` want to expose the complete interface (`getByteArray`) of `UISettings` such that `WavePlusUiSettings` can be used where `UISettings` is expected? Indicates __inheritance__.

Does `WavePlusUiSettings` want only some/part of the behavior exposed by `UISettings`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  17 </span>private const val G_UI_SETTINGS_INITIAL_FORMAT_RESPONSE_SIZE = 23
<span class="lineno">  18 </span>private const val G_UI_SETTINGS_V_1_4_0_RESPONSE_SIZE = 20
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">@Suppress(&quot;DataClassShouldBeImmutable&quot;) // The properties are being changed in the app.</span>
<span class="lineno">  21 </span><span class="error">data class WavePlusUiSettings(</span>
<span class="lineno">  22 </span><span class="error">    var humidityLevelsUpper: ColorThreshold = ColorThreshold(</span>
<span class="lineno">  23 </span><span class="error">        yellowLevel = HUMIDITY_UPPER_YELLOW,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/instrumentops/uisettings/merlin/MerlinUiSettings.kt:9:1</span><span class="message">The class `MerlinUiSettings` is using inheritance, consider using composition instead.

Does `MerlinUiSettings` want to expose the complete interface (`getByteArray`) of `UISettings` such that `MerlinUiSettings` can be used where `UISettings` is expected? Indicates __inheritance__.

Does `MerlinUiSettings` want only some/part of the behavior exposed by `UISettings`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>import com.airthings.instrumentapi.instrumentops.uisettings.UISettings
<span class="lineno">   7 </span>import kotlin.experimental.or
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">@Suppress(&quot;DataClassShouldBeImmutable&quot;) // The properties are being changed in the app.</span>
<span class="lineno">  10 </span><span class="error">data class MerlinUiSettings(</span>
<span class="lineno">  11 </span><span class="error">    var humidityLevelsUpper: ColorThreshold = ColorThreshold(</span>
<span class="lineno">  12 </span><span class="error">        yellowLevel = 60,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/interactioncontrol/InteractionControllerImpl.kt:10:1</span><span class="message">The class `InteractionControllerImpl` is using inheritance, consider using composition instead.

Does `InteractionControllerImpl` want to expose the complete interface (`postCommand, endInteraction, establishInteraction`) of `InteractionController` such that `InteractionControllerImpl` can be used where `InteractionController` is expected? Indicates __inheritance__.

Does `InteractionControllerImpl` want only some/part of the behavior exposed by `InteractionController`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import java.util.UUID
<span class="lineno">   8 </span>import java.util.concurrent.ConcurrentHashMap
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">internal class InteractionControllerImpl(private val interactionProvider: InteractionProvider) :</span>
<span class="lineno">  11 </span><span class="error">    InteractionController() {</span>
<span class="lineno">  12 </span><span class="error"></span>
<span class="lineno">  13 </span><span class="error">    companion object {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/main/java/com/airthings/instrumentapi/scanner/BleScannerImpl.kt:30:1</span><span class="message">The class `BleScannerImpl` is using inheritance, consider using composition instead.

Does `BleScannerImpl` want to expose the complete interface (`empty public interface`) of `BleScanner` such that `BleScannerImpl` can be used where `BleScanner` is expected? Indicates __inheritance__.

Does `BleScannerImpl` want only some/part of the behavior exposed by `BleScanner`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  27 </span>import com.airthings.utilities.Try
<span class="lineno">  28 </span>import java.util.UUID
<span class="lineno">  29 </span>
<span class="lineno">  30 </span><span class="error">internal class BleScannerImpl private constructor(val context: Context) : BleScanner() {</span>
<span class="lineno">  31 </span><span class="error">    private val scannerControlHandler = Handler(Looper.getMainLooper())</span>
<span class="lineno">  32 </span><span class="error">    private val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager</span>
<span class="lineno">  33 </span><span class="error">    private val bluetoothAdapter: BluetoothAdapter? by lazy(LazyThreadSafetyMode.NONE) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/fwutil/BleFirmwareImageTest.kt:34:5</span><span class="message">The class `MockFwImageLoader` is using inheritance, consider using composition instead.

Does `MockFwImageLoader` want to expose the complete interface (`tryLoadAndValidateImage, tryLoadAndValidateImage`) of `FwImageLoader` such that `MockFwImageLoader` can be used where `FwImageLoader` is expected? Indicates __inheritance__.

Does `MockFwImageLoader` want only some/part of the behavior exposed by `FwImageLoader`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  31 </span>        assertEquals(&quot;TEST&quot;, instrumentBleFwImage.imageName)
<span class="lineno">  32 </span>    }
<span class="lineno">  33 </span>
<span class="lineno">  34 </span>    <span class="error">class MockFwImageLoader : FwImageLoader(&quot;&quot;) {</span>
<span class="lineno">  35 </span><span class="error">        var shouldReturnFailure = false</span>
<span class="lineno">  36 </span><span class="error"></span>
<span class="lineno">  37 </span><span class="error">        @Throws(IOException::class)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/gatt/GattClientImpl2Test.kt:130:5</span><span class="message">The class `ConnectionStateSpy` is using inheritance, consider using composition instead.

Does `ConnectionStateSpy` want to expose the complete interface (`onConnectionStateChanged`) of `ConnectionStateChangedListener` such that `ConnectionStateSpy` can be used where `ConnectionStateChangedListener` is expected? Indicates __inheritance__.

Does `ConnectionStateSpy` want only some/part of the behavior exposed by `ConnectionStateChangedListener`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 127 </span>        }
<span class="lineno"> 128 </span>    }
<span class="lineno"> 129 </span>
<span class="lineno"> 130 </span>    <span class="error">private class ConnectionStateSpy : ConnectionStateChangedListener(UUID.randomUUID()) {</span>
<span class="lineno"> 131 </span><span class="error">        var onConnectionStateChangedWasCalled = false</span>
<span class="lineno"> 132 </span><span class="error">        var latestStatus: Int? = null</span>
<span class="lineno"> 133 </span><span class="error">        var latestState: Int? = null</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/gatt/WavePlusGattProfileTest.kt:93:1</span><span class="message">The class `MockGattClient` is using inheritance, consider using composition instead.

Does `MockGattClient` want to expose the complete interface (`whenCharacteristicIsWritten_callOnCharacteristicChanged, onCharacteristicChanged, onCharacteristicWrite, writeDescriptor, setCharacteristicNotification, readCharacteristic, writeCharacteristic, getService, discoverServices, getServices, requestConnectionPriority, close, disconnect, mockSetConnState, requestMtu, connect`) of `FakeGattClient` such that `MockGattClient` can be used where `FakeGattClient` is expected? Indicates __inheritance__.

Does `MockGattClient` want only some/part of the behavior exposed by `FakeGattClient`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  90 </span>    }
<span class="lineno">  91 </span>}
<span class="lineno">  92 </span>
<span class="lineno">  93 </span><span class="error">private class MockGattClient : FakeGattClient() {</span>
<span class="lineno">  94 </span><span class="error">    var serviceToReturn: BluetoothGattService? = null</span>
<span class="lineno">  95 </span><span class="error"></span>
<span class="lineno">  96 </span><span class="error">    override fun getService(uuid: UUID): BluetoothGattService? = serviceToReturn</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/wavemini/MerlinDatasetInfoTest.kt:78:5</span><span class="message">The class `FakeNowDatasetEndCalculator` is using inheritance, consider using composition instead.

Does `FakeNowDatasetEndCalculator` want to expose the complete interface (`calcEndTime`) of `DatasetEndCalculator` such that `FakeNowDatasetEndCalculator` can be used where `DatasetEndCalculator` is expected? Indicates __inheritance__.

Does `FakeNowDatasetEndCalculator` want only some/part of the behavior exposed by `DatasetEndCalculator`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  75 </span>        assertEquals(start.time + 2 * MILLIS_PER_HOUR + 3 * MILLIS_IN_FIVE_MINUTES, endTime)
<span class="lineno">  76 </span>    }
<span class="lineno">  77 </span>
<span class="lineno">  78 </span>    <span class="error">internal class FakeNowDatasetEndCalculator(private val fakeNow: Long) : DatasetEndCalculator() {</span>
<span class="lineno">  79 </span><span class="error">        override val now: Long</span>
<span class="lineno">  80 </span><span class="error">            get() = fakeNow</span>
<span class="lineno">  81 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/oad/FakeGattClient.kt:19:1</span><span class="message">The class `FakeGattClient` is using inheritance, consider using composition instead.

Does `FakeGattClient` want to expose the complete interface (`onServicesDiscovered, onMtuChanged, onDescriptorWrite, onDescriptorRead, onCharacteristicWrite, onCharacteristicRead, onConnectionStateChange, onCharacteristicChanged, getConnectionState, removeGattObserver, addGattObserver, close, disconnect, connect`) of `GattClient` such that `FakeGattClient` can be used where `GattClient` is expected? Indicates __inheritance__.

Does `FakeGattClient` want only some/part of the behavior exposed by `GattClient`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  16 </span>import org.mockito.Mockito.mock
<span class="lineno">  17 </span>import org.powermock.reflect.Whitebox
<span class="lineno">  18 </span>
<span class="lineno">  19 </span><span class="error">open class FakeGattClient : GattClient() {</span>
<span class="lineno">  20 </span><span class="error">    override fun connect(bluetoothDevice: BluetoothDevice, context: Context) {</span>
<span class="lineno">  21 </span><span class="error">        TODO(&quot;not implemented&quot;) // To change body of created functions use File | Settings | File Templates.</span>
<span class="lineno">  22 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/oad/MockOadGattProfile.kt:5:1</span><span class="message">The class `MockOadGattProfile` is using inheritance, consider using composition instead.

Does `MockOadGattProfile` want to expose the complete interface (`empty public interface`) of `OadGattProfile` such that `MockOadGattProfile` can be used where `OadGattProfile` is expected? Indicates __inheritance__.

Does `MockOadGattProfile` want only some/part of the behavior exposed by `OadGattProfile`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   2 </span>
<span class="lineno">   3 </span>import com.airthings.instrumentapi.instrument.gatt.GattClient
<span class="lineno">   4 </span>
<span class="lineno">   5 </span><span class="error">internal class MockOadGattProfile(gattClient: GattClient) : OadGattProfile(gattClient)</span>
<span class="lineno">   6 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrument/waveplus/oad/OADControlPointOperationsTest.kt:105:1</span><span class="message">The class `DirectBlockRequestResponseSwitch` is using inheritance, consider using composition instead.

Does `DirectBlockRequestResponseSwitch` want to expose the complete interface (`invoke`) of `OadCpSwitch` such that `DirectBlockRequestResponseSwitch` can be used where `OadCpSwitch` is expected? Indicates __inheritance__.

Does `DirectBlockRequestResponseSwitch` want only some/part of the behavior exposed by `OadCpSwitch`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 102 </span>    abstract fun invoke()
<span class="lineno"> 103 </span>}
<span class="lineno"> 104 </span>
<span class="lineno"> 105 </span><span class="error">internal class DirectBlockRequestResponseSwitch(</span>
<span class="lineno"> 106 </span><span class="error">    private val gattClient: FakeGattClient,</span>
<span class="lineno"> 107 </span><span class="error">    private val oadGattProfile: OadGattProfile</span>
<span class="lineno"> 108 </span><span class="error">) : OadCpSwitch(gattClient) {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/instrumentops/NullCommand.kt:5:1</span><span class="message">The class `NullCommand` is using inheritance, consider using composition instead.

Does `NullCommand` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `NullCommand` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `NullCommand` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   2 </span>
<span class="lineno">   3 </span>import android.content.Context
<span class="lineno">   4 </span>
<span class="lineno">   5 </span><span class="error">internal class NullCommand(context: Context) : InstrumentCommand(context) {</span>
<span class="lineno">   6 </span><span class="error">    override fun runAsFailure() {</span>
<span class="lineno">   7 </span><span class="error">        // STUB</span>
<span class="lineno">   8 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/interactioncontrol/InteractionControllerTest.kt:38:1</span><span class="message">The class `FakeInteractionProvider` is using inheritance, consider using composition instead.

Does `FakeInteractionProvider` want to expose the complete interface (`empty public interface`) of `InteractionProvider` such that `FakeInteractionProvider` can be used where `InteractionProvider` is expected? Indicates __inheritance__.

Does `FakeInteractionProvider` want only some/part of the behavior exposed by `InteractionProvider`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  35 </span>    override fun interactionError(serialNumber: String, clientId: UUID?, reason: String?) {}
<span class="lineno">  36 </span>}
<span class="lineno">  37 </span>
<span class="lineno">  38 </span><span class="error">internal open class FakeInteractionProvider : InteractionProvider(mock(Context::class.java)) {</span>
<span class="lineno">  39 </span><span class="error">    val interactionMap = HashMap&lt;String, InstrumentInteraction&gt;()</span>
<span class="lineno">  40 </span><span class="error"></span>
<span class="lineno">  41 </span><span class="error">    override fun getInteraction(serialNumber: String, interactionCallback: InteractionCallback2): InstrumentInteraction {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/interactioncontrol/InteractionControllerTest.kt:47:1</span><span class="message">The class `MockInstrumentInteraction` is using inheritance, consider using composition instead.

Does `MockInstrumentInteraction` want to expose the complete interface (`initiateInteraction, disconnect, postCommand, isInitialized`) of `InstrumentInteraction` such that `MockInstrumentInteraction` can be used where `InstrumentInteraction` is expected? Indicates __inheritance__.

Does `MockInstrumentInteraction` want only some/part of the behavior exposed by `InstrumentInteraction`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  44 </span>    }
<span class="lineno">  45 </span>}
<span class="lineno">  46 </span>
<span class="lineno">  47 </span><span class="error">private open class MockInstrumentInteraction internal constructor(</span>
<span class="lineno">  48 </span><span class="error">    context: Context,</span>
<span class="lineno">  49 </span><span class="error">    serialNumber: String,</span>
<span class="lineno">  50 </span><span class="error">    callback: InteractionCallback2</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/interactioncontrol/InteractionControllerTest.kt:273:5</span><span class="message">The class `DummyCommand` is using inheritance, consider using composition instead.

Does `DummyCommand` want to expose the complete interface (`runAsFailure, run`) of `InstrumentCommand` such that `DummyCommand` can be used where `InstrumentCommand` is expected? Indicates __inheritance__.

Does `DummyCommand` want only some/part of the behavior exposed by `InstrumentCommand`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 270 </span>        Mockito.verify(interactionProvider.interactionMap[testData.serialNumber]!!).postCommand(dummyCommand)
<span class="lineno"> 271 </span>    }
<span class="lineno"> 272 </span>
<span class="lineno"> 273 </span>    <span class="error">open inner class DummyCommand(onCompletion: ((Try&lt;Unit&gt;) -&gt; Unit)) : InstrumentCommand(mock(Context::class.java), onCompletion) {</span>
<span class="lineno"> 274 </span><span class="error">        override fun runAsFailure() {}</span>
<span class="lineno"> 275 </span><span class="error">    }</span>
<span class="lineno"> 276 </span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/scanner/MockBleScanner.kt:11:1</span><span class="message">The class `MockBleScanner` is using inheritance, consider using composition instead.

Does `MockBleScanner` want to expose the complete interface (`empty public interface`) of `BleScanner` such that `MockBleScanner` can be used where `BleScanner` is expected? Indicates __inheritance__.

Does `MockBleScanner` want only some/part of the behavior exposed by `BleScanner`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   8 </span>import java.util.UUID
<span class="lineno">   9 </span>import org.mockito.Mockito.mock
<span class="lineno">  10 </span>
<span class="lineno">  11 </span><span class="error">internal class MockBleScanner : BleScanner() {</span>
<span class="lineno">  12 </span><span class="error">    override fun restartBluetoothAdapter(onCompletion: (Try&lt;Unit&gt;) -&gt; Unit) {</span>
<span class="lineno">  13 </span><span class="error">        TODO(&quot;not implemented&quot;) // To change body of created functions use File | Settings | File Templates.</span>
<span class="lineno">  14 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-instrumentapi/src/test/java/com/airthings/instrumentapi/scanner/ScannerClientTest.kt:116:5</span><span class="message">The class `FakeScannerProvider` is using inheritance, consider using composition instead.

Does `FakeScannerProvider` want to expose the complete interface (`empty public interface`) of `ScannerProvider` such that `FakeScannerProvider` can be used where `ScannerProvider` is expected? Indicates __inheritance__.

Does `FakeScannerProvider` want only some/part of the behavior exposed by `ScannerProvider`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 113 </span>        }
<span class="lineno"> 114 </span>    }
<span class="lineno"> 115 </span>
<span class="lineno"> 116 </span>    <span class="error">internal class FakeScannerProvider(context: Context, private val bleScanner: MockBleScanner) :</span>
<span class="lineno"> 117 </span><span class="error">        ScannerProvider(context) {</span>
<span class="lineno"> 118 </span><span class="error">        override fun getScanner(): BleScanner {</span>
<span class="lineno"> 119 </span><span class="error">            return bleScanner</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/dialogsheet/DialogSheetFragment.kt:18:1</span><span class="message">The class `DialogSheetFragment` is using inheritance, consider using composition instead.

Does `DialogSheetFragment` want to expose the complete interface (`onCancel, onDismiss, onDestroyView, onCreateDialog, onCreateView, getDialog, makeFullScreen, onTouchOutside, onBackPressed, onDismiss, onCancel, onShown, secondButtonOnClick, firstButtonOnClick`) of `BaseDialogSheetFragment` such that `DialogSheetFragment` can be used where `BaseDialogSheetFragment` is expected? Indicates __inheritance__.

Does `DialogSheetFragment` want only some/part of the behavior exposed by `BaseDialogSheetFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  15 </span>import com.airthings.uicomponents.databinding.BottomSheetDialogBinding
<span class="lineno">  16 </span>import com.google.android.material.bottomsheet.BottomSheetDialog
<span class="lineno">  17 </span>
<span class="lineno">  18 </span><span class="error">@Suppress(&quot;TooManyFunctions&quot;)</span>
<span class="lineno">  19 </span><span class="error">abstract class DialogSheetFragment : BaseDialogSheetFragment&lt;BottomSheetDialogBinding&gt;(), TextWatcher {</span>
<span class="lineno">  20 </span><span class="error">    override val layoutResourceId = R.layout.bottom_sheet_dialog</span>
<span class="lineno">  21 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/dialogsheet/FirstButtonDialogSheetFragment.kt:5:1</span><span class="message">The class `FirstButtonDialogSheetFragment` is using inheritance, consider using composition instead.

Does `FirstButtonDialogSheetFragment` want to expose the complete interface (`onTextChanged, beforeTextChanged, afterTextChanged, firstButtonOnClick, dismiss, onDismiss, onDestroyView, onCreateView, onEditableChanged, firstButtonOnClick`) of `DialogSheetFragment` such that `FirstButtonDialogSheetFragment` can be used where `DialogSheetFragment` is expected? Indicates __inheritance__.

Does `FirstButtonDialogSheetFragment` want only some/part of the behavior exposed by `DialogSheetFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   2 </span>
<span class="lineno">   3 </span>import android.view.View
<span class="lineno">   4 </span>
<span class="lineno">   5 </span><span class="error">@Suppress(&quot;unused&quot;)</span>
<span class="lineno">   6 </span><span class="error">abstract class FirstButtonDialogSheetFragment : DialogSheetFragment() {</span>
<span class="lineno">   7 </span><span class="error">    final override fun secondButtonOnClick(view: View) {</span>
<span class="lineno">   8 </span><span class="error">        @Suppress(&quot;TooGenericExceptionThrown&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/dialogsheet/FirstButtonDialogSheetFragment.kt:13:1</span><span class="message">The class `FirstButtonPluggableDialogSheetFragment` is using inheritance, consider using composition instead.

Does `FirstButtonPluggableDialogSheetFragment` want to expose the complete interface (`onDestroyView, onCreateView`) of `PluggableDialogSheetFragment` such that `FirstButtonPluggableDialogSheetFragment` can be used where `PluggableDialogSheetFragment` is expected? Indicates __inheritance__.

Does `FirstButtonPluggableDialogSheetFragment` want only some/part of the behavior exposed by `PluggableDialogSheetFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>    }
<span class="lineno">  11 </span>}
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">@Suppress(&quot;unused&quot;)</span>
<span class="lineno">  14 </span><span class="error">abstract class FirstButtonPluggableDialogSheetFragment : PluggableDialogSheetFragment() {</span>
<span class="lineno">  15 </span><span class="error">    final override fun secondButtonOnClick(view: View) {</span>
<span class="lineno">  16 </span><span class="error">        @Suppress(&quot;TooGenericExceptionThrown&quot;)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/dialogsheet/PluggableDialogSheetFragment.kt:13:1</span><span class="message">The class `PluggableDialogSheetFragment` is using inheritance, consider using composition instead.

Does `PluggableDialogSheetFragment` want to expose the complete interface (`onCancel, onDismiss, onDestroyView, onCreateDialog, onCreateView, getDialog, makeFullScreen, onTouchOutside, onBackPressed, onDismiss, onCancel, onShown, secondButtonOnClick, firstButtonOnClick`) of `BaseDialogSheetFragment` such that `PluggableDialogSheetFragment` can be used where `BaseDialogSheetFragment` is expected? Indicates __inheritance__.

Does `PluggableDialogSheetFragment` want only some/part of the behavior exposed by `BaseDialogSheetFragment`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>import com.airthings.uicomponents.R
<span class="lineno">  11 </span>import com.airthings.uicomponents.databinding.PluggableBottomSheetDialogBinding
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">abstract class PluggableDialogSheetFragment : BaseDialogSheetFragment&lt;PluggableBottomSheetDialogBinding&gt;() {</span>
<span class="lineno">  14 </span><span class="error">    override val layoutResourceId = R.layout.pluggable_bottom_sheet_dialog</span>
<span class="lineno">  15 </span><span class="error"></span>
<span class="lineno">  16 </span><span class="error">    /**</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/sensor/NullConfiguration.kt:8:1</span><span class="message">The class `NullConfiguration` is using inheritance, consider using composition instead.

Does `NullConfiguration` want to expose the complete interface (`Exposing interface of a Java superclass is not supported`) of `ConfigurationBase` such that `NullConfiguration` can be used where `ConfigurationBase` is expected? Indicates __inheritance__.

Does `NullConfiguration` want only some/part of the behavior exposed by `ConfigurationBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   5 </span>import com.airthings.uicomponents.format.PreferredUnit
<span class="lineno">   6 </span>import com.airthings.utilities.Log
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">internal class NullConfiguration(context: Context, sensorViewLayout: SensorViewLayout) : ConfigurationBase(), SensorLayoutConfiguration {</span>
<span class="lineno">   9 </span><span class="error">    override fun setSensorClickListeners(function: (SensorViewConfig) -&gt; Unit) {</span>
<span class="lineno">  10 </span><span class="error">        // Intentional. No sensors in the null configuration. Therefore there will be no click listeners to set.</span>
<span class="lineno">  11 </span><span class="error">    }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/sensor/SensorData.kt:7:1</span><span class="message">The class `WaveSensorData` is using inheritance, consider using composition instead.

Does `WaveSensorData` want to expose the complete interface (`empty public interface`) of `SensorData` such that `WaveSensorData` can be used where `SensorData` is expected? Indicates __inheritance__.

Does `WaveSensorData` want only some/part of the behavior exposed by `SensorData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>
<span class="lineno">   5 </span>class SensorStatus(val value: String, val qualityLevel: QualityLevel)
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">class WaveSensorData(</span>
<span class="lineno">   8 </span><span class="error">    val radon: SensorStatus,</span>
<span class="lineno">   9 </span><span class="error">    val temperature: SensorStatus,</span>
<span class="lineno">  10 </span><span class="error">    val humidity: SensorStatus</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/sensor/SensorData.kt:13:1</span><span class="message">The class `ProSensorData` is using inheritance, consider using composition instead.

Does `ProSensorData` want to expose the complete interface (`empty public interface`) of `SensorData` such that `ProSensorData` can be used where `SensorData` is expected? Indicates __inheritance__.

Does `ProSensorData` want only some/part of the behavior exposed by `SensorData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>    val humidity: SensorStatus
<span class="lineno">  11 </span>) : SensorData()
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">class ProSensorData(</span>
<span class="lineno">  14 </span><span class="error">    val radon: SensorStatus,</span>
<span class="lineno">  15 </span><span class="error">    val temperature: SensorStatus,</span>
<span class="lineno">  16 </span><span class="error">    val humidity: SensorStatus,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/sensor/SensorData.kt:20:1</span><span class="message">The class `WavePlusSensorData` is using inheritance, consider using composition instead.

Does `WavePlusSensorData` want to expose the complete interface (`empty public interface`) of `SensorData` such that `WavePlusSensorData` can be used where `SensorData` is expected? Indicates __inheritance__.

Does `WavePlusSensorData` want only some/part of the behavior exposed by `SensorData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  17 </span>    val pressure: SensorStatus
<span class="lineno">  18 </span>) : SensorData()
<span class="lineno">  19 </span>
<span class="lineno">  20 </span><span class="error">class WavePlusSensorData(</span>
<span class="lineno">  21 </span><span class="error">    val radon: SensorStatus,</span>
<span class="lineno">  22 </span><span class="error">    val temperature: SensorStatus,</span>
<span class="lineno">  23 </span><span class="error">    val humidity: SensorStatus,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/sensor/SensorData.kt:29:1</span><span class="message">The class `WaveMiniSensorData` is using inheritance, consider using composition instead.

Does `WaveMiniSensorData` want to expose the complete interface (`empty public interface`) of `SensorData` such that `WaveMiniSensorData` can be used where `SensorData` is expected? Indicates __inheritance__.

Does `WaveMiniSensorData` want only some/part of the behavior exposed by `SensorData`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  26 </span>    val voc: SensorStatus
<span class="lineno">  27 </span>) : SensorData()
<span class="lineno">  28 </span>
<span class="lineno">  29 </span><span class="error">class WaveMiniSensorData(</span>
<span class="lineno">  30 </span><span class="error">    val voc: SensorStatus,</span>
<span class="lineno">  31 </span><span class="error">    val humidity: SensorStatus,</span>
<span class="lineno">  32 </span><span class="error">    val temperature: SensorStatus</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/sensor/WaveConfiguration.kt:7:1</span><span class="message">The class `WaveConfiguration` is using inheritance, consider using composition instead.

Does `WaveConfiguration` want to expose the complete interface (`Exposing interface of a Java superclass is not supported`) of `ConfigurationBase` such that `WaveConfiguration` can be used where `ConfigurationBase` is expected? Indicates __inheritance__.

Does `WaveConfiguration` want only some/part of the behavior exposed by `ConfigurationBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.uicomponents.R
<span class="lineno">   5 </span>import com.airthings.uicomponents.format.PreferredUnit
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class WaveConfiguration internal constructor(context: Context, sensorViewLayout: SensorViewLayout) : ConfigurationBase(), SensorLayoutConfiguration {</span>
<span class="lineno">   8 </span><span class="error">    private val radonSensorView: SensorView</span>
<span class="lineno">   9 </span><span class="error">    private val tempSensorView: SensorView</span>
<span class="lineno">  10 </span><span class="error">    private val humiditySensorView: SensorView</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/sensor/WaveMiniConfiguration.kt:7:1</span><span class="message">The class `WaveMiniConfiguration` is using inheritance, consider using composition instead.

Does `WaveMiniConfiguration` want to expose the complete interface (`Exposing interface of a Java superclass is not supported`) of `ConfigurationBase` such that `WaveMiniConfiguration` can be used where `ConfigurationBase` is expected? Indicates __inheritance__.

Does `WaveMiniConfiguration` want only some/part of the behavior exposed by `ConfigurationBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.uicomponents.R
<span class="lineno">   5 </span>import com.airthings.uicomponents.format.PreferredUnit
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class WaveMiniConfiguration(context: Context, sensorViewLayout: SensorViewLayout) : ConfigurationBase(),</span>
<span class="lineno">   8 </span><span class="error">    SensorLayoutConfiguration {</span>
<span class="lineno">   9 </span><span class="error"></span>
<span class="lineno">  10 </span><span class="error">    private val tempSensorView: SensorView</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/sensor/WavePlusConfiguration.kt:7:1</span><span class="message">The class `WavePlusConfiguration` is using inheritance, consider using composition instead.

Does `WavePlusConfiguration` want to expose the complete interface (`Exposing interface of a Java superclass is not supported`) of `ConfigurationBase` such that `WavePlusConfiguration` can be used where `ConfigurationBase` is expected? Indicates __inheritance__.

Does `WavePlusConfiguration` want only some/part of the behavior exposed by `ConfigurationBase`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   4 </span>import com.airthings.uicomponents.R
<span class="lineno">   5 </span>import com.airthings.uicomponents.format.PreferredUnit
<span class="lineno">   6 </span>
<span class="lineno">   7 </span><span class="error">internal class WavePlusConfiguration(context: Context, sensorViewLayout: SensorViewLayout) : ConfigurationBase(), SensorLayoutConfiguration {</span>
<span class="lineno">   8 </span><span class="error">    private val radonSensorView: SensorView</span>
<span class="lineno">   9 </span><span class="error">    private val tempSensorView: SensorView</span>
<span class="lineno">  10 </span><span class="error">    private val humiditySensorView: SensorView</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/dashboarddevicelist/InstrumentListItem.kt:3:1</span><span class="message">The class `InstrumentListItem` is using inheritance, consider using composition instead.

Does `InstrumentListItem` want to expose the complete interface (`empty public interface`) of `HeaderListItem` such that `InstrumentListItem` can be used where `HeaderListItem` is expected? Indicates __inheritance__.

Does `InstrumentListItem` want only some/part of the behavior exposed by `HeaderListItem`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   1 </span>package com.airthings.uicomponents.view.widget.dashboarddevicelist
<span class="lineno">   2 </span>
<span class="lineno">   3 </span><span class="error">class InstrumentListItem(</span>
<span class="lineno">   4 </span><span class="error">    val serialNumber: String,</span>
<span class="lineno">   5 </span><span class="error">    roomName: String,</span>
<span class="lineno">   6 </span><span class="error">    locationName: String,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/GraphViewOverlay.kt:37:5</span><span class="message">The class `Hidden` is using inheritance, consider using composition instead.

Does `Hidden` want to expose the complete interface (`empty public interface`) of `Mode` such that `Hidden` can be used where `Mode` is expected? Indicates __inheritance__.

Does `Hidden` want only some/part of the behavior exposed by `Mode`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  34 </span>        abstract val text: String
<span class="lineno">  35 </span>    }
<span class="lineno">  36 </span>
<span class="lineno">  37 </span>    <span class="error">class Hidden : Mode() {</span>
<span class="lineno">  38 </span><span class="error">        override val visibility: Int = View.GONE</span>
<span class="lineno">  39 </span><span class="error">        override val iconResource: Int = R.drawable.ic_info_outline_stronghold_48dp</span>
<span class="lineno">  40 </span><span class="error">        override val text = &quot;&quot;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/GraphViewOverlay.kt:43:5</span><span class="message">The class `Error` is using inheritance, consider using composition instead.

Does `Error` want to expose the complete interface (`empty public interface`) of `Mode` such that `Error` can be used where `Mode` is expected? Indicates __inheritance__.

Does `Error` want only some/part of the behavior exposed by `Mode`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  40 </span>        override val text = &quot;&quot;
<span class="lineno">  41 </span>    }
<span class="lineno">  42 </span>
<span class="lineno">  43 </span>    <span class="error">class Error(shortMessageToShow: String) : Mode() {</span>
<span class="lineno">  44 </span><span class="error">        override val visibility: Int = View.VISIBLE</span>
<span class="lineno">  45 </span><span class="error">        override val iconResource: Int = R.drawable.ic_error_outline_stronghold_48dp</span>
<span class="lineno">  46 </span><span class="error">        override val text = shortMessageToShow</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/GraphViewOverlay.kt:49:5</span><span class="message">The class `Status` is using inheritance, consider using composition instead.

Does `Status` want to expose the complete interface (`empty public interface`) of `Mode` such that `Status` can be used where `Mode` is expected? Indicates __inheritance__.

Does `Status` want only some/part of the behavior exposed by `Mode`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  46 </span>        override val text = shortMessageToShow
<span class="lineno">  47 </span>    }
<span class="lineno">  48 </span>
<span class="lineno">  49 </span>    <span class="error">class Status(shortMessageToShow: String) : Mode() {</span>
<span class="lineno">  50 </span><span class="error">        override val visibility: Int = View.VISIBLE</span>
<span class="lineno">  51 </span><span class="error">        override val iconResource: Int = R.drawable.ic_info_outline_stronghold_48dp</span>
<span class="lineno">  52 </span><span class="error">        override val text = shortMessageToShow</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/color/MiscColorShaders.kt:15:1</span><span class="message">The class `TemperatureColorSetter` is using inheritance, consider using composition instead.

Does `TemperatureColorSetter` want to expose the complete interface (`setSliderInnerPaint, getPathColorShader`) of `SliderAndBackgroundColorSetter` such that `TemperatureColorSetter` can be used where `SliderAndBackgroundColorSetter` is expected? Indicates __inheritance__.

Does `TemperatureColorSetter` want only some/part of the behavior exposed by `SliderAndBackgroundColorSetter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  12 </span>import com.airthings.uicomponents.R
<span class="lineno">  13 </span>import com.airthings.uicomponents.view.widget.graph.ValueToCanvasTf
<span class="lineno">  14 </span>
<span class="lineno">  15 </span><span class="error">internal class TemperatureColorSetter(</span>
<span class="lineno">  16 </span><span class="error">    context: Context,</span>
<span class="lineno">  17 </span><span class="error">    graphBounds: RectF,</span>
<span class="lineno">  18 </span><span class="error">    graphTopPaddingPx: Float,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/color/MiscColorShaders.kt:50:1</span><span class="message">The class `HumidityColorSetter` is using inheritance, consider using composition instead.

Does `HumidityColorSetter` want to expose the complete interface (`setSliderInnerPaint, getPathColorShader`) of `SliderAndBackgroundColorSetter` such that `HumidityColorSetter` can be used where `SliderAndBackgroundColorSetter` is expected? Indicates __inheritance__.

Does `HumidityColorSetter` want only some/part of the behavior exposed by `SliderAndBackgroundColorSetter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  47 </span>    }
<span class="lineno">  48 </span>}
<span class="lineno">  49 </span>
<span class="lineno">  50 </span><span class="error">internal class HumidityColorSetter(</span>
<span class="lineno">  51 </span><span class="error">    context: Context,</span>
<span class="lineno">  52 </span><span class="error">    graphBounds: RectF</span>
<span class="lineno">  53 </span><span class="error">) :</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/color/MiscColorShaders.kt:71:1</span><span class="message">The class `PressureColorSetter` is using inheritance, consider using composition instead.

Does `PressureColorSetter` want to expose the complete interface (`setSliderInnerPaint, getPathColorShader`) of `SliderAndBackgroundColorSetter` such that `PressureColorSetter` can be used where `SliderAndBackgroundColorSetter` is expected? Indicates __inheritance__.

Does `PressureColorSetter` want only some/part of the behavior exposed by `SliderAndBackgroundColorSetter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  68 </span>    }
<span class="lineno">  69 </span>}
<span class="lineno">  70 </span>
<span class="lineno">  71 </span><span class="error">internal class PressureColorSetter(</span>
<span class="lineno">  72 </span><span class="error">    val context: Context,</span>
<span class="lineno">  73 </span><span class="error">    graphBounds: RectF,</span>
<span class="lineno">  74 </span><span class="error">    canvasBounds: RectF</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/color/SliderAndBackgroundColorSetter.kt:21:1</span><span class="message">The class `GreenYellowRedColorSetter` is using inheritance, consider using composition instead.

Does `GreenYellowRedColorSetter` want to expose the complete interface (`setSliderInnerPaint, getPathColorShader`) of `SliderAndBackgroundColorSetter` such that `GreenYellowRedColorSetter` can be used where `SliderAndBackgroundColorSetter` is expected? Indicates __inheritance__.

Does `GreenYellowRedColorSetter` want only some/part of the behavior exposed by `SliderAndBackgroundColorSetter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  18 </span>    abstract fun setSliderInnerPaint(sliderInnerPaint: Paint, touchX: Float, sliderYPos: Float)
<span class="lineno">  19 </span>}
<span class="lineno">  20 </span>
<span class="lineno">  21 </span><span class="error">internal open class GreenYellowRedColorSetter(</span>
<span class="lineno">  22 </span><span class="error">    val context: Context,</span>
<span class="lineno">  23 </span><span class="error">    graphBounds: RectF,</span>
<span class="lineno">  24 </span><span class="error">    canvasBounds: RectF,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/color/SliderAndBackgroundColorSetter.kt:93:1</span><span class="message">The class `RadonColorSetter` is using inheritance, consider using composition instead.

Does `RadonColorSetter` want to expose the complete interface (`setSliderInnerPaint, getPathColorShader`) of `GreenYellowRedColorSetter` such that `RadonColorSetter` can be used where `GreenYellowRedColorSetter` is expected? Indicates __inheritance__.

Does `RadonColorSetter` want only some/part of the behavior exposed by `GreenYellowRedColorSetter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  90 </span>    }
<span class="lineno">  91 </span>}
<span class="lineno">  92 </span>
<span class="lineno">  93 </span><span class="error">internal class RadonColorSetter(</span>
<span class="lineno">  94 </span><span class="error">    context: Context,</span>
<span class="lineno">  95 </span><span class="error">    graphBounds: RectF,</span>
<span class="lineno">  96 </span><span class="error">    canvasBounds: RectF,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/color/SliderAndBackgroundColorSetter.kt:104:1</span><span class="message">The class `VOCColorSetter` is using inheritance, consider using composition instead.

Does `VOCColorSetter` want to expose the complete interface (`setSliderInnerPaint, getPathColorShader`) of `GreenYellowRedColorSetter` such that `VOCColorSetter` can be used where `GreenYellowRedColorSetter` is expected? Indicates __inheritance__.

Does `VOCColorSetter` want only some/part of the behavior exposed by `GreenYellowRedColorSetter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 101 </span>        yellowLevel = 100,
<span class="lineno"> 102 </span>        redLevel = 150)
<span class="lineno"> 103 </span>
<span class="lineno"> 104 </span><span class="error">internal class VOCColorSetter(</span>
<span class="lineno"> 105 </span><span class="error">    context: Context,</span>
<span class="lineno"> 106 </span><span class="error">    graphBounds: RectF,</span>
<span class="lineno"> 107 </span><span class="error">    canvasBounds: RectF,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/color/SliderAndBackgroundColorSetter.kt:115:1</span><span class="message">The class `CO2ColorSetter` is using inheritance, consider using composition instead.

Does `CO2ColorSetter` want to expose the complete interface (`setSliderInnerPaint, getPathColorShader`) of `GreenYellowRedColorSetter` such that `CO2ColorSetter` can be used where `GreenYellowRedColorSetter` is expected? Indicates __inheritance__.

Does `CO2ColorSetter` want only some/part of the behavior exposed by `GreenYellowRedColorSetter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 112 </span>        yellowLevel = 250,
<span class="lineno"> 113 </span>        redLevel = 2000)
<span class="lineno"> 114 </span>
<span class="lineno"> 115 </span><span class="error">internal class CO2ColorSetter(</span>
<span class="lineno"> 116 </span><span class="error">    context: Context,</span>
<span class="lineno"> 117 </span><span class="error">    graphBounds: RectF,</span>
<span class="lineno"> 118 </span><span class="error">    canvasBounds: RectF,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/path/BackgroundPathBuilder.kt:9:1</span><span class="message">The class `BackgroundPathBuilder` is using inheritance, consider using composition instead.

Does `BackgroundPathBuilder` want to expose the complete interface (`addCurvedSegmentToPath`) of `PathBuilder` such that `BackgroundPathBuilder` can be used where `PathBuilder` is expected? Indicates __inheritance__.

Does `BackgroundPathBuilder` want only some/part of the behavior exposed by `PathBuilder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   6 </span>import com.airthings.uicomponents.view.widget.graph.segment.LineSegment
<span class="lineno">   7 </span>import com.airthings.uicomponents.view.widget.graph.segment.SegmentDataBuilder
<span class="lineno">   8 </span>
<span class="lineno">   9 </span><span class="error">class BackgroundPathBuilder : PathBuilder() {</span>
<span class="lineno">  10 </span><span class="error"></span>
<span class="lineno">  11 </span><span class="error">    fun buildBackgroundPath(segmentDataBuilder: SegmentDataBuilder, canvasBounds: RectF): Path {</span>
<span class="lineno">  12 </span><span class="error">        var path = Path()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/path/DataPathBuilder.kt:10:1</span><span class="message">The class `DataPathBuilder` is using inheritance, consider using composition instead.

Does `DataPathBuilder` want to expose the complete interface (`addCurvedSegmentToPath`) of `PathBuilder` such that `DataPathBuilder` can be used where `PathBuilder` is expected? Indicates __inheritance__.

Does `DataPathBuilder` want only some/part of the behavior exposed by `PathBuilder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import com.airthings.uicomponents.view.widget.graph.segment.SegmentDataBuilder
<span class="lineno">   8 </span>import java.util.ArrayList
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">class DataPathBuilder : PathBuilder() {</span>
<span class="lineno">  11 </span><span class="error"></span>
<span class="lineno">  12 </span><span class="error">    fun buildDataPaths(segmentDataBuilder: SegmentDataBuilder, graphTopPadding_px: Float): SparseArray&lt;ArrayList&lt;Path&gt;&gt; {</span>
<span class="lineno">  13 </span><span class="error">        val paths = SparseArray&lt;ArrayList&lt;Path&gt;&gt;()</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/graph/path/SliderPathBuilder.kt:8:1</span><span class="message">The class `SliderPathBuilder` is using inheritance, consider using composition instead.

Does `SliderPathBuilder` want to expose the complete interface (`addCurvedSegmentToPath`) of `PathBuilder` such that `SliderPathBuilder` can be used where `PathBuilder` is expected? Indicates __inheritance__.

Does `SliderPathBuilder` want only some/part of the behavior exposed by `PathBuilder`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   5 </span>import com.airthings.uicomponents.view.widget.graph.segment.LineSegment
<span class="lineno">   6 </span>import com.airthings.uicomponents.view.widget.graph.segment.SegmentDataBuilder
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">class SliderPathBuilder : PathBuilder() {</span>
<span class="lineno">   9 </span><span class="error">    fun buildSliderPath(segmentDataBuilder: SegmentDataBuilder): Path {</span>
<span class="lineno">  10 </span><span class="error">        var path = Path()</span>
<span class="lineno">  11 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/inappnotificationpager/BluetoothNotification.kt:10:1</span><span class="message">The class `BluetoothNotification` is using inheritance, consider using composition instead.

Does `BluetoothNotification` want to expose the complete interface (`empty public interface`) of `NotificationType` such that `BluetoothNotification` can be used where `NotificationType` is expected? Indicates __inheritance__.

Does `BluetoothNotification` want only some/part of the behavior exposed by `NotificationType`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import android.content.Intent
<span class="lineno">   8 </span>import android.content.IntentFilter
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">class BluetoothNotification(private val context: Context, private val text: NotificationText) : NotificationType() {</span>
<span class="lineno">  11 </span><span class="error"></span>
<span class="lineno">  12 </span><span class="error">    override val actionText: String</span>
<span class="lineno">  13 </span><span class="error">        get() = text.actionText</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/inappnotificationpager/FirmwareNotification.kt:8:1</span><span class="message">The class `FirmwareNotification` is using inheritance, consider using composition instead.

Does `FirmwareNotification` want to expose the complete interface (`empty public interface`) of `NotificationType` such that `FirmwareNotification` can be used where `NotificationType` is expected? Indicates __inheritance__.

Does `FirmwareNotification` want only some/part of the behavior exposed by `NotificationType`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   5 </span>import androidx.core.app.TaskStackBuilder
<span class="lineno">   6 </span>import java.util.ArrayList
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">class FirmwareNotification(</span>
<span class="lineno">   9 </span><span class="error">    private val parentActivity: Activity,</span>
<span class="lineno">  10 </span><span class="error">    private val intents: ArrayList&lt;Intent&gt;,</span>
<span class="lineno">  11 </span><span class="error">    private val serial: String,</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/inappnotificationpager/LocationNotification.kt:10:1</span><span class="message">The class `LocationNotification` is using inheritance, consider using composition instead.

Does `LocationNotification` want to expose the complete interface (`empty public interface`) of `NotificationType` such that `LocationNotification` can be used where `NotificationType` is expected? Indicates __inheritance__.

Does `LocationNotification` want only some/part of the behavior exposed by `NotificationType`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   7 </span>import android.content.IntentFilter
<span class="lineno">   8 </span>import android.location.LocationManager
<span class="lineno">   9 </span>
<span class="lineno">  10 </span><span class="error">class LocationNotification(</span>
<span class="lineno">  11 </span><span class="error">    private val activity: Activity,</span>
<span class="lineno">  12 </span><span class="error">    private val text: NotificationText,</span>
<span class="lineno">  13 </span><span class="error">    private val interactionListener: NotificationInteractionListener</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/inappnotificationpager/NotificationText.kt:12:1</span><span class="message">The class `BtNotificationText` is using inheritance, consider using composition instead.

Does `BtNotificationText` want to expose the complete interface (`empty public interface`) of `NotificationText` such that `BtNotificationText` can be used where `NotificationText` is expected? Indicates __inheritance__.

Does `BtNotificationText` want only some/part of the behavior exposed by `NotificationText`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>    abstract val actionText: String
<span class="lineno">  10 </span>}
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class BtNotificationText(val context: Context) : NotificationText() {</span>
<span class="lineno">  13 </span><span class="error">    override val infoText: String = context.resources.getString(R.string.bluetooth_is_disabled)</span>
<span class="lineno">  14 </span><span class="error">    override val actionText: String = context.resources.getString(R.string.bluetooth_enable)</span>
<span class="lineno">  15 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/inappnotificationpager/NotificationText.kt:17:1</span><span class="message">The class `LocationNotificationText` is using inheritance, consider using composition instead.

Does `LocationNotificationText` want to expose the complete interface (`empty public interface`) of `NotificationText` such that `LocationNotificationText` can be used where `NotificationText` is expected? Indicates __inheritance__.

Does `LocationNotificationText` want only some/part of the behavior exposed by `NotificationText`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  14 </span>    override val actionText: String = context.resources.getString(R.string.bluetooth_enable)
<span class="lineno">  15 </span>}
<span class="lineno">  16 </span>
<span class="lineno">  17 </span><span class="error">class LocationNotificationText(val context: Context) : NotificationText() {</span>
<span class="lineno">  18 </span><span class="error">    override val infoText: String = context.getString(R.string.location_disabled)</span>
<span class="lineno">  19 </span><span class="error">    override val actionText: String = context.getString(R.string.enable_location)</span>
<span class="lineno">  20 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/inappnotificationpager/NotificationText.kt:22:1</span><span class="message">The class `FwUpdateNotificationText` is using inheritance, consider using composition instead.

Does `FwUpdateNotificationText` want to expose the complete interface (`empty public interface`) of `NotificationText` such that `FwUpdateNotificationText` can be used where `NotificationText` is expected? Indicates __inheritance__.

Does `FwUpdateNotificationText` want only some/part of the behavior exposed by `NotificationText`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  19 </span>    override val actionText: String = context.getString(R.string.enable_location)
<span class="lineno">  20 </span>}
<span class="lineno">  21 </span>
<span class="lineno">  22 </span><span class="error">class FwUpdateNotificationText(val context: Context) : NotificationText() {</span>
<span class="lineno">  23 </span><span class="error">    override val infoText: String</span>
<span class="lineno">  24 </span><span class="error">        get() = context.getString(R.string.firmware_update_an_update_available, serialNumber)</span>
<span class="lineno">  25 </span><span class="error">    override val actionText: String = context.getString(R.string.firmware_update)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/menu/MenuItemWithButton.kt:12:1</span><span class="message">The class `MenuItemWithButton` is using inheritance, consider using composition instead.

Does `MenuItemWithButton` want to expose the complete interface (`Exposing interface of a Java superclass is not supported`) of `MenuItemWidget` such that `MenuItemWithButton` can be used where `MenuItemWidget` is expected? Indicates __inheritance__.

Does `MenuItemWithButton` want only some/part of the behavior exposed by `MenuItemWidget`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   9 </span>import androidx.core.content.res.ResourcesCompat
<span class="lineno">  10 </span>import com.airthings.uicomponents.R
<span class="lineno">  11 </span>
<span class="lineno">  12 </span><span class="error">class MenuItemWithButton(context: Context, attrs: AttributeSet) : MenuItemWidget(context, attrs) {</span>
<span class="lineno">  13 </span><span class="error"></span>
<span class="lineno">  14 </span><span class="error">    lateinit var button: Button</span>
<span class="lineno">  15 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusbanner/SyncStatusBanner.kt:90:1</span><span class="message">The class `IdleMode` is using inheritance, consider using composition instead.

Does `IdleMode` want to expose the complete interface (`empty public interface`) of `BannerMode` such that `IdleMode` can be used where `BannerMode` is expected? Indicates __inheritance__.

Does `IdleMode` want only some/part of the behavior exposed by `BannerMode`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  87 </span>    var color: Int? = null
<span class="lineno">  88 </span>}
<span class="lineno">  89 </span>
<span class="lineno">  90 </span><span class="error">class IdleMode : BannerMode()</span>
<span class="lineno">  91 </span>
<span class="lineno">  92 </span>class InfoMode(textRes: String) : BannerMode() {
<span class="lineno">  93 </span>    init {
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusbanner/SyncStatusBanner.kt:92:1</span><span class="message">The class `InfoMode` is using inheritance, consider using composition instead.

Does `InfoMode` want to expose the complete interface (`empty public interface`) of `BannerMode` such that `InfoMode` can be used where `BannerMode` is expected? Indicates __inheritance__.

Does `InfoMode` want only some/part of the behavior exposed by `BannerMode`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  89 </span>
<span class="lineno">  90 </span>class IdleMode : BannerMode()
<span class="lineno">  91 </span>
<span class="lineno">  92 </span><span class="error">class InfoMode(textRes: String) : BannerMode() {</span>
<span class="lineno">  93 </span><span class="error">    init {</span>
<span class="lineno">  94 </span><span class="error">        bannerTextRes = textRes</span>
<span class="lineno">  95 </span><span class="error">        color = R.color.jaggedIce</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusbanner/SyncStatusBanner.kt:99:1</span><span class="message">The class `AlertMode` is using inheritance, consider using composition instead.

Does `AlertMode` want to expose the complete interface (`empty public interface`) of `BannerMode` such that `AlertMode` can be used where `BannerMode` is expected? Indicates __inheritance__.

Does `AlertMode` want only some/part of the behavior exposed by `BannerMode`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  96 </span>    }
<span class="lineno">  97 </span>}
<span class="lineno">  98 </span>
<span class="lineno">  99 </span><span class="error">class AlertMode(textRes: String) : BannerMode() {</span>
<span class="lineno"> 100 </span><span class="error">    init {</span>
<span class="lineno"> 101 </span><span class="error">        bannerTextRes = textRes</span>
<span class="lineno"> 102 </span><span class="error">        color = R.color.albescentWhite</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusbanner/SyncStatusBanner.kt:106:1</span><span class="message">The class `AlertWithActionMode` is using inheritance, consider using composition instead.

Does `AlertWithActionMode` want to expose the complete interface (`empty public interface`) of `BannerMode` such that `AlertWithActionMode` can be used where `BannerMode` is expected? Indicates __inheritance__.

Does `AlertWithActionMode` want only some/part of the behavior exposed by `BannerMode`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 103 </span>    }
<span class="lineno"> 104 </span>}
<span class="lineno"> 105 </span>
<span class="lineno"> 106 </span><span class="error">class AlertWithActionMode(</span>
<span class="lineno"> 107 </span><span class="error">    alertText: String,</span>
<span class="lineno"> 108 </span><span class="error">    actionText: String,</span>
<span class="lineno"> 109 </span><span class="error">    invokeAction: ((Unit) -&gt; Unit)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:171:1</span><span class="message">The class `IdleConfiguration` is using inheritance, consider using composition instead.

Does `IdleConfiguration` want to expose the complete interface (`endAnimation, updateAnimatedProperty, startAnimation`) of `IndicatorConfiguration` such that `IdleConfiguration` can be used where `IndicatorConfiguration` is expected? Indicates __inheritance__.

Does `IdleConfiguration` want only some/part of the behavior exposed by `IndicatorConfiguration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 168 </span>    abstract fun endAnimation()
<span class="lineno"> 169 </span>}
<span class="lineno"> 170 </span>
<span class="lineno"> 171 </span><span class="error">class IdleConfiguration(context: Context, idleIcon: IdleIcon) : IndicatorConfiguration(context) {</span>
<span class="lineno"> 172 </span><span class="error">    override val colorCirclePaint: Paint = Paint()</span>
<span class="lineno"> 173 </span><span class="error">    override val iconResource: Int</span>
<span class="lineno"> 174 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:198:1</span><span class="message">The class `ScanningConfiguration` is using inheritance, consider using composition instead.

Does `ScanningConfiguration` want to expose the complete interface (`endAnimation, updateAnimatedProperty, startAnimation`) of `IndicatorConfiguration` such that `ScanningConfiguration` can be used where `IndicatorConfiguration` is expected? Indicates __inheritance__.

Does `ScanningConfiguration` want only some/part of the behavior exposed by `IndicatorConfiguration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 195 </span>    }
<span class="lineno"> 196 </span>}
<span class="lineno"> 197 </span>
<span class="lineno"> 198 </span><span class="error">class ScanningConfiguration(context: Context, dpToPx: DpToPx) : IndicatorConfiguration(context) {</span>
<span class="lineno"> 199 </span><span class="error">    override val colorCirclePaint: Paint = Paint()</span>
<span class="lineno"> 200 </span><span class="error">    override val iconResource: Int = R.drawable.ic_bluetooth_searching_stronghold_24dp</span>
<span class="lineno"> 201 </span><span class="error">    private val animator: ValueAnimator = ObjectAnimator.ofInt(colorCirclePaint.alpha)</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:233:1</span><span class="message">The class `BatteryAlertConfiguration` is using inheritance, consider using composition instead.

Does `BatteryAlertConfiguration` want to expose the complete interface (`endAnimation, updateAnimatedProperty, startAnimation`) of `IndicatorConfiguration` such that `BatteryAlertConfiguration` can be used where `IndicatorConfiguration` is expected? Indicates __inheritance__.

Does `BatteryAlertConfiguration` want only some/part of the behavior exposed by `IndicatorConfiguration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 230 </span>    }
<span class="lineno"> 231 </span>}
<span class="lineno"> 232 </span>
<span class="lineno"> 233 </span><span class="error">class BatteryAlertConfiguration(context: Context, dpToPx: DpToPx) : IndicatorConfiguration(context) {</span>
<span class="lineno"> 234 </span><span class="error">    override val colorCirclePaint: Paint = Paint()</span>
<span class="lineno"> 235 </span><span class="error">    private val animator = ObjectAnimator.ofInt(colorCirclePaint.alpha)</span>
<span class="lineno"> 236 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:268:1</span><span class="message">The class `CloudDownloadConfiguration` is using inheritance, consider using composition instead.

Does `CloudDownloadConfiguration` want to expose the complete interface (`endAnimation, updateAnimatedProperty, startAnimation`) of `IndicatorConfiguration` such that `CloudDownloadConfiguration` can be used where `IndicatorConfiguration` is expected? Indicates __inheritance__.

Does `CloudDownloadConfiguration` want only some/part of the behavior exposed by `IndicatorConfiguration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 265 </span>    }
<span class="lineno"> 266 </span>}
<span class="lineno"> 267 </span>
<span class="lineno"> 268 </span><span class="error">class CloudDownloadConfiguration(context: Context, dpToPx: DpToPx) : IndicatorConfiguration(context) {</span>
<span class="lineno"> 269 </span><span class="error">    override val colorCirclePaint: Paint = Paint()</span>
<span class="lineno"> 270 </span><span class="error"></span>
<span class="lineno"> 271 </span><span class="error">    init {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:294:1</span><span class="message">The class `CloudUploadConfiguration` is using inheritance, consider using composition instead.

Does `CloudUploadConfiguration` want to expose the complete interface (`endAnimation, updateAnimatedProperty, startAnimation`) of `IndicatorConfiguration` such that `CloudUploadConfiguration` can be used where `IndicatorConfiguration` is expected? Indicates __inheritance__.

Does `CloudUploadConfiguration` want only some/part of the behavior exposed by `IndicatorConfiguration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 291 </span>    }
<span class="lineno"> 292 </span>}
<span class="lineno"> 293 </span>
<span class="lineno"> 294 </span><span class="error">class CloudUploadConfiguration(context: Context, dpToPx: DpToPx) : IndicatorConfiguration(context) {</span>
<span class="lineno"> 295 </span><span class="error">    override val colorCirclePaint: Paint = Paint()</span>
<span class="lineno"> 296 </span><span class="error"></span>
<span class="lineno"> 297 </span><span class="error">    init {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:320:1</span><span class="message">The class `CloudOfflineConfiguration` is using inheritance, consider using composition instead.

Does `CloudOfflineConfiguration` want to expose the complete interface (`endAnimation, updateAnimatedProperty, startAnimation`) of `IndicatorConfiguration` such that `CloudOfflineConfiguration` can be used where `IndicatorConfiguration` is expected? Indicates __inheritance__.

Does `CloudOfflineConfiguration` want only some/part of the behavior exposed by `IndicatorConfiguration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 317 </span>    }
<span class="lineno"> 318 </span>}
<span class="lineno"> 319 </span>
<span class="lineno"> 320 </span><span class="error">class CloudOfflineConfiguration(context: Context, dpToPx: DpToPx) : IndicatorConfiguration(context) {</span>
<span class="lineno"> 321 </span><span class="error">    override val colorCirclePaint: Paint = Paint()</span>
<span class="lineno"> 322 </span><span class="error"></span>
<span class="lineno"> 323 </span><span class="error">    init {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:346:1</span><span class="message">The class `BluetoothDisabledConfiguration` is using inheritance, consider using composition instead.

Does `BluetoothDisabledConfiguration` want to expose the complete interface (`endAnimation, updateAnimatedProperty, startAnimation`) of `IndicatorConfiguration` such that `BluetoothDisabledConfiguration` can be used where `IndicatorConfiguration` is expected? Indicates __inheritance__.

Does `BluetoothDisabledConfiguration` want only some/part of the behavior exposed by `IndicatorConfiguration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 343 </span>    }
<span class="lineno"> 344 </span>}
<span class="lineno"> 345 </span>
<span class="lineno"> 346 </span><span class="error">class BluetoothDisabledConfiguration(context: Context, dpToPx: DpToPx) : IndicatorConfiguration(context) {</span>
<span class="lineno"> 347 </span><span class="error">    override val colorCirclePaint: Paint = Paint()</span>
<span class="lineno"> 348 </span><span class="error">    private val animator = ObjectAnimator.ofInt(colorCirclePaint.alpha)</span>
<span class="lineno"> 349 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:381:1</span><span class="message">The class `ReadingFromInstrumentConfiguration` is using inheritance, consider using composition instead.

Does `ReadingFromInstrumentConfiguration` want to expose the complete interface (`endAnimation, updateAnimatedProperty, startAnimation`) of `IndicatorConfiguration` such that `ReadingFromInstrumentConfiguration` can be used where `IndicatorConfiguration` is expected? Indicates __inheritance__.

Does `ReadingFromInstrumentConfiguration` want only some/part of the behavior exposed by `IndicatorConfiguration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 378 </span>    }
<span class="lineno"> 379 </span>}
<span class="lineno"> 380 </span>
<span class="lineno"> 381 </span><span class="error">class ReadingFromInstrumentConfiguration(context: Context, dpToPx: DpToPx) : IndicatorConfiguration(context) {</span>
<span class="lineno"> 382 </span><span class="error">    override val colorCirclePaint: Paint = Paint()</span>
<span class="lineno"> 383 </span><span class="error">    private val animator = ObjectAnimator.ofInt(colorCirclePaint.alpha)</span>
<span class="lineno"> 384 </span><span class="error"></span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:416:1</span><span class="message">The class `InstrumentOfflineConfiguration` is using inheritance, consider using composition instead.

Does `InstrumentOfflineConfiguration` want to expose the complete interface (`endAnimation, updateAnimatedProperty, startAnimation`) of `IndicatorConfiguration` such that `InstrumentOfflineConfiguration` can be used where `IndicatorConfiguration` is expected? Indicates __inheritance__.

Does `InstrumentOfflineConfiguration` want only some/part of the behavior exposed by `IndicatorConfiguration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 413 </span>    }
<span class="lineno"> 414 </span>}
<span class="lineno"> 415 </span>
<span class="lineno"> 416 </span><span class="error">class InstrumentOfflineConfiguration(</span>
<span class="lineno"> 417 </span><span class="error">    val context: Context,</span>
<span class="lineno"> 418 </span><span class="error">    dpToPx: DpToPx,</span>
<span class="lineno"> 419 </span><span class="error">    private val stateContext: StateContext</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:473:1</span><span class="message">The class `ConnectedConfiguration` is using inheritance, consider using composition instead.

Does `ConnectedConfiguration` want to expose the complete interface (`endAnimation, updateAnimatedProperty, startAnimation`) of `IndicatorConfiguration` such that `ConnectedConfiguration` can be used where `IndicatorConfiguration` is expected? Indicates __inheritance__.

Does `ConnectedConfiguration` want only some/part of the behavior exposed by `IndicatorConfiguration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 470 </span>    }
<span class="lineno"> 471 </span>}
<span class="lineno"> 472 </span>
<span class="lineno"> 473 </span><span class="error">open class ConnectedConfiguration(context: Context, dpToPx: DpToPx) : IndicatorConfiguration(context) {</span>
<span class="lineno"> 474 </span><span class="error">    final override val colorCirclePaint: Paint = Paint()</span>
<span class="lineno"> 475 </span><span class="error"></span>
<span class="lineno"> 476 </span><span class="error">    init {</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/main/java/com/airthings/uicomponents/view/widget/syncstatusindicator/SyncStatusIndicator.kt:499:1</span><span class="message">The class `SignalQualityConfiguration` is using inheritance, consider using composition instead.

Does `SignalQualityConfiguration` want to expose the complete interface (`endAnimation, updateAnimatedProperty, startAnimation`) of `ConnectedConfiguration` such that `SignalQualityConfiguration` can be used where `ConnectedConfiguration` is expected? Indicates __inheritance__.

Does `SignalQualityConfiguration` want only some/part of the behavior exposed by `ConnectedConfiguration`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 496 </span>    }
<span class="lineno"> 497 </span>}
<span class="lineno"> 498 </span>
<span class="lineno"> 499 </span><span class="error">class SignalQualityConfiguration(</span>
<span class="lineno"> 500 </span><span class="error">    context: Context,</span>
<span class="lineno"> 501 </span><span class="error">    dpToPx: DpToPx,</span>
<span class="lineno"> 502 </span><span class="error">    val value: ConfigurationType</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/test/java/com/airthings/uicomponents/view/widget/graph/GraphViewAdapterTest.kt:126:5</span><span class="message">The class `GraphViewAdapterMockImpl` is using inheritance, consider using composition instead.

Does `GraphViewAdapterMockImpl` want to expose the complete interface (`getValue, getValueList`) of `GraphViewAdapter` such that `GraphViewAdapterMockImpl` can be used where `GraphViewAdapter` is expected? Indicates __inheritance__.

Does `GraphViewAdapterMockImpl` want only some/part of the behavior exposed by `GraphViewAdapter`? Indicates __Composition__.</span>
        <pre><code><span class="lineno"> 123 </span>            assertEquals(50f, bucketValue)
<span class="lineno"> 124 </span>    }
<span class="lineno"> 125 </span>
<span class="lineno"> 126 </span>    <span class="error">private inner class GraphViewAdapterMockImpl : GraphViewAdapter(ValueFormatter(Locale.getDefault()), 0, 0) {</span>
<span class="lineno"> 127 </span><span class="error">        override fun getValueList(from: Long, to: Long, sensor: Int): TreeMap&lt;Long, Float&gt; {</span>
<span class="lineno"> 128 </span><span class="error">            return TreeMap(testValues.subMap(from, to))</span>
<span class="lineno"> 129 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/test/java/com/airthings/uicomponents/view/widget/inappnotificationpager/NotificationPagerAdapterTest.kt:83:5</span><span class="message">The class `TestText` is using inheritance, consider using composition instead.

Does `TestText` want to expose the complete interface (`empty public interface`) of `NotificationText` such that `TestText` can be used where `NotificationText` is expected? Indicates __inheritance__.

Does `TestText` want only some/part of the behavior exposed by `NotificationText`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  80 </span>        assertEquals(0, pagerAdapter!!.count.toLong())
<span class="lineno">  81 </span>    }
<span class="lineno">  82 </span>
<span class="lineno">  83 </span>    <span class="error">internal inner class TestText : NotificationText() {</span>
<span class="lineno">  84 </span><span class="error"></span>
<span class="lineno">  85 </span><span class="error">        override val infoText: String</span>
<span class="lineno">  86 </span><span class="error">            get() = &quot;Code nuh!$serialNumber&quot;</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-uicomponents/src/test/java/com/airthings/uicomponents/view/widget/inappnotificationpager/NotificationPagerAdapterTest.kt:92:5</span><span class="message">The class `NotificationContainerViewMock` is using inheritance, consider using composition instead.

Does `NotificationContainerViewMock` want to expose the complete interface (`setViewPagerAdapter, addNotification`) of `NotificationContainerView` such that `NotificationContainerViewMock` can be used where `NotificationContainerView` is expected? Indicates __inheritance__.

Does `NotificationContainerViewMock` want only some/part of the behavior exposed by `NotificationContainerView`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  89 </span>            get() = &quot;Code nuh! Nuh!&quot;
<span class="lineno">  90 </span>    }
<span class="lineno">  91 </span>
<span class="lineno">  92 </span>    <span class="error">class NotificationContainerViewMock : NotificationContainerView(mock(Context::class.java)) {</span>
<span class="lineno">  93 </span><span class="error">        override fun setViewPagerAdapter(adapter: NotificationPagerAdapter?) {</span>
<span class="lineno">  94 </span><span class="error">            // INTENTIONAL STUB</span>
<span class="lineno">  95 </span><span class="error">        }</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-utilities/src/main/java/com/airthings/utilities/Try.kt:8:1</span><span class="message">The class `Success` is using inheritance, consider using composition instead.

Does `Success` want to expose the complete interface (`isFailure, isSuccess`) of `Try` such that `Success` can be used where `Try` is expected? Indicates __inheritance__.

Does `Success` want only some/part of the behavior exposed by `Try`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">   5 </span>    abstract fun isFailure(): Boolean
<span class="lineno">   6 </span>}
<span class="lineno">   7 </span>
<span class="lineno">   8 </span><span class="error">data class Success&lt;out T&gt;(val value: T) : Try&lt;T&gt;() {</span>
<span class="lineno">   9 </span><span class="error">    override fun isSuccess() = true</span>
<span class="lineno">  10 </span><span class="error">    override fun isFailure() = false</span>
<span class="lineno">  11 </span><span class="error">}</span>
</code></pre>
      </li>
      <li><span class="location">/Users/mariuskohmann/Code/Work/Airthings/unifiedandroidapps/module-utilities/src/main/java/com/airthings/utilities/Try.kt:13:1</span><span class="message">The class `Failure` is using inheritance, consider using composition instead.

Does `Failure` want to expose the complete interface (`isFailure, isSuccess`) of `Try` such that `Failure` can be used where `Try` is expected? Indicates __inheritance__.

Does `Failure` want only some/part of the behavior exposed by `Try`? Indicates __Composition__.</span>
        <pre><code><span class="lineno">  10 </span>    override fun isFailure() = false
<span class="lineno">  11 </span>}
<span class="lineno">  12 </span>
<span class="lineno">  13 </span><span class="error">data class Failure&lt;out T&gt;(val e: Throwable) : Try&lt;T&gt;() {</span>
<span class="lineno">  14 </span><span class="error">    override fun isSuccess() = false</span>
<span class="lineno">  15 </span><span class="error">    override fun isFailure() = true</span>
<span class="lineno">  16 </span><span class="error">}</span>
</code></pre>
      </li>
    </ul>
  </details>
</div>


generated with <a href="https://arturbosch.github.io/detekt">detekt version 1.7.4</a> on 2020-04-23 08:51:48 UTC.

</body>
</html>
